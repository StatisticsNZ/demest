

/* predict models not using exposure*/
void predictModelNotUseExp_NormalFixedVarsigmaKnownPredict(SEXP object, SEXP y_R);
void predictModelNotUseExp_NormalFixedVarsigmaUnknownPredict(SEXP object, SEXP y_R);
void predictModelNotUseExp_PoissonFixedNotUseExpPredict(SEXP object, SEXP y_R);
void predictModelUseExp_BinomialFixedPredict(SEXP object, SEXP y_R, SEXP exposure_R);
void predictModelUseExp_PoissonFixedUseExpPredict(SEXP object, SEXP y_R, SEXP exposure_R);
UPDATEOBJECT_NOEXP_WRAPPER_R(predictModelNotUseExp_NormalFixedVarsigmaKnownPredict);
UPDATEOBJECT_NOEXP_WRAPPER_R(predictModelNotUseExp_NormalFixedVarsigmaUnknownPredict);
UPDATEOBJECT_NOEXP_WRAPPER_R(predictModelNotUseExp_PoissonFixedNotUseExpPredict);
UPDATEOBJECT_WITHEXP_WRAPPER_R(predictModelUseExp_BinomialFixedPredict);
UPDATEOBJECT_WITHEXP_WRAPPER_R(predictModelUseExp_PoissonFixedUseExpPredict);
CALLDEF(predictModelNotUseExp_NormalFixedVarsigmaKnownPredict_R, 2),
CALLDEF(predictModelNotUseExp_NormalFixedVarsigmaUnknownPredict_R, 2),
CALLDEF(predictModelNotUseExp_PoissonFixedNotUseExpPredict_R, 2),
CALLDEF(predictModelUseExp_BinomialFixedPredict_R, 3),
CALLDEF(predictModelUseExp_PoissonFixedUseExpPredict_R, 3),

static __inline__ void
predictModelNotUseExp_PoissonFixedNotUseExpPredict_i(SEXP object, SEXP y_R)
{
    /* updateTheta_PoissonFixedNotUseExp(object, y = y) */
    
    updateTheta_PoissonFixedNotUseExp(object, y_R);
    
}
static __inline__ void
predictModelNotUseExp_NormalFixedVarsigmaKnownPredict_i(SEXP object, SEXP y_R)
{
    /* object <- updateTheta_NormalFixed(object, y = y) */
    
    updateTheta_NormalFixed(object, y_R);
    
}
static __inline__ void
predictModelNotUseExp_NormalFixedVarsigmaUnknownPredict_i(SEXP object, SEXP y_R) 
{
    /* object <- updateTheta_NormalFixed(object, y = y)) */
    
    updateTheta_NormalFixed(object, y_R);
    
}
static __inline__ void
predictModelUseExp_BinomialFixedPredict_i(SEXP object, SEXP y_R, SEXP exposure_R)
{
    /* updateTheta_BinomialFixed(object, y = y, exposure = exposure) */
                  
    updateTheta_BinomialFixed(object, y_R, exposure_R);
}


static __inline__ void
predictModelUseExp_PoissonFixedUseExpPredict_i(SEXP object, SEXP y_R, SEXP exposure_R)
{
    /* updateTheta_PoissonFixedUseExp(object, y = y, exposure = exposure)) */
    
    updateTheta_PoissonFixedUseExp(object, y_R, exposure_R);    
}
		case 101:
            predictModelNotUseExp_NormalFixedVarsigmaKnownPredict_i(object, y_R);
            break;
        case 102:
            predictModelNotUseExp_NormalFixedVarsigmaUnknownPredict_i(object, y_R);
            break;
        case 103:
            predictModelNotUseExp_PoissonFixedNotUseExpPredict_i(object, y_R);
            break;
        case 107: 
            predictModelUseExp_BinomialFixedPredict_i(object, y_R, exposure_R);
            break;
        case 108:
            predictModelUseExp_PoissonFixedUseExpPredict_i(object, y_R, exposure_R);
            break;
                
void
predictModelNotUseExp_NormalFixedVarsigmaKnownPredict(SEXP object, SEXP y_R) 
{
    predictModelNotUseExp_NormalFixedVarsigmaKnownPredict_i(object, y_R);
    
}
void
predictModelNotUseExp_NormalFixedVarsigmaUnknownPredict(SEXP object, SEXP y_R) 
{
    predictModelNotUseExp_NormalFixedVarsigmaUnknownPredict_i(object, y_R);
    
}


void
predictModelUseExp_BinomialFixedPredict(SEXP object, SEXP y_R, SEXP exposure_R)
{
    predictModelUseExp_BinomialFixedPredict_i(object, y_R, exposure_R);
    
}

void
predictModelUseExp_PoissonFixedUseExpPredict(SEXP object, SEXP y_R, SEXP exposure_R)
{
   predictModelUseExp_PoissonFixedUseExpPredict_i(object, y_R, exposure_R);
    
}


void transferParamModel_NormalFixedVarsigmaKnownPredict(SEXP model_R, 
        const char *filename, int lengthIter, int iteration);
void transferParamModel_NormalFixedVarsigmaUnknownPredict(SEXP model_R, 
        const char *filename, int lengthIter, int iteration);
void transferParamModel_PoissonFixedNotUseExpPredict(SEXP model_R, 
        const char *filename, int lengthIter, int iteration);
void transferParamModel_BinomialFixedPredict(SEXP model_R, 
        const char *filename, int lengthIter, int iteration);
void transferParamModel_PoissonFixedUseExpPredict(SEXP model_R, 
        const char *filename, int lengthIter, int iteration);
TRANSFERPARAM_WRAPPER_R(transferParamModel_NormalFixedVarsigmaKnownPredict);
TRANSFERPARAM_WRAPPER_R(transferParamModel_NormalFixedVarsigmaUnknownPredict);
TRANSFERPARAM_WRAPPER_R(transferParamModel_PoissonFixedNotUseExpPredict);
TRANSFERPARAM_WRAPPER_R(transferParamModel_BinomialFixedPredict);
TRANSFERPARAM_WRAPPER_R(transferParamModel_PoissonFixedUseExpPredict);
CALLDEF(transferParamModel_NormalFixedVarsigmaKnownPredict_R, 4),
CALLDEF(transferParamModel_NormalFixedVarsigmaUnknownPredict_R, 4),
CALLDEF(transferParamModel_PoissonFixedNotUseExpPredict_R, 4),
CALLDEF(transferParamModel_BinomialFixedPredict_R, 4),
CALLDEF(transferParamModel_PoissonFixedUseExpPredict_R, 4),
static __inline__ void
transferParamModel_NormalFixedVarsigmaKnownPredict_i(SEXP model_R, const char *filename,
                                int lengthIter, int iteration)
{
    transferParamSigma(model_R, filename, lengthIter, iteration);
}

static __inline__ void
transferParamModel_NormalFixedVarsigmaUnknownPredict_i(SEXP model_R, const char *filename,
                                int lengthIter, int iteration)
{
    transferParamVarsigma(model_R, filename, lengthIter, iteration);
    transferParamSigma(model_R, filename, lengthIter, iteration);
}


static __inline__ void
transferParamModel_PoissonFixedNotUseExpPredict_i(SEXP model_R, const char *filename,
                                int lengthIter, int iteration)
{
    transferParamSigma(model_R, filename, lengthIter, iteration);
}


static __inline__ void
transferParamModel_BinomialFixedPredict_i(SEXP model_R, const char *filename,
                                int lengthIter, int iteration)
{
    transferParamSigma(model_R, filename, lengthIter, iteration);
}


static __inline__ void
transferParamModel_PoissonFixedUseExpPredict_i(SEXP model_R, const char *filename,
                                int lengthIter, int iteration)
{
    transferParamSigma(model_R, filename, lengthIter, iteration);
}
        case 101: 
            transferParamModel_NormalFixedVarsigmaKnownPredict_i(model_R, 
                        filename, lengthIter, iteration);
            break;
        case 102: 
            transferParamModel_NormalFixedVarsigmaUnknownPredict_i(model_R, 
                        filename, lengthIter, iteration);
            break;
        case 103: 
            transferParamModel_PoissonFixedNotUseExpPredict_i(model_R, 
                        filename, lengthIter, iteration);
            break;
		case 107: 
            transferParamModel_BinomialFixedPredict_i(model_R, 
                        filename, lengthIter, iteration);
            break;
        case 108: 
            transferParamModel_PoissonFixedUseExpPredict_i(model_R, 
                        filename, lengthIter, iteration);
            break;
void
transferParamModel_NormalFixedVarsigmaKnownPredict(SEXP model_R, const char *filename,
                                int lengthIter, int iteration)
{
    transferParamModel_NormalFixedVarsigmaKnownPredict_i(model_R, filename, 
                                lengthIter, iteration);
}
void
transferParamModel_NormalFixedVarsigmaUnknownPredict(SEXP model_R, const char *filename,
                                int lengthIter, int iteration)
{
    transferParamModel_NormalFixedVarsigmaUnknownPredict_i(model_R, filename, 
                                lengthIter, iteration);
}
void
transferParamModel_PoissonFixedNotUseExpPredict(SEXP model_R, const char *filename,
                                int lengthIter, int iteration)
{
    transferParamModel_PoissonFixedNotUseExpPredict_i(model_R, filename, 
                                lengthIter, iteration);
}
void
transferParamModel_BinomialFixedPredict(SEXP model_R, const char *filename,
                                int lengthIter, int iteration)
{
    transferParamModel_BinomialFixedPredict_i(model_R, filename, 
                                lengthIter, iteration);
}
void
transferParamModel_PoissonFixedUseExpPredict(SEXP model_R, const char *filename,
                                int lengthIter, int iteration)
{
    transferParamModel_PoissonFixedUseExpPredict_i(model_R, filename, 
                                lengthIter, iteration);
}
        
void updateModelNotUseExp_NormalFixedVarsigmaKnown(SEXP object, SEXP y_R);
void updateModelNotUseExp_NormalFixedVarsigmaUnknown(SEXP object, SEXP y_R);
void updateModelNotUseExp_PoissonFixedNotUseExp(SEXP object, SEXP y_R);
void updateModelUseExp_BinomialFixed(SEXP object, SEXP y_R, SEXP exposure_R);
void updateModelUseExp_PoissonFixedUseExp(SEXP object, SEXP y_R, SEXP exposure_R);
UPDATEOBJECT_NOEXP_WRAPPER_R(updateModelNotUseExp_NormalFixedVarsigmaKnown);
UPDATEOBJECT_NOEXP_WRAPPER_R(updateModelNotUseExp_NormalFixedVarsigmaUnknown);
UPDATEOBJECT_NOEXP_WRAPPER_R(updateModelNotUseExp_PoissonFixedNotUseExp);
UPDATEOBJECT_WITHEXP_WRAPPER_R(updateModelUseExp_BinomialFixed);
UPDATEOBJECT_WITHEXP_WRAPPER_R(updateModelUseExp_PoissonFixedUseExp);
  CALLDEF(updateModelNotUseExp_NormalFixedVarsigmaKnown_R, 2),
  CALLDEF(updateModelNotUseExp_NormalFixedVarsigmaUnknown_R, 2),
  CALLDEF(updateModelNotUseExp_PoissonFixedNotUseExp_R, 2),
  CALLDEF(updateModelUseExp_BinomialFixed_R, 3),
  CALLDEF(updateModelUseExp_PoissonFixedUseExp_R, 3),
static __inline__ void
updateModelNotUseExp_NormalFixedVarsigmaKnown_i(SEXP object, SEXP y_R)
{
    updateTheta_NormalFixed(object, y_R);
    updateSigma_NormalFixed(object);
    
}

static __inline__ void
updateModelNotUseExp_NormalFixedVarsigmaUnknown_i(SEXP object, SEXP y_R) 
{
    updateTheta_NormalFixed(object, y_R);
    updateVarsigma(object, y_R);
    updateSigma_NormalFixed(object);
    
}


static __inline__ void
updateModelNotUseExp_PoissonFixedNotUseExp_i(SEXP object, SEXP y_R)
{
    updateTheta_PoissonFixedNotUseExp(object, y_R);
    updateSigma_PoissonFixed(object);
}
static __inline__ void
updateModelUseExp_BinomialFixed_i(SEXP object, SEXP y_R, SEXP exposure_R)
{
    updateTheta_BinomialFixed(object, y_R, exposure_R);
    updateSigma_BinomialFixed(object);
    
}


static __inline__ void
updateModelUseExp_PoissonFixedUseExp_i(SEXP object, SEXP y_R, SEXP exposure_R)
{
    updateTheta_PoissonFixedUseExp(object, y_R, exposure_R);    
    updateSigma_PoissonFixed(object);
}
        case 1: 
            updateModelNotUseExp_NormalFixedVarsigmaKnown_i(object, y_R);
            break;
        case 2:
            updateModelNotUseExp_NormalFixedVarsigmaUnknown_i(object, y_R);
            break;
        case 3:
            updateModelNotUseExp_PoissonFixedNotUseExp_i(object, y_R);
            break;
        case 7: 
            updateModelUseExp_BinomialFixed_i(object, y_R, exposure_R);
            break;
        case 8:
            updateModelUseExp_PoissonFixedUseExp_i(object, y_R, exposure_R);
            break;
        case 9: 
void
updateModelNotUseExp_NormalFixedVarsigmaKnown(SEXP object, SEXP y_R) 
{
    updateModelNotUseExp_NormalFixedVarsigmaKnown_i(object, y_R);
    
}

void
updateModelNotUseExp_NormalFixedVarsigmaUnknown(SEXP object, SEXP y_R) 
{
    updateModelNotUseExp_NormalFixedVarsigmaUnknown_i(object, y_R);
    
}


void
updateModelNotUseExp_PoissonFixedNotUseExp(SEXP object, SEXP y_R)
{
   updateModelNotUseExp_PoissonFixedNotUseExp_i(object, y_R);
    
}

void
updateModelUseExp_BinomialFixed(SEXP object, SEXP y_R, SEXP exposure_R)
{
    updateModelUseExp_BinomialFixed_i(object, y_R, exposure_R);
    
}

void
updateModelUseExp_PoissonFixedUseExp(SEXP object, SEXP y_R, SEXP exposure_R)
{
   updateModelUseExp_PoissonFixedUseExp_i(object, y_R, exposure_R);
    
}

void updateDeltaHatAR11(SEXP prior_R);
UPDATEOBJECT_NOPRNG_WRAPPER_R(updateDeltaHatAR11);
CALLDEF(updateDeltaHatAR11_R, 1),

void
updateDeltaHatAR11(SEXP prior_R)
{
    int K = *INTEGER(GET_SLOT(prior_R, K_sym)); /*scalar integer */
    int L = *INTEGER(GET_SLOT(prior_R, L_sym)); /*scalar integer */
    double *delta = REAL(GET_SLOT(prior_R, delta_sym)); /*length (K+1)L */
    double *deltaHat = REAL(GET_SLOT(prior_R, deltaHat_sym)); /*length KL */
    
    double phi = *REAL(GET_SLOT(prior_R, phi_sym)); /*scalar double */
    
    SEXP iterDelta_R = GET_SLOT(prior_R, iteratorGamma_sym); /* AlongIterator */
    SEXP iterDeltaHat_R = GET_SLOT(prior_R, iteratorV_sym); /* AlongIterator */
    
    resetA(iterDelta_R);
    resetA(iterDeltaHat_R);
    
    int *indicesDelta = INTEGER(GET_SLOT(iterDelta_R, indices_sym));
    int *indicesDeltaHat = INTEGER(GET_SLOT(iterDeltaHat_R, indices_sym));

    for (int l = 0; l < L; ++l) {

        for (int k = 0; k < K; ++k) {
            
            int i = indicesDelta[k] - 1;
            int ih = indicesDeltaHat[k] - 1;
            deltaHat[ih] = phi * delta[i];
        }
        advanceA(iterDelta_R);
        advanceA(iterDeltaHat_R); 
    }
}
    
void updateDeltaNoInitialAR11(SEXP prior_R);
UPDATEOBJECT_NOPRNG_WRAPPER_R(updateDeltaNoInitialAR11);
  CALLDEF(updateDeltaNoInitialAR11_R, 1),
void
updateDeltaNoInitialAR11(SEXP prior_R)
{
        
    int K = *INTEGER(GET_SLOT(prior_R, K_sym)); /*scalar integer */
    int L = *INTEGER(GET_SLOT(prior_R, L_sym)); /*scalar integer */

    double *deltaHas = REAL(GET_SLOT(prior_R, delta_sym)); /*length (K+1)L */
    double *deltaNot = REAL(GET_SLOT(prior_R, deltaNoInitial_sym)); /*length KL */
    
    SEXP iterHas_R = GET_SLOT(prior_R, iteratorGamma_sym); /* AlongIterator */
    SEXP iterNot_R = GET_SLOT(prior_R, iteratorV_sym); /* AlongIterator */
    
    resetA(iterHas_R);
    resetA(iterNot_R);
    
    int *indicesHas = INTEGER(GET_SLOT(iterHas_R, indices_sym));
    int *indicesNot = INTEGER(GET_SLOT(iterNot_R, indices_sym));

    for (int l = 0; l < L; ++l) {
         
        for (int k = 0; k < K; ++k) {
            
            int i_has = indicesHas[k+1] - 1;
            int i_not = indicesNot[k] - 1;
            deltaNot[i_not] = deltaHas[i_has];
        }

        advanceA(iterHas_R);
        advanceA(iterNot_R); 
    }
}
void updateEtaNorm(SEXP prior, SEXP beta_R);
void updateEtaRobust(SEXP prior, SEXP beta_R);
UPDATEPRIOR_WRAPPER_R(updateEtaNorm);
UPDATEPRIOR_WRAPPER_R(updateEtaRobust);
CALLDEF(updateEtaNorm_R, 2),
  CALLDEF(updateEtaRobust_R, 2),
/* update eta for Normal with Covariates prior */
void
updateEtaNorm(SEXP prior, SEXP beta_R)
{
    /* z <- prior@Z */
    SEXP z_R = GET_SLOT(prior, Z_sym);
    int *z_dim =  INTEGER(GET_DIM(z_R));
    int J = z_dim[0];
    int P = z_dim[1];
    double *z = REAL(z_R);

    /* tau <- prior@tau, tau is a double*/
    double tau = *(REAL(GET_SLOT(prior,tau_sym)));

    /* get eta so that we can change it in place */
    double *eta = REAL(GET_SLOT(prior,eta_sym));

    double *beta = REAL(beta_R);


    /* make a workspace that allows for:
     * P*J doubles for qr
     * P doubles for qraux_and_g
     * J doubles for qty
     * P doubles for eta_hat
     * = P*J + P + J + P = P(J+2) + J doubles altogether */

    double *workspace = (double *)R_alloc((P*(J+2) + J), sizeof(double));

    /* QR <- qr(Z)
     * But now have to do this in two stages with the linpack
     * calls dqrdc (qr decomposition) and dqrsl (to get eta_hat)*/

    /* copy z because dqrdc call will change the matrix passed in
     * and copy into qr which is first P*J elements of workspace*/
    double *qr = workspace;
    memcpy(qr, z, P*J*sizeof(double));

    /* qraux is filled in by call to dqrdc and used in call to dqrsl
     * point this to (P*J)th element of workspace
     * qraux_and_g is P doubles */
    double *qraux_and_g = workspace + P*J;
    int jpvt = 0; /* not pivoting */

    double work_qr = 0; /* work not needed since we are not pivoting */
    /* matrix passed to dqrdc is going to be changed so need to copy it */
    int job_qr = 0; /* no pivoting */

    F77_CALL(dqrdc)(qr, &J, &J, &P, qraux_and_g, &jpvt,
                            &work_qr, &job_qr);
    /* after the call, qr contains R in its upper triangle and below
     * the diagonal qr contains info from which the orthogonal part
     * of the decomposition can be recovered,
     * and qraux contains the information required to be able to do this
     */

    /* eta.hat <- qr.coef(QR, beta) */
    /* in the call parameters, parameter x = our qr and y = our beta */
    double qy = 0; /* q*y results if requested - not needed */

    /* transpose(q)*y results - needed since we want eta_hat (b)
     * point qty to (P*J + P)th element of workspace
     * qty needs J doubles*/
    double *qty = workspace + P*J + P;

    /* in the call parameters, parameter b = eta_hat
     * point eta_hat to (P*J + P + J)th element of workspace
     * eta_hat is P doubles (all that is left of workspace)*/
    double *eta_hat = workspace + P*J + P + J;

    double rsd = 0; /* residual y  - z*b if req - not needed */
    double xb = 0; /* x*b if req - not needed */
    int job_sl = 100; /* set to compute b (eta_hat) only */
    int info = 0; /* could be changed by call */

    F77_CALL(dqrsl)(qr, &J, &J, &P, qraux_and_g, beta,
                    &qy, qty, eta_hat, &rsd, &xb, &job_sl, &info);
    if (info) error("error in dqrsl in updateEtaNorm: %d", info);

    /* g <- rnorm(n = P)
     * we no longer need qraux, so now use this as g */
    for (int i = 0; i < P; ++i) {
            qraux_and_g[i] = rnorm(0.0, 1.0);
    } /* g is b in the dtrsl parameters */

    /* eta <- eta.hat + tau * backsolve(R, g)
     * do backsolve part using dtrsl from linpack */
    int job_bsl = 01; /* solve t*x = b, t upper triangular */
    F77_CALL(dtrsl)(qr, &J, &P, qraux_and_g, &job_bsl, &info);
    if (info) error("error in dtrsl in updateEtaNorm: %d", info);
    /* after the call, g contains the solution */

    /* eta <- eta.hat + tau * backsolve(R, g); prior@eta <- eta */
    for (int i = 0; i < P; ++i) {
            eta[i] = eta_hat[i] + tau * qraux_and_g[i];
    }
}

/* update eta for Normal with Covariates prior, robust version */
void
updateEtaRobust(SEXP prior, SEXP beta_R)
{
    /* z <- prior@Z */
    SEXP z_R = GET_SLOT(prior, Z_sym);
    int *z_dim =  INTEGER(GET_DIM(z_R));
    int J = z_dim[0];
    int P = z_dim[1];
    double *z = REAL(z_R);


    /* U <- prior@U */
    double *u = REAL(GET_SLOT(prior,U_sym));

    /* get eta so that we can change it in place */
    double *eta = REAL(GET_SLOT(prior,eta_sym));

    double *beta = REAL(beta_R);

    /* make a workspace that allows for:
     * P*J doubles for qr
     * P doubles for qraux_and_g
     * J doubles for beta_scaled (also acts as qty)
     * P doubles for eta_hat
     * = P*J + P + J + P = P(J+2) + J doubles altogether */

    double *workspace = (double *)R_alloc((P*(J+2) + J), sizeof(double));

    /* D <- diag(1 / sqrt(U)); Z <- D %*% Z
     * and we need to copy z anyway
     * because dqrdc call will change the matrix passed in
     * and copy into qr which is first P*J elements of workspace*/
    double *qr = workspace;
    for (int i = 0; i < P*J; ++i) {
            qr[i] = z[i]/sqrt(u[i%J]); /* z is in column major order */
    }

    /* QR <- qr(Z) where Z is the new Z, Z <- D %*%
     * But now have to do this in two stages with the linpack
     * calls dqrdc (qr decomposition) and dqrsl (to get eta_hat)*/

    /* qraux is filled in by call to dqrdc and used in call to dqrsl
     * point this to (P*J)th element of workspace
     * qraux_and_g is P doubles */
    double *qraux_and_g = workspace + P*J;
    int jpvt = 0; /* not pivoting */

    double work_qr = 0; /* work not needed since we are not pivoting */
    int job_qr = 0; /* no pivoting */

    F77_CALL(dqrdc)(qr, &J, &J, &P, qraux_and_g, &jpvt,
                            &work_qr, &job_qr);
    /* after the call, qr contains R in its upper triangle and below
     * the diagonal qr contains info from which the orthogonal part
     * of the decomposition can be recovered,
     * and qraux contains the information required to be able to do this
     */

    /* eta.hat <- qr.coef(QR, beta) */
    /* in the call parameters, parameter x = our qr and y = our beta */
    double qy = 0; /* q*y results if requested - not needed */

    /* space for beta_scaled, which will also act as qty in dqrsl
     * point beta_scaled to (P*J + P)th element of workspace
     * beta_scaled needs J doubles*/
    double *beta_scaled = workspace + P*J + P;

    /* beta.scaled <- drop(D %*% beta)  */
    for (int i = 0; i < J; ++i) {
            beta_scaled[i] = beta[i]/sqrt(u[i]);
    }

    /* in the call parameters, parameter b = eta_hat
     * point eta_hat to (P*J + P + J)th element of workspace
     * eta_hat is P doubles (all that is left of workspace)*/
    double *eta_hat = workspace + P*J + P + J;

    double rsd = 0; /* residual y  - z*b if req - not needed */
    double xb = 0; /* x*b if req - not needed */
    int job_sl = 100; /* set to compute b (eta_hat) only */
    int info = 0; /* could be changed by call */

    /* we can use beta_scaled for qty as well */
    F77_CALL(dqrsl)(qr, &J, &J, &P, qraux_and_g, beta_scaled,
                    &qy, beta_scaled, eta_hat, &rsd, &xb, &job_sl, &info);
    if (info) error("error in dqrsl in updateEtaRobust: %d", info);
    /* after the call, we have eta_hat (b) */

    /* g <- rnorm(n = P)
     * we no longer need qraux, so now use this as g */
    for (int i = 0; i < P; ++i) {
            qraux_and_g[i] = rnorm(0.0, 1.0);
    } /* g is b in the dtrsl parameters */

    /* eta <- eta.hat * backsolve(R, g)
     * do backsolve part using dtrsl from linpack */
    int job_bsl = 01; /* solve t*x = b, t upper triangular */
    F77_CALL(dtrsl)(qr, &J, &P, qraux_and_g, &job_bsl, &info);
    if (info) error("error in dtrsl in updateEtaRobust: %d", info);
    /* after the call, qraux_and_g contains the solution */

    /* eta <- eta.hat + backsolve(R, g); prior@eta <- eta */
    for (int i = 0; i < P; ++i) {
            eta[i] = eta_hat[i] + qraux_and_g[i];
    }

}
  
void updateFinalGamma(SEXP object_R, int forward);          
UPDATEOBJECTFILTER_WRAPPER_R(updateFinalGamma);
CALLDEF(updateFinalGamma_R, 2),


void
updateFinalGamma(SEXP object_R, int forward)
{
    int J = *INTEGER(GET_SLOT(object_R, J_sym));
    int q = *INTEGER(GET_SLOT(object_R, q_sym));

    /* m a list of vector of doubles, len J+1, each vector length q */
    SEXP m_R = GET_SLOT(object_R, m_sym);
    /* UC a list of matrices of doubles, len J+1, each matrix q x q */
    SEXP UC_R = GET_SLOT(object_R, UC_sym); 
    /* DC a list of vecotrs of doubles, len J+1, each vector length q */
    SEXP DC_R = GET_SLOT(object_R, DC_sym); 
    
    /* a a list of vectors of doubles, len J, each vector length q */
    SEXP gamma_R = GET_SLOT(object_R, gamma_sym);

    int j = (forward ? J : 0 );
    
    double *thisUC = REAL(VECTOR_ELT(UC_R, j));
    double *thisDC = REAL(VECTOR_ELT(DC_R, j));
    double *this_m = REAL(VECTOR_ELT(m_R, j));
    double *this_gamma = REAL(VECTOR_ELT(gamma_R, j));

    /* allocate space for q + q*q */
    double *workspace = (double *)R_alloc(q*(q+1), sizeof(double));
    double *z = workspace; /* q */
    double *work1 = workspace + q; /* q x q */

    /* sqrt.C <- UC[[j]] %*% diag(DC[[j]], nrow = q)
    * into work1
    * and do z's at the same time */
    for (int colj = 0; colj < q; ++colj) {
        
        z[colj] = rnorm(0, 1);        
            
        double d = thisDC[colj];
        
        for (int rowi = 0; rowi < q; ++rowi) {
            work1[colj*q + rowi] = d * thisUC[colj*q + rowi];
        }
    }
    
    char transN = 'N';
    double alpha_blas_one = 1.0;
    double beta_blas_one = 1.0;
    int inc_blas = 1;
    
    /* object@gamma[[j]] <- m[[j]] + drop(sqrt.C %*% z) */
    /* put m in the gamma vector */
    memcpy(this_gamma, this_m, q*sizeof(double));
    F77_CALL(dgemv)(&transN, &q, &q, &alpha_blas_one, work1, /* sqrt.Cs is in work1 */
                    &q, z, &inc_blas, &beta_blas_one,
                    this_gamma, &inc_blas);
}

void updateGAR11(SEXP prior_R);
UPDATEOBJECT_NOPRNG_WRAPPER_R(updateGAR11);
CALLDEF(updateGAR11_R, 1),

void
updateGAR11(SEXP prior_R)
{
    double phi = *REAL(GET_SLOT(prior_R, phi_sym)); /*scalar double */
    /* G a matrix of doubles, size 2 x 2: 1, 0, 1, phi */
    double *G = REAL(GET_SLOT(prior_R, G_sym));
    G[3] = phi;
}

void updateGammaHatAR10(SEXP prior_R);
UPDATEOBJECT_NOPRNG_WRAPPER_R(updateGammaHatAR10);
CALLDEF(updateGammaHatAR10_R, 1),

void
updateGammaHatAR10(SEXP prior_R)
{
    int K = *INTEGER(GET_SLOT(prior_R, K_sym)); /*scalar integer */
    int L = *INTEGER(GET_SLOT(prior_R, L_sym)); /*scalar integer */
    double *gamma = REAL(GET_SLOT(prior_R, gamma_sym)); /*length (K+1)L */
    double *gammaHat = REAL(GET_SLOT(prior_R, gammaHat_sym)); /*length KL */
    
    double phi = *REAL(GET_SLOT(prior_R, phi_sym)); /*scalar double */
    
    SEXP iterGamma_R = GET_SLOT(prior_R, iteratorGamma_sym); /* AlongIterator */
    SEXP iterGammaHat_R = GET_SLOT(prior_R, iteratorV_sym); /* AlongIterator */
    
    resetA(iterGamma_R);
    resetA(iterGammaHat_R);
    
    int *indicesGamma = INTEGER(GET_SLOT(iterGamma_R, indices_sym));
    int *indicesGammaHat = INTEGER(GET_SLOT(iterGammaHat_R, indices_sym));

    for (int l = 0; l < L; ++l) {
         
        #ifdef DEBUGGING
            PrintValue(mkString(""));
            PrintValue(mkString("l = "));
            PrintValue(ScalarInteger(l));
        #endif
        
        for (int k = 0; k < K; ++k) {
            
            int i = indicesGamma[k] - 1;
            int ih = indicesGammaHat[k] - 1;
            gammaHat[ih] = phi * gamma[i];
            
            #ifdef DEBUGGING
                PrintValue(mkString(""));
                PrintValue(mkString("forward k = "));
                PrintValue(ScalarInteger(k));
                PrintValue(mkString("i = indicesGamma[k] - 1 = "));
                PrintValue(ScalarInteger(i));
                PrintValue(mkString("ih = indicesGammaHat[k] - 1 = "));
                PrintValue(ScalarInteger(ih));
                PrintValue(mkString("gammaHat[ih] = "));
                PrintValue(ScalarReal(gammaHat[ih]));
            #endif
            
        }

        advanceA(iterGamma_R);
        advanceA(iterGammaHat_R); 
    }
}


void updateGammaNorm(SEXP prior, SEXP beta_R);
UPDATEPRIOR_WRAPPER_R(updateGammaNorm);
CALLDEF(updateGammaNorm_R, 2),
void
updateGammaNorm(SEXP prior, SEXP beta_R)
{
    double *beta = REAL(beta_R);
    double tau = *(REAL(GET_SLOT(prior, tau_sym)));
    double *gamma = REAL(GET_SLOT(prior, gamma_sym));
    int J = LENGTH(beta_R);

    double sum_beta = 0;
    for (int i = 0; i < J; ++i)
        sum_beta += beta[i];

    double mean = sum_beta / J;

    double sd = tau / sqrt(J);

    gamma[0] = rnorm(mean, sd);
}

void updateGammaDeltaAR11(SEXP prior_R, SEXP beta_R, int forward);
SEXP updateGammaDeltaAR11_R(SEXP prior_R, SEXP beta_R, SEXP forward_R)
{
    int forward = *INTEGER(forward_R);
    SEXP ans_R;
    PROTECT(ans_R = duplicate(prior_R));
    GetRNGstate();
    updateGammaDeltaAR11(ans_R, beta_R, forward);
    PutRNGstate();
    UNPROTECT(1);
    return ans_R;
}
CALLDEF(updateGammaDeltaAR11_R, 3),

void
updateGammaDeltaAR11(SEXP prior_R, SEXP beta_R, int forward)
{
/*      a, m, UC, DC, DCinv not changed 
  * gamma, delta changed*/

    double *beta = REAL(beta_R); 

    int K = *INTEGER(GET_SLOT(prior_R, K_sym)); /*scalar integer */ 
    int L = *INTEGER(GET_SLOT(prior_R, L_sym)); /*scalar integer */ 
    double *gamma = REAL(GET_SLOT(prior_R, gamma_sym)); /*length (K+1)L */ 
    double *delta = REAL(GET_SLOT(prior_R, delta_sym)); /*length (K+1)L */ 
    double phi = *REAL(GET_SLOT(prior_R, phi_sym)); /*scalar double */ 
    double *v = REAL(GET_SLOT(prior_R, v_sym)); /*length KL */ 
    double *w = REAL(GET_SLOT(prior_R, w_sym)); /*length KL */ 
    SEXP m_R; /*list length K, elements vectors len 2 */ 
    PROTECT(m_R = duplicate(GET_SLOT(prior_R, m_sym))); 
    SEXP UC_R; /*list length K + 1, 2x2 matrices */ 
    PROTECT(UC_R = duplicate(GET_SLOT(prior_R, UC_sym))); 
    SEXP DC_R; /*list length K + 1, vectors length 2 */ 
    PROTECT(DC_R = duplicate(GET_SLOT(prior_R, DC_sym))); 
    SEXP DCInv_R; /*list length K + 1, vectors length 2 */ 
    PROTECT(DCInv_R = duplicate(GET_SLOT(prior_R, DCInv_sym))); 
    SEXP a_R; /*list length K, elements vectors len 2*/ 
    PROTECT(a_R = duplicate(GET_SLOT(prior_R, a_sym)));     
    double *G = REAL(GET_SLOT(prior_R, G_sym)); /*2x2 */ 
    
    SEXP iterGamma_R = GET_SLOT(prior_R, iteratorGamma_sym); /* AlongIterator */ 
    SEXP iterV_R = GET_SLOT(prior_R, iteratorV_sym); /* AlongIterator */ 

    resetA(iterGamma_R); 
    resetA(iterV_R); 

    int *indicesGamma = INTEGER(GET_SLOT(iterGamma_R, indices_sym)); 
    int *indicesV = INTEGER(GET_SLOT(iterV_R, indices_sym)); 

    int q = 2; /* dimensions */
    
    /* space for 2 vectors length q
     * and 4 matrices q  x q 
     * and svd work  q*(5q + 7)
     * = total  9*q + 9*q*q*/
    int nWorkspace = 9*q*(1+q);
    double *workspace = (double *)R_alloc(nWorkspace, sizeof(double));
    
    /* divvie up the workspace */
    double *singulars = workspace; /* q */
    double *DRInv = workspace + q; /* q */
    double *UR = workspace + 2*q; /* q x q */
    double *work1 = workspace + 2*q + q*q; /* q x q */
    double *work2 = workspace + 2*q + 2*q*q; /* 2*q x q */
    double *work_svd = workspace + 2*q + 4* q*q; /* q*(5q + 7) */
    
    /* allocate 8q of int space for iwork in svd */
    int *iwork_svd = (int *)R_alloc(8*q, sizeof(int));

    /* stuff needed for fortran routines */
    int info = 0;
    int lwork = q*(5*q+7); /* q*(5q + 7) */
    
    char jobz = 'O';
    char transN = 'N';
    char transT = 'T';
    
    int dim_n = q;
    
    double dummyU = 0; /* U not used */
    int ldu = 1; 
    
    double alpha_blas_one = 1.0;
    double beta_blas_zero = 0.0;
    double beta_blas_one = 1.0;
    
    int inc_blas = 1;
    
    for (int l = 0; l < L; ++l) {
        
        #ifdef DEBUGGING
            PrintValue(mkString("l"));
            PrintValue(ScalarInteger(l));
            PrintValue(ScalarInteger(l+1));
        #endif 
        
        for (int k = 0; k < K; ++k) { 
            
            int k0 = k;
            int k1 = k;
            int k2 = k+1;
            
            if (!(forward)) {
                k0 = K - k; 
                k1 = K - k - 1;
                k2 = K - k - 1;
            }
            
            #ifdef DEBUGGING
                PrintValue(mkString("k"));
                PrintValue(ScalarInteger(k));
                PrintValue(ScalarInteger(k+1));
                PrintValue(mkString("k0"));
                PrintValue(ScalarInteger(k0));
                PrintValue(ScalarInteger(k0+1));
                PrintValue(mkString("k1"));
                PrintValue(ScalarInteger(k1));
                PrintValue(ScalarInteger(k1+1));
                PrintValue(mkString("k2"));
                PrintValue(ScalarInteger(k2));
                PrintValue(ScalarInteger(k2+1));
                 
            #endif
            
            int iv = indicesV[k1] - 1; 
            double v_inv = 1/v[iv];
            if (!R_finite(v_inv)) {
                v_inv = 0;
            }

            double *thisDC = REAL(VECTOR_ELT(DC_R, k0));
            double *thisUC = REAL(VECTOR_ELT(UC_R, k0));
            double sqrt_w = sqrt(w[iv]);
            
            /* t(UC[[j0]]) %*% t(G)*/
            F77_CALL(dgemm)(&transT, &transT, &q, &q, &q,
                            &alpha_blas_one, thisUC, &q, G, &q,
                            &beta_blas_zero, work1, &q);
            /* after call, work1 contains t(UC[[k0]]) %*% t(G) */
            
            /*  *M.R <- rbind(diag(DC[[k0]], nrow = 2L) %*% t(UC[[k0]]) %*% t(G),
                             sqrt(w[iv])) */
            
            for (int colj = 0; colj < q; ++colj) { 
                
                for (int rowi = 0; rowi < q; ++rowi) {
                    double d = thisDC[rowi];
                    
                    /* use work2 to create a (q+1) x q matrix*/
                    work2 [ (q+1)*colj + rowi ] 
                                = d * work1[q * colj + rowi];
                }
                int rowi = q;
                work2 [ (q+1)*colj + rowi ] 
                                = sqrt_w;
            }
            
            for (int rowi = 0; rowi < q; ++rowi) {
                double d = thisDC[rowi];
                
                for (int colj = 0; colj < q; ++colj) { 
                    
                    /* use work2 to create a (q+1) x q matrix*/
                    work2 [ (q+1)*colj + rowi ] 
                                = d * work1[q * colj + rowi];
                }
            }
            int rowi = q;
            for (int colj = 0; colj < q; ++colj) { 
                
                work2 [ (q+1)*colj + rowi ] 
                            = sqrt_w;
            }
                
            
            #ifdef DEBUGGING
                PrintValue(mkString("t(UC[[k0]]) %*% t(G)"));
                printDblArray(work1, q*q);
                PrintValue(mkString("M.R"));
                printDblArray(work2, (q+1)*q);
               
            #endif
            
            /* MR (A for dgesdd) in work 2 */
            /* svd.R <- svd(M.R, nu = 0)
             * provide work1 for VT */
            {
                int dim_m = (q+1);
    
                F77_CALL(dgesdd)(&jobz, &dim_m, &dim_n, work2,
                                &dim_m, singulars, &dummyU, &ldu, /* U not used */
                                work1, &dim_n, /* work1 for VT */
                                work_svd, &lwork,
                                iwork_svd, &info);
                if (info) error("error in dgesdd in updateGammaDeltaAR11: %d", info); 
            }
            
            /*UR <- svd.R$v
                DR.inv <- 1 / svd.R$d
                DR.inv[is.infinite(DR.inv)] <- 0 */
            for (int rowi = 0; rowi < q; ++rowi) {
                
                double tmp = 1/singulars[rowi];
                DRInv[rowi] = ( R_finite( tmp ) ? tmp : 0.0 );
                
                for (int colj = 0; colj < q; ++colj) {
                    UR[q*colj + rowi] = work1[q*rowi + colj];
                    
                }
            }
            
            #ifdef DEBUGGING
                PrintValue(mkString("V transposed"));
                printDblArray(work1, q*q);
                PrintValue(mkString("singulars"));
                printDblArray(singulars, q);
                PrintValue(mkString("new UR"));
                printDblArray(UR, q*q);
                PrintValue(mkString("new DRInv"));
                printDblArray(DRInv, q);
                
            #endif    
        
            double sqrt_v_inv = sqrt(v_inv);
            /*M.C <- rbind(sqrt(v.inv) * UR[c(1L, 3L)],
                             diag(DR.inv, nrow = 2L)) */
            memset(work2, 0, q*(q+1) * sizeof(double));
            for (int colj = 0; colj < q; ++colj) { 
                
                for (int rowi = 0; rowi < q; ++rowi) {
                    
                    /* use work2 to create a (q+1) x q matrix*/
                    if (rowi == 0) {
                        work2 [ (q+1)*colj + rowi ] 
                                = sqrt_v_inv * UR[q*colj + rowi];
                    }
                    if (rowi == colj) {
                        work2 [ (q+1)*colj + rowi + 1] 
                                = DRInv[rowi];
                    }
                }
            }
            
            #ifdef DEBUGGING
                PrintValue(mkString("M.C"));
                printDblArray(work2, (q+1)*q);
               
            #endif
            
            /* M.C (A for dgesdd) in work2 ((q+1) x q) */
            /* svd.C <- svd(M.C, nu = 0)
             * provide work1 for VT */
            {
                int dim_m = (q+1);
                F77_CALL(dgesdd)(&jobz, &dim_m, &dim_n, work2,
                            &dim_m, singulars, &dummyU, &ldu, /* U not used */
                            work1, &dim_n, /* work1 for VT */
                            work_svd, &lwork, 
                            iwork_svd, &info);
                if (info) error("error in dgesdd in updateGammaDeltaAR11: %d", info); 
            }
            
            #ifdef DEBUGGING
                PrintValue(mkString("VT"));
                printDblArray(work1, q*q);
                PrintValue(mkString("singulars"));
                printDblArray(singulars, q);
                
            #endif
            
            double *newUC = REAL(VECTOR_ELT(UC_R, k2));
            double *newDC = REAL(VECTOR_ELT(DC_R, k2));
            double *newDCInv = REAL(VECTOR_ELT(DCInv_R, k2));
            
            /* UC[[k2]] <- UR %*% svd.C$v*/
            F77_CALL(dgemm)(&transN, &transT, &q, &q, &q,
                            &alpha_blas_one, UR, &q, 
                            work1, &q, /* work1 is t(svd.C$v)) */
                            &beta_blas_zero, newUC, &q);
        
            /*DC[[k2]] <- 1 / svd.C$d
                DC[[k2]][is.infinite(DC[[k2]])] <- 0
                DC.inv[[k2]] <- svd.C$d */
            for (int rowi = 0; rowi < q; ++rowi) {
                double d = singulars[rowi];
                double tmp = 1/d;
                newDC[rowi] = ( R_finite( tmp ) ? tmp : 0.0 );
                newDCInv[rowi] = d;
            }
            
            #ifdef DEBUGGING
                PrintValue(mkString("new UC"));
                PrintValue(VECTOR_ELT(UC_R, k2));
                PrintValue(mkString("new DC"));
                PrintValue(VECTOR_ELT(DC_R, k2));
                PrintValue(mkString("new DCInv"));
                PrintValue(VECTOR_ELT(DCInv_R, k2));
            #endif
            
            double *this_m = REAL(VECTOR_ELT(m_R, k0));
            double *new_a = REAL(VECTOR_ELT(a_R, k1));
            double *new_m = REAL(VECTOR_ELT(m_R, k2));

            #ifdef DEBUGGING
                PrintValue(mkString("this_m"));
                PrintValue(VECTOR_ELT(m_R, k0));
            #endif 

            /* a[[j1]] <- drop(G %*% m[[k0]]) */
            F77_CALL(dgemv)(&transN, &q, &q, &alpha_blas_one, G, 
                        &q, this_m, &inc_blas, &beta_blas_zero,
                        new_a, &inc_blas);
            /* new_a should have new a[[k1]] */
        
            #ifdef DEBUGGING
                PrintValue(mkString("new a[[k1]]"));
                PrintValue(VECTOR_ELT(a_R, k1));
            #endif    
                        
            /*e <- beta[iv] - a[[k1]][1L]*/
            double e = beta[iv] - new_a[0];
            
            #ifdef DEBUGGING
                PrintValue(mkString("e"));
                PrintValue( ScalarReal(e));
            #endif    
            
            /* C <- UC[[k2]] %*% diag(DC[[k2]]^2) %*% t(UC[[k2]]) */
            /* C into work 1 */
            memset(work1, 0, q*q * sizeof(double));
            for (int rowi = 0; rowi < q; ++rowi) {
             
                for (int colj = rowi; colj < q; ++colj) {
                    
                    double tmp = 0;
                    
                    for (int iq = 0; iq < q; ++iq) {
                        double dc_qi = newDC[iq];    
                        tmp += dc_qi * dc_qi * 
                            newUC[ q * iq + rowi] * newUC[ q * iq + colj];
                    }
                    work1[ q * colj + rowi ] = tmp;
                    
                    if (colj > rowi) {
                        work1[ q * rowi + colj ] = tmp;
                    }
                }
            }
            /* C should be in work1 */
            #ifdef DEBUGGING
                PrintValue(mkString("C"));
                printDblArray(work1, q*q);
            #endif 
            
            
            /*A <- C[1:2] * v.inv
                m[[k2]] <- a[[k1]] + A * e*/
            
            /* new_a = a[[k1]] into new_m = m[[k2]]*/
            memcpy(new_m, new_a, q*sizeof(double));
            
            for (int i = 0; i < q; ++i) {
                new_m[i] += e * work1[i] * v_inv;
            }
            
            #ifdef DEBUGGING
                PrintValue(mkString("new m[[k2]]"));
                PrintValue(VECTOR_ELT(m_R, k2));
            #endif  
           
        }
       
        int k = (forward ? K : 0 );     
        int ig = indicesGamma[k] - 1; /* index [k + 1L] in R -> [k] in C*/ 
        
        double *thisUC = REAL(VECTOR_ELT(UC_R, k));
        double *thisDC = REAL(VECTOR_ELT(DC_R, k));
        double *this_m = REAL(VECTOR_ELT(m_R, k));

        /*sqrt.C <- UC[[k]] %*% diag(DC[[k]], nrow = 2L)
            z <- rnorm(n = 2L)*/
        /* UCs is in work2 but as VT, not V 
         * put sqrt.Cs into work1*/
        memset(work1, 0, q*q * sizeof(double));
        double *z = singulars; 
        for (int colj = 0; colj < q; ++colj) {    
            
            z[colj] = rnorm(0, 1);    
            
            double d = thisDC[colj];
            
            for (int rowi = 0; rowi < q; ++rowi) {
            
                work1[colj*q + rowi] = d * thisUC[colj*q + rowi];
            }
        }
        #ifdef DEBUGGING
            PrintValue(mkString("end forward loop"));
            PrintValue(mkString("sqrt.C"));
            printDblArray(work1, q*q);
            PrintValue(mkString("z"));
            printDblArray(z, q);
        #endif  
        
        /*  gamma.delta <- m[[k]] + drop(sqrt.C %*% z) 
         * put gamma.delta into work2*/
        memcpy(work2, this_m, q*sizeof(double));
        F77_CALL(dgemv)(&transN, &q, &q, &alpha_blas_one, work1, /* sqrt.Cs is in work1 */
                    &q, z, &inc_blas, &beta_blas_one,
                    work2, &inc_blas);
        /* after call, work2 contains m[[k]] + drop(sqrt.C %*% z) */
        
        gamma[ig] = work2[0];
        delta[ig] = work2[1];
        
        #ifdef DEBUGGING
            PrintValue(mkString("gamma.delta"));
            printDblArray(work2, q);
            PrintValue(mkString("ig"));
            PrintValue(ScalarInteger(ig));
            PrintValue(ScalarInteger(ig+1));
            PrintValue(mkString("gamma[ig]"));
            PrintValue(ScalarReal(gamma[ig]));            
            PrintValue(mkString("delta[ig]"));
            PrintValue(ScalarReal(delta[ig]));  
        #endif  
        
        /* backward smooth */
        for (int k = K-1; k >= 0; --k) {

                int k0 = k + 1;
                int k1 = k;
                int k2 = k;
                
                if (!forward) {
                    k0 = K - 1 - k; 
                    k1 = K - 1 - k;
                    k2 = K - k;
                }

            int iv = indicesV[k1] - 1; 
            int ig0 = indicesGamma[k0] - 1; 
            /* int ig1 = indicesGamma[k1] - 1; not needed*/
            int ig2 = indicesGamma[k2] - 1;
            
            #ifdef DEBUGGING
                PrintValue(mkString("k"));
                PrintValue(ScalarInteger(k));
                PrintValue(ScalarInteger(k+1));
                PrintValue(mkString("k0"));
                PrintValue(ScalarInteger(k0));
                PrintValue(ScalarInteger(k0+1));
                PrintValue(mkString("k1"));
                PrintValue(ScalarInteger(k1));
                PrintValue(ScalarInteger(k1+1));
                PrintValue(mkString("k2"));
                PrintValue(ScalarInteger(k2));
                PrintValue(ScalarInteger(k2+1));
                PrintValue(mkString("iv"));
                PrintValue(ScalarInteger(iv));
                PrintValue(ScalarInteger(iv+1));
                PrintValue(mkString("ig0"));
                PrintValue(ScalarInteger(ig0));
                PrintValue(ScalarInteger(ig0+1));
                PrintValue(mkString("ig2"));
                PrintValue(ScalarInteger(ig2));
                PrintValue(ScalarInteger(ig2+1));
                 
            #endif 
            
            double *thisDCInv = REAL(VECTOR_ELT(DCInv_R, k2));
            double *thisUC = REAL(VECTOR_ELT(UC_R, k2));
            double *this_m = REAL(VECTOR_ELT(m_R, k2));
            
            /*C.inv <- UC[[k2]] %*% diag(DC.inv[[k2]]^2) %*% t(UC[[k2]])*/
            /* C.inv into work 1 */
            memset(work1, 0, q*q * sizeof(double));
            for (int rowi = 0; rowi < q; ++rowi) {
             
                for (int colj = rowi; colj < q; ++colj) {
                    
                    double tmp = 0;
                    
                    for (int iq = 0; iq < q; ++iq) {
                        double dcInv_qi = thisDCInv[iq];    
                        tmp += dcInv_qi * dcInv_qi * 
                            thisUC[ q * iq + rowi] * thisUC[ q * iq + colj];
                    }
                    work1[ q * colj + rowi ] = tmp;
                    
                    if (colj > rowi) {
                        work1[ q * rowi + colj ] = tmp;
                    }
                }
            }
            /* C.inv should be in work1 */
            
            #ifdef DEBUGGING 
                PrintValue(mkString("C.inv ")); 
                printDblArray(work1, q*q);
            #endif 
           
            double w_iv = w[iv];
            double C_inv_0 = work1[0];
            double C_inv_1 = work1[1];
            double C_inv_3 = work1[3];
            double var_inv = phi*phi/w_iv 
                                + C_inv_0 - 2*C_inv_1 + C_inv_3;
            double var = 1/var_inv;
            
            double gamma_ig0 = gamma[ig0];
            double mean = var * (phi*delta[ig0]/w_iv
                            + (C_inv_0 - C_inv_1) * (gamma_ig0 - this_m[0])
                            + (C_inv_3 - C_inv_1) * this_m[1]);
            double delta_ig2 = rnorm(mean, sqrt(var));
            delta[ig2] = delta_ig2;
            gamma[ig2] = gamma_ig0 - delta_ig2;

            #ifdef DEBUGGING 
                PrintValue(mkString("var")); 
                PrintValue(ScalarReal(var)); 
                PrintValue(mkString("mean")); 
                PrintValue(ScalarReal(mean)); 
                PrintValue(mkString("delta[ig2]")); 
                PrintValue(ScalarReal(delta[ig2])); 
                PrintValue(mkString("gamma[ig2]")); 
                PrintValue(ScalarReal(gamma[ig2])); 
            #endif 

        }
            
        advanceA(iterGamma_R); 
        advanceA(iterV_R);  
    } 
    UNPROTECT(5);
}

void updateGammaAR10(SEXP prior_R, SEXP beta_R);
UPDATEPRIOR_WRAPPER_R(updateGammaAR10);
CALLDEF(updateGammaAR10_R, 2),

void
updateGammaAR10(SEXP prior_R, SEXP beta_R)
{
    double *beta = REAL(beta_R);
    
    int K = *INTEGER(GET_SLOT(prior_R, K_sym)); /*scalar integer */
    int L = *INTEGER(GET_SLOT(prior_R, L_sym)); /*scalar integer */
    double *gamma = REAL(GET_SLOT(prior_R, gamma_sym)); /*length (K+1)L */
    SEXP m_R; 
    PROTECT(m_R = duplicate(GET_SLOT(prior_R, m_sym))); 
    SEXP C_R; 
    PROTECT(C_R = duplicate(GET_SLOT(prior_R, CC_sym))); 
    SEXP R_R; 
    PROTECT(R_R = duplicate(GET_SLOT(prior_R, R_sym))); 
    /* m, C, R unchanged */
    double *m = REAL(m_R); /*length K+1 */
    double *C = REAL(C_R); /*length K+1 */
    double *R = REAL(R_R); /*length K */
    double phi = *REAL(GET_SLOT(prior_R, phi_sym)); /*scalar double */
    double *v = REAL(GET_SLOT(prior_R, v_sym)); /*length KL */
    double *w = REAL(GET_SLOT(prior_R, w_sym)); /*length KL */
    SEXP iterGamma_R = GET_SLOT(prior_R, iteratorGamma_sym); /* AlongIterator */
    SEXP iterV_R = GET_SLOT(prior_R, iteratorV_sym); /* AlongIterator */
    
    resetA(iterGamma_R);
    resetA(iterV_R);
    
    int *indicesGamma = INTEGER(GET_SLOT(iterGamma_R, indices_sym));
    int *indicesV = INTEGER(GET_SLOT(iterV_R, indices_sym));

    double phi_squared = phi*phi;
    
    for (int l = 0; l < L; ++l) {
         
        #ifdef DEBUGGING
            PrintValue(mkString(""));
            PrintValue(mkString("l = "));
            PrintValue(ScalarInteger(l));
        #endif
        
        for (int k = 0; k < K; ++k) {

            int iv = indicesV[k] - 1;
            
            #ifdef DEBUGGING
                PrintValue(mkString(""));
                PrintValue(mkString("forward k = "));
                PrintValue(ScalarInteger(k));
                PrintValue(mkString("iv = indicesV[k] - 1 = "));
                PrintValue(ScalarInteger(iv));
            #endif
            
            double R_k = phi_squared * C[k] + w[iv];
            R[k] = R_k;
            double v_iv = v[iv];
            double A = v_iv / (R_k + v_iv);
            m[k+1] = A * phi * m[k] + (1-A)*beta[iv];
            C[k+1] = A * R_k;
            
            #ifdef DEBUGGING
                PrintValue(mkString("R[k] ="));
                PrintValue(ScalarReal(R_k));
                PrintValue(mkString("v[iv] ="));
                PrintValue(ScalarReal(v_iv));
                PrintValue(mkString("A = "));
                PrintValue(ScalarReal(A));
                PrintValue(mkString("m[k+1] = "));
                PrintValue(ScalarReal(m[k+1]));
                PrintValue(mkString("C[k+1] = "));
                PrintValue(ScalarReal(C[k+1]));
            #endif
        }

        int ig = indicesGamma[K] - 1; /* index [K + 1L] in R -> [K] in C*/
        gamma[ig] = rnorm(m[K], sqrt(C[K]));
        
        #ifdef DEBUGGING
            PrintValue(mkString(""));
            PrintValue(mkString("finished forward"));
        
            PrintValue(mkString("ig = "));
            PrintValue(ScalarInteger(ig));
            PrintValue(mkString("m[K] = "));
            PrintValue(ScalarReal(m[K]));
            PrintValue(mkString("C[K] = "));
            PrintValue(ScalarReal(C[K]));
            
            PrintValue(mkString("gamma[ig]"));
            PrintValue(ScalarReal(gamma[ig]));
            PrintValue(mkString(""));
        #endif
        
        for (int k = K-1; k >= 0; --k) {

            int iv = indicesV[k] - 1;
            int ig0 = indicesGamma[k] - 1;
            int ig1 = indicesGamma[k+1] - 1;
            
            #ifdef DEBUGGING
                PrintValue(mkString("backward k = "));
                PrintValue(ScalarInteger(k));
            
                PrintValue(mkString("iv = "));
                PrintValue(ScalarInteger(iv));
                PrintValue(mkString("ig0 = "));
                PrintValue(ScalarInteger(ig0));
                PrintValue(mkString("ig1 = "));
                PrintValue(ScalarInteger(ig1));
            #endif
            
            double B = w[iv] / R[k];
            double mStar = B * m[k] + (1 - B)*gamma[ig1]/phi;
            double CStar = B * C[k];
            gamma[ig0] = rnorm(mStar, sqrt(CStar));
            
            #ifdef DEBUGGING
                PrintValue(mkString("gamma[ig0] = "));
                PrintValue(ScalarReal(gamma[ig0]));
            #endif
        }
         
        advanceA(iterGamma_R);
        advanceA(iterV_R); 
        
    }
    UNPROTECT(3);
}

void updateGammaNoInitialAR1(SEXP prior_R);
UPDATEOBJECT_NOPRNG_WRAPPER_R(updateGammaNoInitialAR1);
CALLDEF(updateGammaNoInitialAR1_R, 1),
void
updateGammaNoInitialAR1(SEXP prior_R)
{
        
    int K = *INTEGER(GET_SLOT(prior_R, K_sym)); /*scalar integer */
    int L = *INTEGER(GET_SLOT(prior_R, L_sym)); /*scalar integer */

    double *gammaHas = REAL(GET_SLOT(prior_R, gamma_sym)); /*length (K+1)L */
    double *gammaNot = REAL(GET_SLOT(prior_R, gammaNoInitial_sym)); /*length KL */
    
    SEXP iterHas_R = GET_SLOT(prior_R, iteratorGamma_sym); /* AlongIterator */
    SEXP iterNot_R = GET_SLOT(prior_R, iteratorV_sym); /* AlongIterator */
    
    resetA(iterHas_R);
    resetA(iterNot_R);
    
    int *indicesHas = INTEGER(GET_SLOT(iterHas_R, indices_sym));
    int *indicesNot = INTEGER(GET_SLOT(iterNot_R, indices_sym));

    for (int l = 0; l < L; ++l) {
         
        #ifdef DEBUGGING
            PrintValue(mkString(""));
            PrintValue(mkString("l = "));
            PrintValue(ScalarInteger(l));
        #endif
        
        for (int k = 0; k < K; ++k) {
            
            int i_has = indicesHas[k+1] - 1;
            int i_not = indicesNot[k] - 1;
            gammaNot[i_not] = gammaHas[i_has];
            
            #ifdef DEBUGGING
                PrintValue(mkString(""));
                PrintValue(mkString("forward k = "));
                PrintValue(ScalarInteger(k));
                PrintValue(mkString("i_has = indicesHas[k] - 1 = "));
                PrintValue(ScalarInteger(i_has));
                PrintValue(mkString("i_not = indicesNot[k] - 1 = "));
                PrintValue(ScalarInteger(i_not));
                PrintValue(mkString("gammaNot[i_not] = "));
                PrintValue(ScalarReal(gammaNot[i_not]));
            #endif
            
        }

        advanceA(iterHas_R);
        advanceA(iterNot_R); 
    }
}

void updateGammaRobust(SEXP prior, SEXP beta_R);
UPDATEPRIOR_WRAPPER_R(updateGammaRobust);
CALLDEF(updateGammaRobust_R, 2),
void
updateGammaRobust(SEXP prior, SEXP beta_R)
{
    double *beta = REAL(beta_R);
    double *U = REAL(GET_SLOT(prior, U_sym));
    double *gamma = REAL(GET_SLOT(prior, gamma_sym));
    int J = LENGTH(beta_R);

    double sum_beta = 0;
    for (int i = 0; i < J; ++i)
        sum_beta += beta[i];

    double mean = sum_beta / J;

    double sum_U = 0;
    for (int i = 0; i < J; ++i)
        sum_U += U[i];

    double sd = sqrt(sum_U) / J;

    gamma[0] = rnorm(mean, sd);
}

void updateM0Poly(SEXP component_R, int forward);
UPDATEOBJECTFILTER_WRAPPER_R(updateM0Poly);
CALLDEF(updateM0Poly_R, 2),
void
updateM0Poly(SEXP component_R, int forward)
{
    SEXP m_R = GET_SLOT(component_R, m_sym);
    SEXP gamma_R = GET_SLOT(component_R, gamma_sym);
    int J = *INTEGER(GET_SLOT(component_R, J_sym));
    
    int j = (forward) ? 0 : J;
    SEXP this_m_R = VECTOR_ELT(m_R, j);
    double *this_m = REAL(this_m_R);
    int n = LENGTH(this_m_R);
    double *this_gamma = REAL(VECTOR_ELT(gamma_R, j));
    memcpy(this_m, this_gamma, n*sizeof(double));
}

void updatePhiAR10(SEXP prior_R);
UPDATEOBJECT_WRAPPER_R(updatePhiAR10);
CALLDEF(updatePhiAR10_R, 1),
void
updatePhiAR10(SEXP prior_R)
{
    int phiKnown = *INTEGER(GET_SLOT(prior_R, phiKnown_sym)); /*scalar logical */
    
    #ifdef DEBUGGING
        PrintValue(mkString("phi at start is "));
        PrintValue(GET_SLOT(prior_R, phi_sym));
    #endif
    
    if (!phiKnown) {
        
        int phiRestricted = *INTEGER(GET_SLOT(prior_R, phiRestricted_sym)); 
        
        int K = *INTEGER(GET_SLOT(prior_R, K_sym)); /*scalar integer */
        int L = *INTEGER(GET_SLOT(prior_R, L_sym)); /*scalar integer */
        double *gamma = REAL(GET_SLOT(prior_R, gamma_sym)); /*length (K+1)L */
        double *w = REAL(GET_SLOT(prior_R, w_sym)); /*length KL */
        SEXP iterGamma_R = GET_SLOT(prior_R, iteratorGamma_sym); /* AlongIterator */
        SEXP iter_w_R = GET_SLOT(prior_R, iteratorV_sym); /* AlongIterator */
        
        resetA(iterGamma_R);
        resetA(iter_w_R);
        
        int *indicesGamma = INTEGER(GET_SLOT(iterGamma_R, indices_sym));
        int *indices_w = INTEGER(GET_SLOT(iter_w_R, indices_sym));

        double num = 0.0;
        double den = 0.0;

        for (int l = 0; l < L; ++l) {
         
            for (int k = 0; k < K; ++k) {
                
                int ig1 = indicesGamma[k+1] - 1;
                int ig0 = indicesGamma[k] - 1;
                int iw = indices_w[k]-1;
                
                double gamma_ig0 = gamma[ig0];
                double w_iw = w[iw];
                
                num += gamma_ig0 * gamma[ig1] / w_iw;
                den += gamma_ig0 * gamma_ig0 / w_iw;
            }

            advanceA(iterGamma_R);
            advanceA(iter_w_R); 
        }

        double phi_prop = rnorm(num/den, 1/sqrt(den));
        if ( !phiRestricted || !(( phi_prop < 0 ) || (phi_prop > 1)) ) {
            
            SET_SLOT(prior_R, phi_sym, ScalarReal(phi_prop));
        }
        #ifdef DEBUGGING
        else if ( (( phi_prop < 0 ) || (phi_prop > 1)) ) {
            PrintValue(mkString("phi_prop is "));
            PrintValue(ScalarReal(phi_prop));
        }
        #endif
        
        #ifdef DEBUGGING
            PrintValue(mkString("phi at end "));
            PrintValue(GET_SLOT(prior_R, phi_sym));
        #endif
        
    } /* end if phi not known */
}

void updatePhiAR11(SEXP prior_R);
UPDATEOBJECT_WRAPPER_R(updatePhiAR11);
CALLDEF(updatePhiAR11_R, 1),
void
updatePhiAR11(SEXP prior_R)
{
    int phiKnown = *INTEGER(GET_SLOT(prior_R, phiKnown_sym)); /*scalar logical */
    
    #ifdef DEBUGGING
        PrintValue(mkString("phi at start is "));
        PrintValue(GET_SLOT(prior_R, phi_sym));
    #endif
    
    if (!phiKnown) {
        
        int phiRestricted = *INTEGER(GET_SLOT(prior_R, phiRestricted_sym)); 
        
        int K = *INTEGER(GET_SLOT(prior_R, K_sym)); /*scalar integer */
        int L = *INTEGER(GET_SLOT(prior_R, L_sym)); /*scalar integer */
        double *delta = REAL(GET_SLOT(prior_R, delta_sym)); /*length (K+1)L */
        double *w = REAL(GET_SLOT(prior_R, w_sym)); /*length KL */
        SEXP iterDelta_R = GET_SLOT(prior_R, iteratorGamma_sym); /* AlongIterator */
        SEXP iter_w_R = GET_SLOT(prior_R, iteratorV_sym); /* AlongIterator */
        
        resetA(iterDelta_R);
        resetA(iter_w_R);
        
        int *indicesDelta = INTEGER(GET_SLOT(iterDelta_R, indices_sym));
        int *indices_w = INTEGER(GET_SLOT(iter_w_R, indices_sym));

        double num = 0.0;
        double den = 0.0;

        for (int l = 0; l < L; ++l) {

            for (int k = 0; k < K; ++k) {
                
                int ig1 = indicesDelta[k+1] - 1;
                int ig0 = indicesDelta[k] - 1;
                int iw = indices_w[k]-1;
                
                double delta_ig0 = delta[ig0];
                double w_iw = w[iw];
                
                num += delta_ig0 * delta[ig1] / w_iw;
                den += delta_ig0 * delta_ig0 / w_iw;
            }

            advanceA(iterDelta_R);
            advanceA(iter_w_R); 
        }

        double phi_prop = rnorm(num/den, 1/sqrt(den));
        if ( !phiRestricted || !(( phi_prop < 0 ) || (phi_prop > 1)) ) {
            
            SET_SLOT(prior_R, phi_sym, ScalarReal(phi_prop));
        }
        #ifdef DEBUGGING
        else if ( (( phi_prop < 0 ) || (phi_prop > 1)) ) {
            PrintValue(mkString("phi_prop is "));
            PrintValue(ScalarReal(phi_prop));
        }
        #endif
        
        #ifdef DEBUGGING
            PrintValue(mkString("phi at end "));
            PrintValue(GET_SLOT(prior_R, phi_sym));
        #endif
        
    } /* end if phi not known */
}

void updateTauKnown(SEXP prior, double zeta);
void updateTauNormZeroUnknown(SEXP prior, SEXP beta_R, double zeta);
void updateTauNormCovUnknown(SEXP prior, SEXP beta_R, double zeta);
void updateTauRobustUnknown(SEXP prior, SEXP beta_R, double zeta);
UPDATEWITHZETA_WRAPPER_R(updateTauKnown);
UPDATEPRIORWITHZETA_WRAPPER_R(updateTauNormZeroUnknown);
UPDATEPRIORWITHZETA_WRAPPER_R(updateTauNormCovUnknown);
UPDATEPRIORWITHZETA_WRAPPER_R(updateTauRobustUnknown);
CALLDEF(updateTauKnown_R, 2),
  CALLDEF(updateTauNormZeroUnknown_R, 3),
  CALLDEF(updateTauNormCovUnknown_R, 3),
  CALLDEF(updateTauRobustUnknown_R, 3),
void
updateTauKnown(SEXP prior, double zeta)
{
    double tauUnscaled = *REAL(GET_SLOT(prior, tauUnscaled_sym));
    double tau = tauUnscaled/fabs(zeta);
    
    SET_SLOT(prior, tau_sym, ScalarReal(tau));
}

/*        gamma <- prior@gamma
        J <- length(beta)
        s.sq <- sum((beta - gamma)^2) / (J - 1)
        tau.sq <- rinvchisq1(J - 1, s.sq)
        prior@tau <- sqrt(tau.sq)
        prior
*/


void
updateTauNormZeroUnknown(SEXP prior, SEXP beta_R, double zeta)
{
    double minTau = *REAL(GET_SLOT(prior, minTau_sym));
    double maxTau = *REAL(GET_SLOT(prior, maxTau_sym));
   
    double *beta = REAL(beta_R);
    int J = LENGTH(beta_R);

    double df = J - 2.0;
    
    double sum_beta = 0.0;
    double sum_beta_sq = 0.0;
    
    for (int i = 0; i < J; ++i) {
        double this_beta = beta[i];
        sum_beta += this_beta;
        sum_beta_sq += this_beta * this_beta;
    }
    
    double s_sq = (sum_beta_sq - sum_beta * sum_beta / J) / df;
    
    double tau_sq = rinvchisq1(df, s_sq);
    
    double tau_prop = sqrt(tau_sq);
    double tau_prop_scaled = fabs(zeta) * tau_prop;

    if ( !(tau_prop_scaled < minTau) && !(tau_prop_scaled > maxTau) ) {
        SET_SLOT(prior, tau_sym, ScalarReal(tau_prop));
    }
}


void
updateTauNormCovUnknown(SEXP prior, SEXP beta_R, double zeta)
{
    double minTau = *REAL(GET_SLOT(prior, minTau_sym));
    double maxTau = *REAL(GET_SLOT(prior, maxTau_sym));

    /* z <- prior@Z */
    SEXP z_R = GET_SLOT(prior, Z_sym);
    int *z_dim =  INTEGER(GET_DIM(z_R));
    int J = z_dim[0]; /* length beta */
    int P = z_dim[1];
    double *z = REAL(z_R);

    double *beta = REAL(beta_R);

    /* QR <- qr(Z)
     * But now have to do this in two stages with the linpack
     * calls dqrdc (qr decomposition) and dqrsl (to get eta_hat)*/

    /* make a workspace that allows for:
     * P*J doubles for qr
     * P doubles for qraux
     * J doubles for qty
     * J doubles for beta_hat
     * = P*J + P + J + J = J(P+2) + P doubles altogether */

    double *workspace = (double *)R_alloc((J*(P+2) + P), sizeof(double));

    /* copy z because dqrdc call will change the matrix passed in
     * and copy into qr which is first P*J elements of workspace*/
    double *qr = workspace;
    memcpy(qr, z, P*J*sizeof(double));

    /* qraux is filled in by call to dqrdc and used in call to dqrsl
     * point this to (P*J)th element of workspace
     * qraux is P doubles */
    double *qraux = workspace + P*J;
    int jpvt = 0; /* not pivoting */

    double work_qr = 0; /* work not needed since we are not pivoting */
    /* matrix passed to dqrdc is going to be changed so need to copy it */
    int job_qr = 0; /* no pivoting */

    F77_CALL(dqrdc)(qr, &J, &J, &P, qraux, &jpvt,
                            &work_qr, &job_qr);
    /* after the call, qr contains R in its upper triangle and below
     * the diagonal qr contains info from which the orthogonal part
     * of the decomposition can be recovered,
     * and qraux contains the information required to be able to do this
     */

    /* beta.hat <- qr.fitted(QR, beta) */
    /* in the call parameters, parameter x = our qr and b = our beta */
    double qy = 0; /* q*y results if requested - not needed */

    /* transpose(q)*y results - needed since we want beta_hat (b) */

    /* transpose(q)*y results - needed since we want eta_hat (b)
     * point qty to (P*J + P)th element of workspace
     * qty needs J doubles*/
    double *qty = workspace + P*J + P;

    /* in the call parameters, parameter xb = beta_hat
     * point beta_hat to (P*J + P + J)th element of workspace
     * beta_hat is J doubles (all that is left of workspace)*/
    double *beta_hat = workspace + P*J + P + J;

    double rsd = 0; /* residual y  - z*b if req - not needed */
    double b = 0; /* b if req - not needed */
    int job_sl = 1; /* set to compute xb (fitted) only */
    int info = 0; /* could be changed by call */

    F77_CALL(dqrsl)(qr, &J, &J, &P, qraux, beta,
                    &qy, qty, &b, &rsd, beta_hat, &job_sl, &info);
    if (info) error("error in dqrsl in updateTauNormCovUnknown: %d", info);

    double df = J - P - 1.0;

    /* s.sq <- sum((beta - beta.hat)^2) / (J - P - 1) */
    double s_sq = 0.0;
    for (int i = 0; i < J; ++i) {
        double bb = beta[i]-beta_hat[i];
        s_sq += bb*bb;
    }
    s_sq /= df;

    /* tau.sq <- rinvchisq1(J - P - 1, s.sq) */
    double tau_sq = rinvchisq1(df, s_sq);
    
    double tau_prop = sqrt(tau_sq);
    double tau_prop_scaled = fabs(zeta) * tau_prop;

    if ( !(tau_prop_scaled < minTau) && !(tau_prop_scaled > maxTau) ) {
        SET_SLOT(prior, tau_sym, ScalarReal(tau_prop));
    }
}


void
updateTauRobustUnknown(SEXP prior, SEXP beta_R, double zeta)
{
    double minTau = *REAL(GET_SLOT(prior, minTau_sym));
    double maxTau = *REAL(GET_SLOT(prior, maxTau_sym));

    /* nu <- prior@nu, nu is a double, treat by value here*/
    double nu = *(REAL(GET_SLOT(prior, nu_sym)));

    SEXP u_R = GET_SLOT(prior, U_sym);
    int J = LENGTH(u_R);
    double *u = REAL(u_R);

    double shapeParam = (J * nu + 1.0)/2;
    double sumUsRecip = 0.0;

    for (int i = 0; i < J; ++i) {
        sumUsRecip += 1.0/(u[i]);
    }

    double rateParamMult = (nu/2.0)*sumUsRecip;

    double tau_sq = rgamma(shapeParam, 1/rateParamMult);
    
    double tau_prop = sqrt(tau_sq);
    double tau_prop_scaled = fabs(zeta) * tau_prop;

    if ( !(tau_prop_scaled < minTau) && !(tau_prop_scaled > maxTau) ) {
        SET_SLOT(prior, tau_sym, ScalarReal(tau_prop));
    }
}
     
void updateUCov(SEXP prior, SEXP beta_R);
UPDATEPRIOR_WRAPPER_R(updateUCov);
CALLDEF(updateUCov_R, 2),

/* update the Us used for the Normal Robust prior with covariates */
void
updateUCov(SEXP prior, SEXP beta_R)
{
    /* nu <- prior@nu, nu is a double*/
    double nu = *(REAL(GET_SLOT(prior, nu_sym)));

    /* tau <- prior@tau, tau is a double*/
    double tau = *(REAL(GET_SLOT(prior, tau_sym)));

    double *u = REAL(GET_SLOT(prior, U_sym));

    double *beta = REAL(beta_R);

    int J = LENGTH(beta_R); /* also length of U_sym*/

    /* beta.hat <- betaHat(prior) */
    double *beta_hat = (double *)R_alloc(J, sizeof(double));
    betaHat(beta_hat, prior, J);
    
    double nu_tau_sq = nu * tau * tau;
    double nu_plus_one = nu + 1.0;
    /* avoid having to calculate a whole s_sq vector when we only need
     * it element by element to update corresponding element of u */
    for (int i = 0; i < J; ++i) {
        /* use beta_hat to do our manipulation */
        beta_hat[i] -= beta[i];
        /* s.sq <- (nu * tau^2 + (beta - beta.hat)^2) / (nu + 1) */
        double s_sq = (nu_tau_sq + (beta_hat[i]*beta_hat[i]))/nu_plus_one;
        /* U[i] <- rinvchisq1(df = nu + 1L, scale = s.sq[i]) */
        u[i] = rinvchisq1(nu_plus_one, s_sq);
    }
}

void updateUZero(SEXP prior, SEXP beta_R);
CALLDEF(updateUZero_R, 2),
UPDATEPRIOR_WRAPPER_R(updateUZero);

/* update the Us used for the Normal Robust prior without covariates */
void
updateUZero(SEXP prior, SEXP beta_R)
{
    double gamma = *(REAL(GET_SLOT(prior, gamma_sym)));

    /* nu <- prior@nu, nu is a double */
    double nu = *(REAL(GET_SLOT(prior, nu_sym)));

    /* tau <- prior@tau, tau is a double*/
    double tau = *(REAL(GET_SLOT(prior, tau_sym)));

    double *u = REAL(GET_SLOT(prior, U_sym));

    double *beta = REAL(beta_R);

    int J = LENGTH(beta_R); /* also length of U_sym*/

    double nu_tau_sq = nu * tau * tau;
    double nu_plus_one = nu + 1.0;
    /* avoid having to calculate a whole s_sq vector when we only need
     * it element by element to update corresponding element of u */
    for (int i = 0; i < J; ++i) {
      double s_sq = (nu_tau_sq + ((beta[i] - gamma) * (beta[i] - gamma)))/nu_plus_one;
      u[i] = rinvchisq1(nu_plus_one, s_sq);
    }
}

void updateVPriorVAR1(SEXP prior_R, SEXP beta_R, double zeta);
void updateWPriorWAR10(SEXP prior_R, double zeta);
void updateWPriorWAR11(SEXP prior_R, double zeta);
UPDATEPRIORWITHZETA_WRAPPER_R(updateVPriorVAR1);
UPDATEWITHZETA_WRAPPER_R(updateWPriorWAR10);
UPDATEWITHZETA_WRAPPER_R(updateWPriorWAR11);
CALLDEF(updateVPriorVAR1_R, 3),
  CALLDEF(updateWPriorWAR10_R, 2),
  CALLDEF(updateWPriorWAR11_R, 2),
void
updateVPriorVAR1(SEXP prior_R, SEXP beta_R, double zeta)
{
    double *beta = REAL(beta_R);
    int KL = LENGTH(beta_R);
    
    double *gammaNoInitial = REAL(GET_SLOT(prior_R, gammaNoInitial_sym)); 
    double *v = REAL(GET_SLOT(prior_R, v_sym)); 
    
    SEXP priorV_R = GET_SLOT(prior_R, priorV_sym); 
    
    updatePriorVarDLM_Internal(priorV_R, v, KL, beta, gammaNoInitial, zeta);
    
    updateVarDLM_Internal(v, KL, priorV_R, beta, gammaNoInitial);

}


void
updateWPriorWAR10(SEXP prior_R, double zeta)
{
    SEXP gammaNoInitial_R = GET_SLOT(prior_R, gammaNoInitial_sym); 
    double *gammaNoInitial = REAL(gammaNoInitial_R); 
    int KL = LENGTH(gammaNoInitial_R);
    
    double *gammaHat = REAL(GET_SLOT(prior_R, gammaHat_sym)); 
    double *w = REAL(GET_SLOT(prior_R, w_sym)); 
    
    SEXP priorW_R = GET_SLOT(prior_R, priorW_sym); 
    
    updatePriorVarDLM_Internal(priorW_R, w, 
                            KL, gammaNoInitial, gammaHat, zeta);
    
    updateVarDLM_Internal(w, KL, priorW_R, 
                            gammaNoInitial, gammaHat);

}


void
updateWPriorWAR11(SEXP prior_R, double zeta)
{
    SEXP deltaNoInitial_R = GET_SLOT(prior_R, deltaNoInitial_sym); 
    double *deltaNoInitial = REAL(deltaNoInitial_R); 
    int KL = LENGTH(deltaNoInitial_R);
    
    double *deltaHat = REAL(GET_SLOT(prior_R, deltaHat_sym)); 
    double *w = REAL(GET_SLOT(prior_R, w_sym)); 
    
    SEXP priorW_R = GET_SLOT(prior_R, priorW_sym); 
    
    updatePriorVarDLM_Internal(priorW_R, w, 
                            KL, deltaNoInitial, deltaHat, zeta);
    
    updateVarDLM_Internal(w, KL, priorW_R, 
			  deltaNoInitial, deltaHat);

}

void updateWAndPriorsW(SEXP object_R, double zeta);
UPDATEWITHZETA_WRAPPER_R(updateWAndPriorsW);
CALLDEF(updateWAndPriorsW_R, 2),

void
updateWAndPriorsW(SEXP object_R, double zeta)
{
    /* G a matrix of doubles, size q x q */
    double *G = REAL(GET_SLOT(object_R, G_sym));
    /* gamma a list of vector of doubles, len J+1, each vector length q */
    SEXP gamma_R = GET_SLOT(object_R, gamma_sym);
    /* gammaHat a list of vector of doubles, len J, each vector length q */
    SEXP gammaHat_R = GET_SLOT(object_R, gammaHat_sym);
    /* W a list of matrices of doubles, len J, each matrix size q x q */
    SEXP W_R = GET_SLOT(object_R, W_sym);
    /* PriorsW a list of PriorVarDLM types, length q */
    SEXP priorsW_R = GET_SLOT(object_R, priorsW_sym);

    int J = *INTEGER(GET_SLOT(object_R, J_sym));
    int q = *INTEGER(GET_SLOT(object_R, q_sym));

    /* one malloc for all space and then split it up into 3 lots of J*/
    double *workspace = (double *)R_alloc((3*J), sizeof(double));
    double *observed = workspace;
    double *expected = workspace + J;
    double *var = workspace + 2*J;

    /* and also store pointers to beginnings of arrays
     * for J+1 gammas and J gammaHats and J W's s*/
    double **storage = (double **)R_alloc((3*J+1), sizeof(double*));
    double **gammaPtrs = storage;
    double **gammaHatPtrs = storage + J+1;
    double **WPtrs = storage + 2*J+1;

    /* stuff for dgemv */
    char transN = 'N';
    double alpha_blas = 1.0;
    double beta_blas_zero = 0.0;
    int inc_blas = 1;

    for (int j = 0; j < J; ++j) {

        /* ** gamma.hat[[j]] <- G %*% gamma[[j]] ** */
        double *this_gamma = REAL(VECTOR_ELT(gamma_R, j));
        gammaPtrs[j] = this_gamma;
        double *this_gammaHat = REAL(VECTOR_ELT(gammaHat_R, j));
        gammaHatPtrs[j] = this_gammaHat;
        double *this_W = REAL(VECTOR_ELT(W_R, j));
        WPtrs[j] = this_W;

        /* general matrix vector multiplication */
        F77_CALL(dgemv)(&transN, &q, &q, &alpha_blas, G,
                            &q, this_gamma, &inc_blas, &beta_blas_zero,
                            this_gammaHat, &inc_blas);
        /* after call, this_gammaHat contains G*this_gamma */
    }

    /* do the last gamma, in position J+1 */
    gammaPtrs[J] = REAL(VECTOR_ELT(gamma_R, J));;

    for (int i = 0; i < q; ++i) {

        for (int j = 0; j < J; ++j) {

            /* get the gammas and gammaHats and Ws using the stored pointers */
            double *this_gamma = gammaPtrs[j+1];
            double *this_gammaHat = gammaHatPtrs[j];
            double *this_W = WPtrs[j];

            observed[j] = this_gamma[i];
            expected[j] = this_gammaHat[i];
            var[j] = this_W[i*q+i];
        }

        SEXP this_prior_R = VECTOR_ELT(priorsW_R, i);

        updatePriorVarDLM_Internal(this_prior_R, var, J,
                                        observed, expected, zeta);

        updateVarDLM_Internal(var, J, this_prior_R,
                                        observed, expected);

        for (int j = 0; j < J; ++j) {

            /* and get the Ws from the stored pointers again */
            double *this_W = WPtrs[j];
            /* update it */
            this_W[i*q+i] = var[j];
        }
    }
}

void updateTheta_BinomialFixed(SEXP object, SEXP y_R, SEXP exposure_R);
void updateTheta_PoissonFixedNotUseExp(SEXP object, SEXP y_R);
void updateTheta_PoissonFixedUseExp(SEXP object, SEXP y_R, SEXP exposure_R);
void updateTheta_NormalFixed(SEXP object, SEXP y_R);
UPDATEOBJECT_WITHEXP_WRAPPER_R(updateTheta_BinomialFixed);
UPDATEOBJECT_NOEXP_WRAPPER_R(updateTheta_PoissonFixedNotUseExp);
UPDATEOBJECT_WITHEXP_WRAPPER_R(updateTheta_PoissonFixedUseExp);
UPDATEOBJECT_NOEXP_WRAPPER_R(updateTheta_NormalFixed);
  CALLDEF(updateTheta_BinomialFixed_R, 3),
  CALLDEF(updateTheta_PoissonFixedNotUseExp_R, 2),
  CALLDEF(updateTheta_PoissonFixedUseExp_R, 3),
  CALLDEF(updateTheta_NormalFixed_R, 2),
/* y_R is a demographic array, g'teed to be doubles */
void
updateTheta_NormalFixed(SEXP object, SEXP y_R)
{
    double varsigma = *REAL(GET_SLOT(object, varsigma_sym));
    double sigma = *REAL(GET_SLOT(object, sigma_sym));
    double mu = *REAL(GET_SLOT(object, mu_sym));

    double *w = REAL(GET_SLOT(object, w_sym));

    SEXP theta_R = GET_SLOT(object, theta_sym);
    double *theta = REAL(theta_R);
    int n_theta = LENGTH(theta_R);
    /* n_theta and length of y_R and w are all identical */

    double *y = REAL(y_R);

    for (int i = 0; i < n_theta; ++i) {
        
        double mean = 0;
        double sd = 0;
        
        if ( y[i] == NA_REAL || ISNA(y[i]) ) { /* testing for an R NA seems 
                                                to be very illogical!
                                                What works here is the NA_REAL
                                                test but I wanted to add belt & braces*/
            mean = mu;
            sd = sigma;
        }
        else {
            double prec_prior = 1/(sigma * sigma);
            double prec_data = w[i] / (varsigma * varsigma);
            double var = 1/(prec_prior + prec_data);
            
            mean = (prec_prior * mu + prec_data * y[i]) * var; 
            sd = sqrt(var);
        }
        
        theta[i] = rnorm( mean, sd);
    }
}

/* y_R integer */
void
updateTheta_PoissonFixedNotUseExp(SEXP object, SEXP y_R)
{
    SEXP theta_R = GET_SLOT(object, theta_sym);
    double *theta = REAL(theta_R);
    int n_theta = LENGTH(theta_R);
    /* n_theta and length of y_R are all identical */

    double sigma = *REAL(GET_SLOT(object, sigma_sym));
    double mu = *REAL(GET_SLOT(object, mu_sym));

    int *y = INTEGER(y_R);

    double sigmaSq = sigma*sigma;

    double priorShape = mu * mu/ sigmaSq;
    double priorRate = mu / sigmaSq;

    for (int i = 0; i < n_theta; ++i) {

       double shape = priorShape;
       double rate = priorRate;
       
       if ( y[i] == NA_INTEGER || ISNA(y[i]) ) { /* testing for an R NA seems 
                                                to be very illogical!
                                                What works here is the NA_INTEGER
                                                test but I wanted to add belt & braces*/
            /* no change */
        }
        else {
            shape += y[i];
            rate += 1.0;
        }

        theta[i] = rgamma(shape, 1/rate);
    }
}


/* y_R integer
 * exposure_R double */
void
updateTheta_PoissonFixedUseExp(SEXP object, SEXP y_R, SEXP exposure_R)
{
    SEXP theta_R = GET_SLOT(object, theta_sym);
    double *theta = REAL(theta_R);
    int n_theta = LENGTH(theta_R);
    /* n_theta and length of y_R and exposure_R are all identical */

    double sigma = *REAL(GET_SLOT(object, sigma_sym));
    double mu = *REAL(GET_SLOT(object, mu_sym));

    int *y = INTEGER(y_R);
    double *exposure = REAL(exposure_R);

    double sigmaSq = sigma*sigma;

    double priorShape = mu * mu/ sigmaSq;
    double priorRate = mu / sigmaSq;

    for (int i = 0; i < n_theta; ++i) {

       double shape = priorShape;
       double rate = priorRate;
       
       if ( y[i] == NA_INTEGER || ISNA(y[i]) ) { /* testing for an R NA seems 
                                                to be very illogical!
                                                What works here is the NA_INTEGER
                                                test but I wanted to add belt & braces*/
            /* no change */
        }
        else {
            shape += y[i];
            rate += exposure[i];
        }

        theta[i] = rgamma(shape, 1/rate);
    }
}
/* y_R and exposure_R are both Counts objects, g'teed to be integer */
void
updateTheta_BinomialFixed(SEXP object, SEXP y_R, SEXP exposure_R)
{
    SEXP theta_R = GET_SLOT(object, theta_sym);
    double *theta = REAL(theta_R);
    int n_theta = LENGTH(theta_R);
    /* n_theta and length of y_R and exposure_R are all identical */

    double mu = *REAL(GET_SLOT(object, mu_sym));
    double sigma = *REAL(GET_SLOT(object, sigma_sym));

    double sigmaSq = sigma * sigma;
    double nu = mu * (1 - mu);
    double mult = nu / sigmaSq - 1; 
    
    double priorShape1 = mu * mult;
    double priorShape2 = (1 - mu) * mult;

    int *y = INTEGER(y_R);
    int *exposure = INTEGER(exposure_R);
    
    #ifdef DEBUGGING
        PrintValue(mkString("y"));
        PrintValue(y_R);
        PrintValue(mkString("exposure"));
        PrintValue(exposure_R);
        PrintValue(mkString("priorShape1"));
        PrintValue(ScalarReal(priorShape1));
        PrintValue(mkString("priorShape2"));
        PrintValue(ScalarReal(priorShape2));
    #endif  

    for (int i = 0; i < n_theta; ++i) {
        
        double shape1 = priorShape1;
        double shape2 = priorShape2;
        
        #ifdef DEBUGGING
            PrintValue(mkString(""));
            PrintValue(mkString("i"));
            PrintValue(ScalarInteger(i+1));
            PrintValue(mkString("y[i]"));
            PrintValue(ScalarInteger(y[i]));
        #endif  
        
        if ( y[i] == NA_INTEGER || ISNA(y[i]) ) { /* testing for an R NA seems 
                                                to be very illogical!
                                                What works here is the NA_INTEGER
                                                test but I wanted to add belt & braces*/
            #ifdef DEBUGGING
                PrintValue(mkString("na"));
            #endif 
        }
        else {
            #ifdef DEBUGGING
                PrintValue(mkString("not na"));
            #endif 
            shape1 += y[i];
            shape2 += (exposure [i] - y[i]);
        }
        
        #ifdef DEBUGGING
            PrintValue(mkString("shape1"));
            PrintValue(ScalarReal(shape1));
            PrintValue(mkString("shape2"));
            PrintValue(ScalarReal(shape2));
        #endif  
         
        theta[i] = rbeta(shape1, shape2);
        
        #ifdef DEBUGGING
            PrintValue(mkString("theta[i]"));
            PrintValue(ScalarReal(theta[i]));
        #endif  
    }
    
    #ifdef DEBUGGING
        PrintValue(mkString("theta"));
        PrintValue(theta_R);
    #endif
}

void updateSigma_BinomialFixed(SEXP object);
void updateSigma_PoissonFixed(SEXP object);
void updateSigma_NormalFixed(SEXP object);
UPDATEOBJECT_WRAPPER_R(updateSigma_BinomialFixed);
UPDATEOBJECT_WRAPPER_R(updateSigma_PoissonFixed);
UPDATEOBJECT_WRAPPER_R(updateSigma_NormalFixed);
CALLDEF(updateSigma_BinomialFixed_R, 1),
  CALLDEF(updateSigma_PoissonFixed_R, 1),
  CALLDEF(updateSigma_NormalFixed_R, 1),
void
updateSigma_BinomialFixed(SEXP object)
{
    /*      theta <- object@theta
        mu <- object@mu
        sigma.curr <- object@sigma
        scaleSigma <- object@scaleSigma
        df.prior.sigma <- object@dfPriorSigma
        has.informative.prior <- df.prior.sigma != -1
        nu <- mu * (1 - mu)
        sigma.prop <- rnorm(n = 1L, mean = sigma.curr, sd = scaleSigma)
    */

    double *sigma = REAL(GET_SLOT(object, sigma_sym));
    double sigma_curr = *sigma;
    double scale = *REAL(GET_SLOT(object, scaleSigma_sym));

    double mu = *REAL(GET_SLOT(object, mu_sym));

    double nu = mu * (1 - mu);

    /* sigma.prop <- rnorm(n = 1L, mean = sigma.curr, sd = scale) */
    double sigma_prop = rnorm(sigma_curr, scale);

    int accept = 0;
    /* if ((sigma.prop > 0) && (sigma.prop < nu)) {
            log.dens.curr <- sum(dbeta(x = theta,
                                       shape1 = mu * (nu / sigma.curr^2 - 1),
                                       shape2 = (1 - mu) * (nu / sigma.curr^2 - 1),
                                       log = TRUE))
            log.dens.prop <- sum(dbeta(x = theta,
                                       shape1 = mu * (nu / sigma.prop^2 - 1),
                                       shape2 = (1 - mu) * (nu / sigma.prop^2 - 1),
                                       log = TRUE))
            log.diff <- log.dens.prop - log.dens.curr
            if (has.informative.prior) {
                scale.prior.sigma <- object@scalePriorSigma # equals s in Gelman et al
                log.diff.prior <- ((df.prior.sigma / 2 + 1) *
                                   (log(sigma.curr) - log(sigma.prop)) +
                                   (df.prior.sigma * scale.prior.sigma^2 / 2) *
                                   ((1 / sigma.curr) - (1 / sigma.prop)))
                log.diff <- log.diff + log.diff.prior
            }
            accept <- (log.diff >= 0) || (runif(n = 1L) < exp(log.diff))
        }*/

    if ( (sigma_prop) > 0.0 && (sigma_prop < nu) ) {

        SEXP theta_R = GET_SLOT(object, theta_sym);
        double *theta = REAL(theta_R);
        int n_theta = LENGTH(theta_R);

        double df_prior_sigma = *REAL(GET_SLOT(object, dfPriorSigma_sym));
        /* code checks for equality with -1 but these are doubles so I want
         * to avoid checking equality and as far as I can see the only
         * time dfPriorSigma is not > 0, dfPriorSigma is -1 */
        int has_informative_prior = (df_prior_sigma > 0);

        double nuOverSigSqMinusOne = nu/(sigma_curr*sigma_curr) - 1;

        /*log.dens.curr <- sum(dbeta(x = theta,
                                       shape1 = mu * (nu / sigma.curr^2 - 1),
                                       shape2 = (1 - mu) * (nu / sigma.curr^2 - 1),
                                       log = TRUE)) */
        double log_dens_curr = get_log_beta_dens(n_theta, theta,
                (mu * nuOverSigSqMinusOne),
                ((1-mu) * nuOverSigSqMinusOne));

        double nuOverSigPropSqMinusOne = nu/(sigma_prop*sigma_prop) - 1;

        double log_dens_prop = get_log_beta_dens(n_theta, theta,
                    (mu * nuOverSigPropSqMinusOne),
                    ((1-mu) * nuOverSigPropSqMinusOne));
        double log_diff = log_dens_prop - log_dens_curr;

        /* if (has.informative.prior) {
                scale.prior.sigma <- object@scalePriorSigma # equals s in Gelman et al
                log.diff.prior <- ((df.prior.sigma / 2 + 1) *
                                   (log(sigma.curr) - log(sigma.prop)) +
                                   (df.prior.sigma * scale.prior.sigma^2 / 2) *
                                   ((1 / sigma.curr) - (1 / sigma.prop)))
                log.diff <- log.diff + log.diff.prior
            } */

        if (has_informative_prior) {
            double scale_prior_sigma =
                        *REAL(GET_SLOT(object, scalePriorSigma_sym));
            double log_diff_prior = (df_prior_sigma/2 + 1) *
                        (log(sigma_curr) - log(sigma_prop))
                        +
                        df_prior_sigma * scale_prior_sigma * scale_prior_sigma / 2 *
                        (1/sigma_curr - 1/sigma_prop);
            log_diff += log_diff_prior;
        }

        /*accept <- (log.diff >= 0) || (runif(n = 1L) < exp(log.diff)) */
        accept = ( !(log_diff < 0.0) ||
                (runif(0.0, 1.0) < exp(log_diff)) );
    }

    /* if (accept) {
            object@sigma <- sigma.prop
            object@acceptSigma <- 1L
        }
        else
            object@acceptSigma <- 0L
        object */

    SET_SLOT(object, acceptSigma_sym, ScalarInteger(accept));

    if (accept) {
        *sigma = sigma_prop;
    }

}

void
updateSigma_NormalFixed(SEXP object)
{
    /* theta <- object@theta
        mu <- object@mu
        I <- length(theta) */

    SEXP theta_R = GET_SLOT(object, theta_sym);
    double *theta = REAL(theta_R);
    int n_theta = LENGTH(theta_R);
    double mu = *REAL(GET_SLOT(object, mu_sym));

    double df = *REAL(GET_SLOT(object, dfPriorSigma_sym));
    double scale = *REAL(GET_SLOT(object, scalePriorSigma_sym));

    /*   SS <- sum((theta - mu)^2)
        sigma.sq <- rinvchisq1(I + df, (SS + df * scale) / (I + df))
      */
    double s_sq = 0.0;
    for (int i = 0; i < n_theta; ++i) {
        double tmp = theta[i] - mu;
        s_sq += tmp * tmp;
    }

    double sigma_sq = rinvchisq1(n_theta + df,
                 (s_sq + df*scale*scale)/(n_theta + df));

    SET_SLOT(object, sigma_sym, ScalarReal(sqrt(sigma_sq)));
}

void
updateSigma_PoissonFixed(SEXP object)
{

    double *sigma = REAL(GET_SLOT(object, sigma_sym));
    double sigma_curr = *sigma;
    double scale = *REAL(GET_SLOT(object, scaleSigma_sym));


    /* sigma.prop <- rnorm(n = 1L, mean = sigma.curr, sd = scale) */
    double sigma_prop = rnorm(sigma_curr, scale);

    /*        if (sigma.prop > 0) {
            log.dens.curr <- sum(dgamma(x = theta,
                                        shape = mu^2 / sigma.curr^2,
                                        rate = mu / sigma.curr^2,
                                        log = TRUE))
            log.dens.prop <- sum(dgamma(x = theta,
                                        shape = mu^2 / sigma.prop^2,
                                        rate = mu / sigma.prop^2,
                                        log = TRUE))
            log.diff <- log.dens.prop - log.dens.curr
            if (has.informative.prior) {
                scale.prior.sigma <- object@scalePriorSigma # equals s in Gelman et al
                log.diff.prior <- ((df.prior.sigma / 2 + 1) *
                                   (log(sigma.curr) - log(sigma.prop)) +
                                   (df.prior.sigma * scale.prior.sigma^2 / 2) *
                                   ((1 / sigma.curr) - (1 / sigma.prop)))
                log.diff <- log.diff + log.diff.prior
            }
            accept <- (log.diff >= 0) || (runif(n = 1L) < exp(log.diff))
        } */

    int accept = 0;

    if (sigma_prop > 0.0) {

        SEXP theta_R = GET_SLOT(object, theta_sym);
        double *theta = REAL(theta_R);
        int n_theta = LENGTH(theta_R);
        double mu = *REAL(GET_SLOT(object, mu_sym));

        double df_prior_sigma = *REAL(GET_SLOT(object, dfPriorSigma_sym));
        /* code checks for equality with -1 but these are doubles so I want
         * to avoid checking equality and as far as I can see the only
         * time dfPriorSigma is not > 0, dfPriorSigma is -1 */
        int has_informative_prior = (df_prior_sigma > 0);

        double sigmaSq = sigma_curr*sigma_curr;
        /* log.dens.curr <- sum(dgamma(x = theta,
                                        shape = mu^2 / sigma.curr^2,
                                        rate = mu / sigma.curr^2,
                                        log = TRUE))       */

        double log_dens_curr = get_log_gamma_dens(n_theta, theta,
                    mu*mu/sigmaSq, sigmaSq/mu);

        double sigmaPropSq = sigma_prop * sigma_prop;
        double log_dens_prop = get_log_gamma_dens(n_theta, theta,
                    mu*mu/sigmaPropSq, sigmaPropSq/mu);

        double log_diff = log_dens_prop - log_dens_curr;

        /*    if (has.informative.prior) {
                scale.prior.sigma <- object@scalePriorSigma # equals s in Gelman et al
                log.diff.prior <- ((df.prior.sigma / 2 + 1) *
                                   (log(sigma.curr) - log(sigma.prop)) +
                                   (df.prior.sigma * scale.prior.sigma^2 / 2) *
                                   ((1 / sigma.curr) - (1 / sigma.prop)))
                log.diff <- log.diff + log.diff.prior
            } */

        if (has_informative_prior) {
            double scale_prior_sigma =
                        *REAL(GET_SLOT(object, scalePriorSigma_sym));
            double log_diff_prior = (df_prior_sigma/2 + 1) *
                        (log(sigma_curr) - log(sigma_prop))
                        +
                        df_prior_sigma * scale_prior_sigma * scale_prior_sigma/2 *
                        (1/sigma_curr - 1/sigma_prop);
            log_diff += log_diff_prior;
        }

        accept = ( !(log_diff < 0.0) ||
                (runif(0.0, 1.0) < exp(log_diff)) );
    }

    /* if (accept) {
            object@sigma <- sigma.prop
            object@acceptSigma <- 1L
        }
        else
            object@acceptSigma <- 0L
        object */
    SET_SLOT(object, acceptSigma_sym, ScalarInteger(accept));

    if (accept) {
        *sigma = sigma_prop;
    }

}

void predictBeta_ExchNormZeroKnown(double *beta, SEXP prior_R, int J);
void predictBeta_ExchNormZeroUnknown(double *beta, SEXP prior_R, int J);
void predictBeta_ExchNormCovKnown(double *beta, SEXP prior_R, int J);
void predictBeta_ExchNormCovUnknown(double *beta, SEXP prior_R, int J);
void predictBeta_ExchRobustZeroKnown(double *beta, SEXP prior_R, int J);
void predictBeta_ExchRobustZeroUnknown(double *beta, SEXP prior_R, int J);
void predictBeta_ExchRobustCovKnown(double *beta, SEXP prior_R, int J);
void predictBeta_ExchRobustCovUnknown(double *beta, SEXP prior_R, int J);
PREDICTBETA_WRAPPER_R(predictBeta_ExchNormZeroKnown);
PREDICTBETA_WRAPPER_R(predictBeta_ExchNormZeroUnknown);
PREDICTBETA_WRAPPER_R(predictBeta_ExchNormCovKnown);
PREDICTBETA_WRAPPER_R(predictBeta_ExchNormCovUnknown);
PREDICTBETA_WRAPPER_R(predictBeta_ExchRobustZeroKnown);
PREDICTBETA_WRAPPER_R(predictBeta_ExchRobustZeroUnknown);
PREDICTBETA_WRAPPER_R(predictBeta_ExchRobustCovKnown);
PREDICTBETA_WRAPPER_R(predictBeta_ExchRobustCovUnknown);
  CALLDEF(predictBeta_ExchNormZeroKnown_R, 2),
  CALLDEF(predictBeta_ExchNormZeroUnknown_R, 2),
  CALLDEF(predictBeta_ExchNormCovKnown_R, 2),
  CALLDEF(predictBeta_ExchNormCovUnknown_R, 2),
  CALLDEF(predictBeta_ExchRobustZeroKnown_R, 2),
  CALLDEF(predictBeta_ExchRobustZeroUnknown_R, 2),
  CALLDEF(predictBeta_ExchRobustCovKnown_R, 2),
  CALLDEF(predictBeta_ExchRobustCovUnknown_R, 2),
void
predictBeta_ExchNormZeroKnown(double *beta, SEXP prior_R, int J)
{
    predictBeta_ExchNormZero_i(beta, prior_R, J);
}

void
predictBeta_ExchNormZeroUnknown(double *beta, SEXP prior_R, int J)
{
    predictBeta_ExchNormZero_i(beta, prior_R, J);
}


void
predictBeta_ExchNormCovKnown(double *beta, SEXP prior_R, int J)
{
    predictBeta_ExchNormCov_i(beta, prior_R, J);
}

void
predictBeta_ExchNormCovUnknown(double *beta, SEXP prior_R, int J)
{
    predictBeta_ExchNormCov_i(beta, prior_R, J);
}


void
predictBeta_ExchRobustZeroKnown(double *beta, SEXP prior_R, int J)
{
    predictBeta_ExchRobustZero_i(beta, prior_R, J);
}


void
predictBeta_ExchRobustZeroUnknown(double *beta, SEXP prior_R, int J)
{
    predictBeta_ExchRobustZero_i(beta, prior_R, J);
}


void
predictBeta_ExchRobustCovKnown(double *beta, SEXP prior_R, int J)
{
    predictBeta_ExchRobustCov_i(beta, prior_R, J);
}

void
predictBeta_ExchRobustCovUnknown(double *beta, SEXP prior_R, int J)
{
    predictBeta_ExchRobustCov_i(beta, prior_R, J);
}

static __inline__ void
predictBeta_ExchNormZero_i(double *beta, SEXP prior_R, int J)
{
    double gamma = *(REAL(GET_SLOT(prior_R, gamma_sym)));
    double tau = *(REAL(GET_SLOT(prior_R, tau_sym)));
    
    for (int j = 0; j < J; ++j) {
        beta[j] = rnorm(gamma, tau);
    }
}

static __inline__ void
predictBeta_ExchNormCov_i(double *beta, SEXP prior_R, int J)
{
    double tau = *(REAL(GET_SLOT(prior_R, tau_sym)));
    
    /* beta.hat <- betaHat(prior) */
    double *beta_hat = (double *)R_alloc(J, sizeof(double));
    betaHat(beta_hat, prior_R, J);
    
    for (int j = 0; j < J; ++j) {
        beta[j] = rnorm(beta_hat[j], tau);
    }
}

static __inline__ void
predictBeta_ExchRobustZero_i(double *beta, SEXP prior_R, int J)
{
    double gamma = *(REAL(GET_SLOT(prior_R, gamma_sym)));
    double *U = REAL(GET_SLOT(prior_R, U_sym));
    
    for (int j = 0; j < J; ++j) {
        beta[j] = rnorm(gamma, sqrt(U[j]));
    }
}

static __inline__ void
predictBeta_ExchRobustCov_i(double *beta, SEXP prior_R, int J)
{
    double *U = REAL(GET_SLOT(prior_R, U_sym));
    /* beta.hat <- betaHat(prior) */
    double *beta_hat = (double *)R_alloc(J, sizeof(double));
    betaHat(beta_hat, prior_R, J);
    
    for (int j = 0; j < J; ++j) {
        beta[j] = rnorm(beta_hat[j], sqrt(U[j]));
    }
}

void predictBeta(double *beta, SEXP prior_R, int J);
void predictBeta_PolyPredict(double *beta, SEXP prior_R, int J);
void predictBeta_AR10Predict(double *beta, SEXP prior_R, int J);
void predictBeta_AR11Predict(double *beta, SEXP prior_R, int J);
PREDICTBETA_WRAPPER_R(predictBeta);
PREDICTBETA_WRAPPER_R(predictBeta_PolyPredict);
PREDICTBETA_WRAPPER_R(predictBeta_AR10Predict);
PREDICTBETA_WRAPPER_R(predictBeta_AR11Predict);
CALLDEF(predictBeta_R, 2),
  CALLDEF(predictBeta_PolyPredict_R, 2),
  CALLDEF(predictBeta_AR10Predict_R, 2),
  CALLDEF(predictBeta_AR11Predict_R, 2),

/* common to both AR10 and AR11 */
static __inline__ void
predictBeta_AR1Predict_i(double *beta, SEXP prior_R, int J)
{
    double *gammaNoInitial = REAL(GET_SLOT(prior_R, gammaNoInitial_sym));
    double *v = REAL(GET_SLOT(prior_R, v_sym));
    
    for (int j = 0; j < J; ++j) {
        beta[j] = rnorm(gammaNoInitial[j], sqrt(v[j]));
    }
}


void
predictBeta_AR10Predict(double *beta, SEXP prior_R, int J)
{
    predictBeta_AR1Predict_i(beta, prior_R, J);
}

void
predictBeta_AR11Predict(double *beta, SEXP prior_R, int J)
{
    predictBeta_AR1Predict_i(beta, prior_R, J);
}

/*                  components <- prior@components
                  v <- prior@v
                  forward <- prior@forward
                  ## THE FOLLOWING LINE HAS CHANGED
                  beta.hat <- betaHatPoly(components, forward = forward)
                  rnorm(n = J, mean = beta.hat, sd = sqrt(v))
*/
void
predictBeta_PolyPredict(double *beta, SEXP prior_R, int J)
{
    SEXP components_R = GET_SLOT(prior_R, components_sym);
	double *v = REAL(GET_SLOT(prior_R, v_sym));
	
    int forward = *INTEGER(GET_SLOT(prior_R, forward_sym));
    
    /* beta.hat <- betaHatPoly(components) */
    double *betaHat = (double *)R_alloc(J, sizeof(double));
    betaHatPoly_Internal(betaHat, J, components_R, forward);
    
    for (int j = 0; j < J; ++j) {
        beta[j] = rnorm(betaHat[j], sqrt(v[j]));
    }
}


void
predictBeta(double *beta, SEXP prior_R, int J) 
{
    int i_method_prior = *(INTEGER(GET_SLOT(prior_R, iMethodPrior_sym)));
    
    switch(i_method_prior)
    {	
		/* functions deleted */
		#if(0)
        case 1: case 2:
            predictBeta_ExchNormZero_i(beta, prior_R, J);
            break;
        case 3: case 4:
            predictBeta_ExchNormCov_i(beta, prior_R, J);
            break;
        case 5: case 6:
            predictBeta_ExchRobustZero_i(beta, prior_R, J);
            break;
        case 7: case 8:
            predictBeta_ExchRobustCov_i(beta, prior_R, J);
            break;
        #endif
        case 128:
            predictBeta_PolyPredict(beta, prior_R, J); 
            break;
        case 129:
			predictBeta_AR1Predict_i(beta, prior_R, J); 
			break;
        case 130:
			predictBeta_AR1Predict_i(beta, prior_R, J); 
			break;
        default:
            error("unknown i_method_prior for predictBeta: %d", i_method_prior);
            break;
    }
}

void predictPrior(SEXP prior_R, double zeta);
void predictPrior_ExchNormZeroKnown(SEXP prior_R, double zeta);
void predictPrior_ExchNormZeroUnknown(SEXP prior_R, double zeta);
void predictPrior_ExchNormCovKnown(SEXP prior_R, double zeta);
void predictPrior_ExchNormCovUnknown(SEXP prior_R, double zeta);
void predictPrior_ExchRobustZeroKnown(SEXP prior_R, double zeta);
void predictPrior_ExchRobustZeroUnknown(SEXP prior_R, double zeta);
void predictPrior_ExchRobustCovKnown(SEXP prior_R, double zeta);
void predictPrior_ExchRobustCovUnknown(SEXP prior_R, double zeta);
void predictPrior_PolyPredict(SEXP prior_R, double zeta);
void predictPrior_AR10Predict(SEXP prior_R, double zeta);
void predictPrior_AR11Predict(SEXP prior_R, double zeta);
UPDATEWITHZETA_WRAPPER_R(predictPrior);
UPDATEWITHZETA_WRAPPER_R(predictPrior_ExchNormZeroKnown);
UPDATEWITHZETA_WRAPPER_R(predictPrior_ExchNormZeroUnknown);
UPDATEWITHZETA_WRAPPER_R(predictPrior_ExchNormCovKnown);
UPDATEWITHZETA_WRAPPER_R(predictPrior_ExchNormCovUnknown);
UPDATEWITHZETA_WRAPPER_R(predictPrior_ExchRobustZeroKnown);
UPDATEWITHZETA_WRAPPER_R(predictPrior_ExchRobustZeroUnknown);
UPDATEWITHZETA_WRAPPER_R(predictPrior_ExchRobustCovKnown);
UPDATEWITHZETA_WRAPPER_R(predictPrior_ExchRobustCovUnknown);
UPDATEWITHZETA_WRAPPER_R(predictPrior_PolyPredict);
UPDATEWITHZETA_WRAPPER_R(predictPrior_AR10Predict);
UPDATEWITHZETA_WRAPPER_R(predictPrior_AR11Predict);
CALLDEF(predictPrior_R, 2),
  CALLDEF(predictPrior_ExchNormZeroKnown_R, 2),
  CALLDEF(predictPrior_ExchNormZeroUnknown_R, 2),
  CALLDEF(predictPrior_ExchNormCovKnown_R, 2),
  CALLDEF(predictPrior_ExchNormCovUnknown_R, 2),
  CALLDEF(predictPrior_ExchRobustZeroKnown_R, 2),
  CALLDEF(predictPrior_ExchRobustZeroUnknown_R, 2),
  CALLDEF(predictPrior_ExchRobustCovKnown_R, 2),
  CALLDEF(predictPrior_ExchRobustCovUnknown_R, 2),
  CALLDEF(predictPrior_PolyPredict_R, 2),
  CALLDEF(predictPrior_AR10Predict_R, 2),
  CALLDEF(predictPrior_AR11Predict_R, 2),

static __inline__ void
predictPrior_ExchNormZeroKnown_i(SEXP prior_R, double zeta)
{
    double tauUnscaled = *REAL(GET_SLOT(prior_R, tauUnscaled_sym));
    double tau = tauUnscaled/fabs(zeta);
    SET_SLOT(prior_R, tau_sym, ScalarReal(tau));
}

static __inline__ void
predictPrior_ExchNormZeroUnknown_i(SEXP prior_R, double zeta)
{
    /* null op */
}


static __inline__ void
predictPrior_ExchNormCovKnown_i(SEXP prior_R, double zeta)
{
    double tauUnscaled = *REAL(GET_SLOT(prior_R, tauUnscaled_sym));
    double tau = tauUnscaled/fabs(zeta);
    SET_SLOT(prior_R, tau_sym, ScalarReal(tau));
}

static __inline__ void
predictPrior_ExchNormCovUnknown_i(SEXP prior_R, double zeta)
{
    /* null op */
}

static __inline__ void
predictPrior_ExchRobustZeroKnown_i(SEXP prior_R, double zeta)
{
    double tauUnscaled = *(REAL(GET_SLOT(prior_R, tauUnscaled_sym)));
    double nu = *(REAL(GET_SLOT(prior_R, nu_sym)));
    double tau = tauUnscaled/fabs(zeta);
    double tau_sq = tau * tau;
    SEXP U_R = GET_SLOT(prior_R, U_sym);
    int J = LENGTH(U_R);
    double *U = REAL(U_R);
    
    for (int j = 0; j < J; ++j) {
        U[j] = rinvchisq1(nu, tau_sq);
    }
    
    SET_SLOT(prior_R, tau_sym, ScalarReal(tau));
}

static __inline__ void
predictPrior_ExchRobustZeroUnknown_i(SEXP prior_R, double zeta)
{
    double tau = *(REAL(GET_SLOT(prior_R, tau_sym)));
    double tau_sq = tau * tau;
    double nu = *(REAL(GET_SLOT(prior_R, nu_sym)));
    SEXP U_R = GET_SLOT(prior_R, U_sym);
    int J = LENGTH(U_R);
    double *U = REAL(U_R);
    
    for (int j = 0; j < J; ++j) {
        U[j] = rinvchisq1(nu, tau_sq);
    }
}

static __inline__ void
predictPrior_ExchRobustCovKnown_i(SEXP prior_R, double zeta)
{
    double tauUnscaled = *(REAL(GET_SLOT(prior_R, tauUnscaled_sym)));
    double nu = *(REAL(GET_SLOT(prior_R, nu_sym)));
    double tau = tauUnscaled/fabs(zeta);
    double tau_sq = tau * tau;
    SEXP U_R = GET_SLOT(prior_R, U_sym);
    int J = LENGTH(U_R);
    double *U = REAL(U_R);
    
    for (int j = 0; j < J; ++j) {
        U[j] = rinvchisq1(nu, tau_sq);
    }
    
    SET_SLOT(prior_R, tau_sym, ScalarReal(tau));
}


static __inline__ void
predictPrior_ExchRobustCovUnknown_i(SEXP prior_R, double zeta)
{
    double tau = *(REAL(GET_SLOT(prior_R, tau_sym)));
    double tau_sq = tau * tau;
    double nu = *(REAL(GET_SLOT(prior_R, nu_sym)));
    SEXP U_R = GET_SLOT(prior_R, U_sym);
    int J = LENGTH(U_R);
    double *U = REAL(U_R);
    
    for (int j = 0; j < J; ++j) {
        U[j] = rinvchisq1(nu, tau_sq);
    }
}

void
predictPrior_ExchNormZeroKnown(SEXP prior_R, double zeta)
{
    predictPrior_ExchNormZeroKnown_i(prior_R, zeta);
}


void
predictPrior_ExchNormZeroUnknown(SEXP prior_R, double zeta)
{
    predictPrior_ExchNormZeroUnknown_i(prior_R, zeta);
}

void
predictPrior_ExchNormCovKnown(SEXP prior_R, double zeta)
{
    predictPrior_ExchNormCovKnown_i(prior_R, zeta);
}

void
predictPrior_ExchNormCovUnknown(SEXP prior_R, double zeta)
{
    predictPrior_ExchNormCovUnknown_i(prior_R, zeta);
}

void
predictPrior_ExchRobustZeroKnown(SEXP prior_R, double zeta)
{
    predictPrior_ExchRobustZeroKnown_i(prior_R, zeta);
}

void
predictPrior_ExchRobustZeroUnknown(SEXP prior_R, double zeta)
{
    predictPrior_ExchRobustZeroUnknown_i(prior_R, zeta);
}

void
predictPrior_ExchRobustCovKnown(SEXP prior_R, double zeta)
{
    predictPrior_ExchRobustCovKnown_i(prior_R, zeta);
}

void
predictPrior_ExchRobustCovUnknown(SEXP prior_R, double zeta)
{
    predictPrior_ExchRobustCovUnknown_i(prior_R, zeta);
}

void
predictPrior_PolyPredict(SEXP prior_R, double zeta)
{
    SEXP components_R = GET_SLOT(prior_R, components_sym);
    int n = LENGTH(components_R);
    
    SEXP priorV_R = GET_SLOT(prior_R, priorV_sym); /* a PriorVarDLM */
	
    SEXP v_R = GET_SLOT(prior_R, v_sym);
    int J = LENGTH(v_R);
	double *v = REAL(v_R);

	int forward = *INTEGER(GET_SLOT(prior_R, forward_sym));
 
    for (int i = 0; i < n; ++i) {
        
        predictPolyComponent(VECTOR_ELT(components_R, i), forward, zeta);
    }
    
    for (int j = 0; j < J; ++j) {
        v[j] = predictVarDLM(priorV_R, zeta);
    }
}


void
predictPrior_AR10Predict(SEXP prior_R, double zeta)
{
    int K = *INTEGER(GET_SLOT(prior_R, K_sym)); /*scalar integer */
    int L = *INTEGER(GET_SLOT(prior_R, L_sym)); /*scalar integer */
    double *gamma = REAL(GET_SLOT(prior_R, gamma_sym)); /*length (K+1)L */
    double phi = *REAL(GET_SLOT(prior_R, phi_sym)); /*scalar double */
    double *v = REAL(GET_SLOT(prior_R, v_sym)); /*length KL */
    double *w = REAL(GET_SLOT(prior_R, w_sym)); /*length KL */
    SEXP priorV_R = GET_SLOT(prior_R, priorV_sym);
    SEXP priorW_R = GET_SLOT(prior_R, priorW_sym);
    SEXP iterGamma_R = GET_SLOT(prior_R, iteratorGamma_sym); /* AlongIterator */
    SEXP iterV_R = GET_SLOT(prior_R, iteratorV_sym); /* AlongIterator */
	int forward = *INTEGER(GET_SLOT(prior_R, forward_sym)); 
    
    resetA(iterGamma_R);
    resetA(iterV_R);
    
    int *indicesGamma = INTEGER(GET_SLOT(iterGamma_R, indices_sym));
    int *indicesV = INTEGER(GET_SLOT(iterV_R, indices_sym));

    for (int l = 0; l < L; ++l) {
		
		if (forward) {
			
			for (int k = 0; k < K; ++k) {
			
				int ig0 = indicesGamma[k] - 1;
				int ig1 = indicesGamma[k+1] - 1;
				int iv = indicesV[k] - 1;
				
				v[iv] = predictVarDLM(priorV_R, zeta);
				w[iv] = predictVarDLM(priorW_R, zeta);
				double mean = phi * gamma[ig0];
				double sd = sqrt(w[iv]);
				gamma[ig1] = rnorm(mean, sd);
			}
		}
		else {
			
			for (int k = K-1; k >= 0; --k) {
            
				int ig0 = indicesGamma[k] - 1;
				int ig1 = indicesGamma[k+1] - 1;
				int iv = indicesV[k] - 1;

				v[iv] = predictVarDLM(priorV_R, zeta);
				w[iv] = predictVarDLM(priorW_R, zeta);
				double mean = phi * gamma[ig1];
				double sd = sqrt(w[iv]);
				gamma[ig0] = rnorm(mean, sd);
			}
		}
		
		advanceA(iterGamma_R);
        advanceA(iterV_R);
	} /* end L loop */

	/* functions removed */
	#if(0)
	updateGammaNoInitialAR1(prior_R);
	updateGammaHatAR10(prior_R);
	#endif
}


void
predictPrior_AR11Predict(SEXP prior_R, double zeta)
{
    int K = *INTEGER(GET_SLOT(prior_R, K_sym)); /*scalar integer */
    int L = *INTEGER(GET_SLOT(prior_R, L_sym)); /*scalar integer */
    double *gamma = REAL(GET_SLOT(prior_R, gamma_sym)); /*length (K+1)L */
    double *delta = REAL(GET_SLOT(prior_R, delta_sym)); /*length (K+1)L */
    double phi = *REAL(GET_SLOT(prior_R, phi_sym)); /*scalar double */
    double *v = REAL(GET_SLOT(prior_R, v_sym)); /*length KL */
    double *w = REAL(GET_SLOT(prior_R, w_sym)); /*length KL */
    SEXP priorV_R = GET_SLOT(prior_R, priorV_sym);
    SEXP priorW_R = GET_SLOT(prior_R, priorW_sym);
    SEXP iterGamma_R = GET_SLOT(prior_R, iteratorGamma_sym); /* AlongIterator */
    SEXP iterV_R = GET_SLOT(prior_R, iteratorV_sym); /* AlongIterator */
	int forward = *INTEGER(GET_SLOT(prior_R, forward_sym)); 
    
    resetA(iterGamma_R);
    resetA(iterV_R);
    
    int *indicesGamma = INTEGER(GET_SLOT(iterGamma_R, indices_sym));
    int *indicesV = INTEGER(GET_SLOT(iterV_R, indices_sym));

    for (int l = 0; l < L; ++l) {
		
		if (forward) {
			
			for (int k = 0; k < K; ++k) {
			
				int ig0 = indicesGamma[k] - 1;
				int ig1 = indicesGamma[k+1] - 1;
				int iv = indicesV[k] - 1;
				
				v[iv] = predictVarDLM(priorV_R, zeta);
				w[iv] = predictVarDLM(priorW_R, zeta);
				double mean = phi * delta[ig0];
				double sd = sqrt(w[iv]);
				delta[ig1] = rnorm(mean, sd);
                gamma[ig1] = gamma[ig0] + delta[ig0];
			}
		}
		else {
			
			for (int k = K-1; k >= 0; --k) {
            
				int ig0 = indicesGamma[k] - 1;
				int ig1 = indicesGamma[k+1] - 1;
				int iv = indicesV[k] - 1;

				v[iv] = predictVarDLM(priorV_R, zeta);
				w[iv] = predictVarDLM(priorW_R, zeta);
				double mean = phi * delta[ig1];
				double sd = sqrt(w[iv]);
				delta[ig0] = rnorm(mean, sd);
                gamma[ig0] = gamma[ig1] + delta[ig1]; 
			}
		}
		
		advanceA(iterGamma_R);
        advanceA(iterV_R);
	} /* end L loop */

	#if(0) /* these functions deleted */
    updateGammaNoInitialAR1(prior_R);
    updateDeltaNoInitialAR11(prior_R);
	updateDeltaHatAR11(prior_R);
    #endif
}



void
predictPrior(SEXP prior_R, double zeta) 
{
    int i_method_prior = *(INTEGER(GET_SLOT(prior_R, iMethodPrior_sym)));
    
    switch(i_method_prior)
    {
        case 1:
            predictPrior_ExchNormZeroKnown_i(prior_R, zeta);
            break;
        case 2:
            predictPrior_ExchNormZeroUnknown_i(prior_R, zeta);
            break;
        case 3:
            predictPrior_ExchNormCovKnown_i(prior_R, zeta);
            break;
        case 4:
            predictPrior_ExchNormCovUnknown_i(prior_R, zeta);
            break;
        case 5:
            predictPrior_ExchRobustZeroKnown_i(prior_R, zeta);
            break;
        case 6:
            predictPrior_ExchRobustZeroUnknown_i(prior_R, zeta);
            break;
        case 7:
            predictPrior_ExchRobustCovKnown_i(prior_R, zeta);
            break;
        case 8:
            predictPrior_ExchRobustCovUnknown_i(prior_R, zeta);
            break;
        case 128:
            predictPrior_PolyPredict(prior_R, zeta); 
            break;
        case 129:
            predictPrior_AR10Predict(prior_R, zeta); 
            break;
        case 130:
            predictPrior_AR11Predict(prior_R, zeta); 
            break;
        
        default:
            error("unknown i_method_prior for predictPrior: %d", i_method_prior);
            break;
    }
}


double predictVarDLM(SEXP prior_R, double zeta);
double predictVarDLM_NormKnown(SEXP prior_R, double zeta);
double predictVarDLM_NormUnknown(SEXP prior_R, double zeta);
double predictVarDLM_RobustKnown(SEXP prior_R, double zeta);
double predictVarDLM_RobustUnknown(SEXP prior_R, double zeta);
double predictVarDLM_Zero(SEXP prior_R, double zeta);
PREDICTOBJECTWITHZETA_WRAPPER_R(predictVarDLM);
PREDICTOBJECTWITHZETA_WRAPPER_R(predictVarDLM_NormKnown);
PREDICTOBJECTWITHZETA_WRAPPER_R(predictVarDLM_NormUnknown);
PREDICTOBJECTWITHZETA_WRAPPER_R(predictVarDLM_RobustKnown);
PREDICTOBJECTWITHZETA_WRAPPER_R(predictVarDLM_RobustUnknown);
PREDICTOBJECTWITHZETA_WRAPPER_R(predictVarDLM_Zero);
  CALLDEF(predictVarDLM_R, 2),
  CALLDEF(predictVarDLM_NormKnown_R, 2),
  CALLDEF(predictVarDLM_NormUnknown_R, 2),
  CALLDEF(predictVarDLM_RobustKnown_R, 2),
  CALLDEF(predictVarDLM_RobustUnknown_R, 2),
  CALLDEF(predictVarDLM_Zero_R, 2),
/* **************** predictVarDLM **************** */

static __inline__ double
predictVarDLM_NormKnown_i(SEXP prior_R, double zeta)
{
    double tauUnscaled = *(REAL(GET_SLOT(prior_R, tauUnscaled_sym)));
    double tau = tauUnscaled/fabs(zeta);
    return (tau * tau);
}


static __inline__ double
predictVarDLM_NormUnknown_i(SEXP prior_R, double zeta)
{
    double tau = *(REAL(GET_SLOT(prior_R, tau_sym)));
    return (tau * tau);
}

static __inline__ double
predictVarDLM_RobustKnown_i(SEXP prior_R, double zeta)
{
    double tauUnscaled = *(REAL(GET_SLOT(prior_R, tauUnscaled_sym)));
    double nu = *(REAL(GET_SLOT(prior_R, nu_sym)));
    double tau = tauUnscaled/fabs(zeta);
    return rinvchisq1(nu, (tau*tau));
}

static __inline__ double
predictVarDLM_RobustUnknown_i(SEXP prior_R, double zeta)
{
    double tau = *(REAL(GET_SLOT(prior_R, tau_sym)));
    double nu = *(REAL(GET_SLOT(prior_R, nu_sym)));
    return rinvchisq1(nu, (tau*tau));
}

double
predictVarDLM_NormKnown(SEXP prior_R, double zeta)
{
    return predictVarDLM_NormKnown_i(prior_R, zeta);
}

double
predictVarDLM_NormUnknown(SEXP prior_R, double zeta)
{
    return predictVarDLM_NormUnknown_i(prior_R, zeta);
}


double
predictVarDLM_RobustKnown(SEXP prior_R, double zeta)
{
    return predictVarDLM_RobustKnown_i(prior_R, zeta);
}


double
predictVarDLM_RobustUnknown(SEXP prior_R, double zeta)
{
    return predictVarDLM_RobustUnknown_i(prior_R, zeta);
}

double
predictVarDLM_Zero(SEXP prior_R, double zeta)
{
    double ans = 0.0;
    return ans;
}

double 
predictVarDLM(SEXP prior_R, double zeta) 
{
    int iMethodPriorVarDLM = *(INTEGER(GET_SLOT(prior_R, 
                                            iMethodPriorVarDLM_sym)));
    
    double ans = 0;
    switch(iMethodPriorVarDLM)
    {
        case 1:
            ans = predictVarDLM_NormKnown_i(prior_R, zeta);
            break;
        
        case 2:
            ans = predictVarDLM_NormUnknown_i(prior_R, zeta);
            break;
        
        case 3:
            ans = predictVarDLM_RobustKnown_i(prior_R, zeta);
            break;
        
        case 4:
            ans = predictVarDLM_RobustUnknown_i(prior_R, zeta);
            break;
            
        case 5:
            ans = predictVarDLM_Zero(prior_R, zeta);
            break;
        
        default:
            error("unknown iMethodPriorVarDLM for predictVarDLM: %d", 
                                            iMethodPriorVarDLM);
            break;
    }
    
    return ans;
}


void transferParamPolyComponent(SEXP component_R, double *values,
                                int nValues, int forward);
void transferParamPolyComponent_Trend(SEXP component_R, double *values,
                                int nValues, int forward);
void transferParamPolyComponent_Covariates(SEXP component_R, double *values,
                                int nValues, int forward);
void transferParamPolyComponent_Seasonal(SEXP component_R, double *values,
                                int nValues, int forward);
void transferParamPolyComponent_TrendPredicted(SEXP component_R, double *values,
                                int nValues, int forward);
void transferParamPolyComponent_CovariatesPredicted(SEXP component_R, double *values,
                                int nValues, int forward);
void transferParamPolyComponent_SeasonalPredicted(SEXP component_R, double *values,
                                int nValues, int forward);
/* transfer param poly components */
/* Wrapper macro to use for the transferParamPolyComponent functions.
 * The wrapper puts a _R suffix on end of function name,
 * and ensures that the R version returns the updated prior as the SEXP */
#define TRANSFERPARAMPOLYCOMPONENT_WRAPPER_R(name)         \
    SEXP name##_R(SEXP component_R, SEXP values_R, SEXP forward_R) {    \
    int forward = *INTEGER(forward_R);               \
    double *values = REAL(values_R);    \
    int nValues = LENGTH(values_R);    \
    SEXP ans_R;               \
    PROTECT(ans_R = duplicate(component_R));    \
    name(ans_R, values, nValues, forward);          \
    UNPROTECT(1);               \
    return ans_R;             \
    }
TRANSFERPARAMPOLYCOMPONENT_WRAPPER_R(transferParamPolyComponent);
TRANSFERPARAMPOLYCOMPONENT_WRAPPER_R(transferParamPolyComponent_Trend);
TRANSFERPARAMPOLYCOMPONENT_WRAPPER_R(transferParamPolyComponent_Covariates);
TRANSFERPARAMPOLYCOMPONENT_WRAPPER_R(transferParamPolyComponent_Seasonal);
TRANSFERPARAMPOLYCOMPONENT_WRAPPER_R(transferParamPolyComponent_TrendPredicted);
TRANSFERPARAMPOLYCOMPONENT_WRAPPER_R(transferParamPolyComponent_CovariatesPredicted);
TRANSFERPARAMPOLYCOMPONENT_WRAPPER_R(transferParamPolyComponent_SeasonalPredicted);
CALLDEF(transferParamPolyComponent_R, 3),
CALLDEF(transferParamPolyComponent_Trend_R, 3),
CALLDEF(transferParamPolyComponent_Covariates_R, 3),
CALLDEF(transferParamPolyComponent_Seasonal_R, 3),
CALLDEF(transferParamPolyComponent_TrendPredicted_R, 3),
CALLDEF(transferParamPolyComponent_CovariatesPredicted_R, 3),
CALLDEF(transferParamPolyComponent_SeasonalPredicted_R, 3),
void
transferParamPolyComponent_Trend(SEXP component_R, double *values, 
                                        int nValues, int forward)
{
    transferGamma(component_R, values, nValues);
    transferPriorsW(component_R, values, nValues);
}

void
transferParamPolyComponent_Covariates(SEXP component_R, double *values, 
                                        int nValues, int forward)
{
    transferGamma(component_R, values, nValues);
}

void
transferParamPolyComponent_Seasonal(SEXP component_R, double *values, 
                                        int nValues, int forward)
{
    transferGamma(component_R, values, nValues);
    transferPriorsW(component_R, values, nValues);
}

void
transferParamPolyComponent_TrendPredicted(SEXP component_R, double *values, 
                                        int nValues, int forward)
{
    transferGamma0(component_R, values, nValues, forward);
    /* function deleted */
    #if(0)
    updateM0Poly(component_R, forward);
    #endif
    transferPriorsW(component_R, values, nValues);
}

void
transferParamPolyComponent_CovariatesPredicted(SEXP component_R, double *values, 
                                        int nValues, int forward)
{
    transferGamma0(component_R, values, nValues, forward);
    /* function deleted */
    #if(0)
    updateM0Poly(component_R, forward);
    #endif
}

void
transferParamPolyComponent_SeasonalPredicted(SEXP component_R, double *values, 
                                        int nValues, int forward)
{
    transferGamma0(component_R, values, nValues, forward);
    /* function deleted */
    #if(0)
    updateM0Poly(component_R, forward);
    #endif
    transferPriorsW(component_R, values, nValues);
}

void
transferParamPolyComponent(SEXP component_R, double *values, 
                                        int nValues, int forward) 
{
    int i_method_poly_component = 
            *(INTEGER(GET_SLOT(component_R, iMethodPolyComponent_sym)));
    
    switch(i_method_poly_component)
    {
        case 1:
            transferParamPolyComponent_Trend(
                            component_R, values, nValues, forward);
            break;
        case 2:
            transferParamPolyComponent_Covariates(
                            component_R, values, nValues, forward);
            break;
        case 3:
            transferParamPolyComponent_Seasonal(
                            component_R, values, nValues, forward);
            break;
        case 101:
            transferParamPolyComponent_TrendPredicted(
                            component_R, values, nValues, forward);
            break;
        case 102:
            transferParamPolyComponent_CovariatesPredicted(
                            component_R, values, nValues, forward);
            break;
        case 103:
            transferParamPolyComponent_SeasonalPredicted(
                            component_R, values, nValues, forward);
            break;
         
        default:
            error("unknown i_method_poly_component: %d", i_method_poly_component);
            break;
    }
}

void transferParamPrior(SEXP prior_R, double *values, int nValues);
void transferParamPrior_ExchNormZeroKnown(SEXP prior_R, double *values, 
					  int nValues);
void transferParamPrior_ExchNormZeroUnknown(SEXP prior_R, double *values, 
                                            int nValues);
void transferParamPrior_ExchNormCovKnown(SEXP prior_R, double *values, 
                                            int nValues);
void transferParamPrior_ExchNormCovUnknown(SEXP prior_R, double *values, 
                                            int nValues);
void transferParamPrior_ExchRobustZeroKnown(SEXP prior_R, double *values, 
                                            int nValues);
void transferParamPrior_ExchRobustZeroUnknown(SEXP prior_R, double *values, 
                                            int nValues);
void transferParamPrior_ExchRobustCovKnown(SEXP prior_R, double *values, 
                                            int nValues);
void transferParamPrior_ExchRobustCovUnknown(SEXP prior_R, double *values, 
                                            int nValues);
void transferParamPrior_Poly(SEXP prior_R, double *values, 
                                            int nValues); 
void transferParamPrior_PolyPredict(SEXP prior_R, double *values, 
                                            int nValues);
void transferParamPrior_AR10(SEXP prior_R, double *values, int nValues);
void transferParamPrior_AR11(SEXP prior_R, double *values, int nValues);
void transferParamPrior_AR10Predict(SEXP prior_R, double *values, int nValues);
void transferParamPrior_AR11Predict(SEXP prior_R, double *values, int nValues);
void transferParamPriorVarDLM(SEXP prior_R, double *values, 
                                            int nValues);
void transferParamPriorVarDLM_NormUnknown(SEXP prior_R, double *values, 
                                            int nValues);
void transferParamPriorVarDLM_RobustUnknown(SEXP prior_R, double *values, 
                                            int nValues);
/* transfer param priors */
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamPrior);
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamPrior_ExchNormZeroKnown);
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamPrior_ExchNormZeroUnknown);
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamPrior_ExchNormCovKnown);
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamPrior_ExchNormCovUnknown);
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamPrior_ExchRobustZeroKnown);
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamPrior_ExchRobustZeroUnknown);
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamPrior_ExchRobustCovKnown);
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamPrior_ExchRobustCovUnknown);
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamPrior_Poly);
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamPrior_PolyPredict);
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamPrior_AR10);
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamPrior_AR11);
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamPrior_AR10Predict);
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamPrior_AR11Predict);
/* transfer param poly var priors */
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamPriorVarDLM);
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamPriorVarDLM_NormUnknown);
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamPriorVarDLM_RobustUnknown);
  CALLDEF(transferParamPrior_R, 2),
  CALLDEF(transferParamPrior_ExchNormZeroKnown_R, 2),
  CALLDEF(transferParamPrior_ExchNormZeroUnknown_R, 2),
  CALLDEF(transferParamPrior_ExchNormCovKnown_R, 2),
  CALLDEF(transferParamPrior_ExchNormCovUnknown_R, 2),
  CALLDEF(transferParamPrior_ExchRobustZeroKnown_R, 2),
  CALLDEF(transferParamPrior_ExchRobustZeroUnknown_R, 2),
  CALLDEF(transferParamPrior_ExchRobustCovKnown_R, 2),
  CALLDEF(transferParamPrior_ExchRobustCovUnknown_R, 2),
  CALLDEF(transferParamPrior_Poly_R, 2),
  CALLDEF(transferParamPrior_PolyPredict_R, 2),
  CALLDEF(transferParamPrior_AR10_R, 2),
  CALLDEF(transferParamPrior_AR11_R, 2),
  CALLDEF(transferParamPrior_AR10Predict_R, 2),
  CALLDEF(transferParamPrior_AR11Predict_R, 2),
  
  CALLDEF(transferParamPriorVarDLM_R, 2),
  CALLDEF(transferParamPriorVarDLM_NormUnknown_R, 2),
  CALLDEF(transferParamPriorVarDLM_RobustUnknown_R, 2),
/* ************** transferParamPrior *************** */

void
transferParamPrior_ExchNormZeroKnown(SEXP prior_R,  double *values, 
				     int nValues) 
{
    SET_SLOT(prior_R, gamma_sym, ScalarReal(values[0]));
}

void
transferParamPrior_ExchNormZeroUnknown(SEXP prior_R,  double *values, 
                                            int nValues) 
{
    SET_SLOT(prior_R, gamma_sym, ScalarReal(values[0]));
    SET_SLOT(prior_R, tau_sym, ScalarReal(values[1]));
}

void
transferParamPrior_ExchNormCovKnown(SEXP prior_R, double *values, 
                                            int nValues) 
{
    SEXP eta_R = GET_SLOT(prior_R, eta_sym);
    double *eta = REAL(eta_R);
    
    int nEta = LENGTH(eta_R);
    
    /* prior@eta <- values - assumes that nValues >= nEta*/
    if (nValues < nEta) {
        error("transferParamPrior_ExchNormCovKnown: not enough elements in values");
    }
    memcpy(eta, values,  nEta*sizeof(double));
}

void
transferParamPrior_ExchNormCovUnknown(SEXP prior_R, double *values, 
                                            int nValues) 
{
    SEXP eta_R = GET_SLOT(prior_R, eta_sym);
    double *eta = REAL(eta_R);
    
    int nEta = LENGTH(eta_R);
    
    /* prior@eta <- values[1 : n.eta]
     * prior@tau <- values[n.eta + 1L]
     * assumes that nValues >= nEta+1*/
    if (nValues < nEta+1) {
        error("transferParamPrior_ExchNormCovUnknown: not enough elements in values");
    }
    memcpy(eta, values,  nEta*sizeof(double));
    
    SET_SLOT(prior_R, tau_sym, ScalarReal(values[nEta]));

}

void
transferParamPrior_ExchRobustZeroKnown(SEXP prior_R, double *values, 
                                            int nValues) 
{
    SET_SLOT(prior_R, gamma_sym, ScalarReal(values[0]));
}

void
transferParamPrior_ExchRobustZeroUnknown(SEXP prior_R, double *values, 
                                            int nValues) 
{
    SET_SLOT(prior_R, gamma_sym, ScalarReal(values[0]));
    SET_SLOT(prior_R, tau_sym, ScalarReal(values[1]));
}

void
transferParamPrior_ExchRobustCovKnown(SEXP prior_R, double *values, 
                                            int nValues) 
{
    SEXP eta_R = GET_SLOT(prior_R, eta_sym);
    double *eta = REAL(eta_R);
    
    int nEta = LENGTH(eta_R);
    
    /* prior@eta <- values - assumes that nValues >= nEta*/
    if (nValues < nEta) {
        error("transferParamPrior_ExchNormCovKnown: not enough elements in values");
    }
    memcpy(eta, values,  nEta*sizeof(double));
}

void
transferParamPrior_ExchRobustCovUnknown(SEXP prior_R, double *values, 
                                            int nValues) 
{
    SEXP eta_R = GET_SLOT(prior_R, eta_sym);
    double *eta = REAL(eta_R);
    
    int nEta = LENGTH(eta_R);
    
    /* prior@eta <- values[1 : n.eta]
     * prior@tau <- values[n.eta + 1L]
     * assumes that nValues >= nEta+1*/
    if (nValues < nEta+1) {
        error("transferParamPrior_ExchNormCovKnown: not enough elements in values");
    }
    memcpy(eta, values,  nEta*sizeof(double));
    
    SET_SLOT(prior_R, tau_sym, ScalarReal(values[nEta]));
}

void
transferParamPrior_Poly(SEXP prior_R, double *values, int nValues) 
{
    SEXP components_R = GET_SLOT(prior_R, components_sym);
    int n = LENGTH(components_R);
    
    SEXP offsetsComponents_R = GET_SLOT(prior_R, offsetsComponents_sym); /* list */
    
    int forward = 1; /* for all */
    
    for (int i = 0; i < n; ++i) {
        
        int *this_offset = INTEGER(VECTOR_ELT(offsetsComponents_R, i));
        int first = this_offset[0] - 1;
        int last = this_offset[1] - 1 ;
        
        int this_nValues = last - first + 1;
        double *this_values = values + first; 
        
        /* function deleted */
        #if(0)
        transferParamPolyComponent(VECTOR_ELT(components_R, i), 
                        this_values, this_nValues, forward);
        #endif
    }
    
    transferParamPriorV(prior_R, values, nValues);
}

void
transferParamPrior_PolyPredict(SEXP prior_R, double *values, 
                                            int nValues) 
{
    SEXP components_R = GET_SLOT(prior_R, components_sym);
    int n = LENGTH(components_R);
    
    SEXP offsetsComponents_R = GET_SLOT(prior_R, offsetsComponents_sym); /* list */
    
    int forward = *INTEGER(GET_SLOT(prior_R, forward_sym));

     for (int i = 0; i < n; ++i) {

        int *this_offset = INTEGER(VECTOR_ELT(offsetsComponents_R, i));
        int first = this_offset[0] - 1;
        int last = this_offset[1] - 1 ;
        
        int this_nValues = last - first + 1;
        double *this_values = values + first; 
        
        /* function deleted */
        #if(0)
        transferParamPolyComponent(VECTOR_ELT(components_R, i), 
                        this_values, this_nValues, forward);
		#endif
    }
    
    transferParamPriorV(prior_R, values, nValues);
}

void
transferParamPrior_AR10(SEXP prior_R, double *values, 
                                            int nValues) 
{
    transferParamGammaAR1(prior_R, values, nValues);
    /* functions removed */
	#if(0)
	updateGammaNoInitialAR1(prior_R);
    updateGammaHatAR10(prior_R);
    #endif
    transferParamPhiAR1(prior_R, values, nValues);
    transferParamPriorV(prior_R, values, nValues);
    transferParamPriorWAR1(prior_R, values, nValues);
}

void
transferParamPrior_AR11(SEXP prior_R, double *values, 
                                            int nValues) 
{
    transferParamGammaAR1(prior_R, values, nValues);
    /* function removed */
    #if(0)
    updateGammaNoInitialAR1(prior_R);
    #endif
    transferParamDeltaAR11(prior_R, values, nValues);
    
    
    #if(0) /* these functions deleted */
    updateDeltaNoInitialAR11(prior_R);
    updateDeltaHatAR11(prior_R);
    #endif
    
    transferParamPhiAR1(prior_R, values, nValues);
    /* function removed */
    #if(0)
    updateGAR11(prior_R);
    #endif
    transferParamPriorV(prior_R, values, nValues);
    transferParamPriorWAR1(prior_R, values, nValues);
}

void
transferParamPrior_AR10Predict(SEXP prior_R, double *values, 
                                            int nValues) 
{
    transferParamGamma0AR1Predict(prior_R, values, nValues);
    transferParamPhiAR1(prior_R, values, nValues);
    transferParamPriorV(prior_R, values, nValues);
    transferParamPriorWAR1(prior_R, values, nValues);
}

void
transferParamPrior_AR11Predict(SEXP prior_R, double *values, 
                                            int nValues) 
{
    transferParamGamma0AR1Predict(prior_R, values, nValues);
    transferParamDelta0AR11Predict(prior_R, values, nValues);
    transferParamPhiAR1(prior_R, values, nValues);
    /* function removed */
    #if(0)
    updateGAR11(prior_R);
    #endif
    transferParamPriorV(prior_R, values, nValues);
    transferParamPriorWAR1(prior_R, values, nValues);
}

void
transferParamPrior(SEXP prior_R, double *values, int nValues) 
{
    int i_method_prior = *(INTEGER(GET_SLOT(prior_R, iMethodPrior_sym)));
    
    switch(i_method_prior)
    {
        case 1:
            transferParamPrior_ExchNormZeroKnown(prior_R, values, nValues);
            break;
        case 2:
            transferParamPrior_ExchNormZeroUnknown(prior_R, values, nValues);
            break;
        case 3:
            transferParamPrior_ExchNormCovKnown(prior_R, values, nValues);
            break;
        case 4:
            transferParamPrior_ExchNormCovUnknown(prior_R, values, nValues);
            break;
        case 5:
            transferParamPrior_ExchRobustZeroKnown(prior_R, values, nValues);
            break;
        case 6:
            transferParamPrior_ExchRobustZeroUnknown(prior_R, values, nValues);
            break;
        case 7:
            transferParamPrior_ExchRobustCovKnown(prior_R, values, nValues);
            break;
        case 8:
            transferParamPrior_ExchRobustCovUnknown(prior_R, values, nValues);
            break;
        case 28:
            transferParamPrior_Poly(prior_R, values, nValues);
            break;
        case 29:
            transferParamPrior_AR10(prior_R, values, nValues);
            break;
        case 30:
            transferParamPrior_AR11(prior_R, values, nValues);
            break;
        case 128:
            transferParamPrior_PolyPredict(prior_R, values, nValues);
            break;
        case 129:
            transferParamPrior_AR10Predict(prior_R, values, nValues);
            break;
        case 130:
            transferParamPrior_AR11Predict(prior_R, values, nValues);
            break;
        default:
            error("unknown i_method_prior for transferParamPrior: %d", i_method_prior);
            break;
    }
}


void
transferParamPriorVarDLM_NormUnknown(SEXP prior_R, double *values, 
                                                int nValues) 
{
    SET_SLOT(prior_R, tau_sym, ScalarReal(values[0]));
}

void
transferParamPriorVarDLM_RobustUnknown(SEXP prior_R, double *values,
                                                int nValues) 
{
    SET_SLOT(prior_R, tau_sym, ScalarReal(values[0]));
}


void
transferParamPriorVarDLM(SEXP prior_R, double *values, int nValues) 
{
    int iMethodPriorVarDLM = *(INTEGER(GET_SLOT(prior_R, 
                                            iMethodPriorVarDLM_sym)));
    
    switch(iMethodPriorVarDLM)
    {
        case 2:
            transferParamPriorVarDLM_NormUnknown(prior_R, values, nValues);
            break;
        
        case 4:
            transferParamPriorVarDLM_RobustUnknown(prior_R, values, nValues);
            break;
        
        default:
            error("unknown iMethodPriorVarDLM for transferParamPriorVarDLM: %d", 
                                            iMethodPriorVarDLM);
            break;
    }
}

void updatePrior(SEXP prior, SEXP beta_R, double zeta); 
void updatePrior_ExchNormZeroKnown(SEXP prior, SEXP beta_R, double zeta); 
void updatePrior_ExchNormZeroUnknown(SEXP prior, SEXP beta_R, double zeta); 
void updatePrior_ExchNormCovKnown(SEXP prior, SEXP beta_R, double zeta); 
void updatePrior_ExchNormCovUnknown(SEXP prior, SEXP beta_R, double zeta); 
void updatePrior_ExchRobustZeroKnown(SEXP prior, SEXP beta_R, double zeta); 
void updatePrior_ExchRobustZeroUnknown(SEXP prior, SEXP beta_R, double zeta); 
void updatePrior_ExchRobustCovKnown(SEXP prior, SEXP beta_R, double zeta); 
void updatePrior_ExchRobustCovUnknown(SEXP prior, SEXP beta_R, double zeta); 
void updatePrior_Uniform(SEXP prior, SEXP beta_R, double zeta); 
void updatePrior_KnownCertain(SEXP prior, SEXP beta_R, double zeta); 
void updatePrior_KnownUncertain(SEXP prior, SEXP beta_R, double zeta); 
void updatePrior_Poly(SEXP prior, SEXP beta_R, double zeta); 
void updatePrior_PolyPredict(SEXP prior, SEXP beta_R, double zeta); 
void updatePrior_AR10(SEXP prior, SEXP beta_R, double zeta); 
void updatePrior_AR11(SEXP prior, SEXP beta_R, double zeta); 

UPDATEPRIORWITHZETA_WRAPPER_R(updatePrior);
UPDATEPRIORWITHZETA_WRAPPER_R(updatePrior_ExchNormZeroKnown);
UPDATEPRIORWITHZETA_WRAPPER_R(updatePrior_ExchNormZeroUnknown);
UPDATEPRIORWITHZETA_WRAPPER_R(updatePrior_ExchNormCovKnown);
UPDATEPRIORWITHZETA_WRAPPER_R(updatePrior_ExchNormCovUnknown);
UPDATEPRIORWITHZETA_WRAPPER_R(updatePrior_ExchRobustZeroKnown);
UPDATEPRIORWITHZETA_WRAPPER_R(updatePrior_ExchRobustZeroUnknown);
UPDATEPRIORWITHZETA_WRAPPER_R(updatePrior_ExchRobustCovKnown);
UPDATEPRIORWITHZETA_WRAPPER_R(updatePrior_ExchRobustCovUnknown);
UPDATEPRIORWITHZETA_WRAPPER_R(updatePrior_Uniform);
UPDATEPRIORWITHZETA_WRAPPER_R(updatePrior_KnownCertain);
UPDATEPRIORWITHZETA_WRAPPER_R(updatePrior_KnownUncertain);
UPDATEPRIORWITHZETA_WRAPPER_R(updatePrior_Poly);
UPDATEPRIORWITHZETA_WRAPPER_R(updatePrior_PolyPredict);
UPDATEPRIORWITHZETA_WRAPPER_R(updatePrior_AR10);
UPDATEPRIORWITHZETA_WRAPPER_R(updatePrior_AR11);
  CALLDEF(updatePrior_R, 3),
  CALLDEF(updatePrior_ExchNormZeroKnown_R, 3),
  CALLDEF(updatePrior_ExchNormZeroUnknown_R, 3),
  CALLDEF(updatePrior_ExchNormCovKnown_R, 3),
  CALLDEF(updatePrior_ExchNormCovUnknown_R, 3),
  CALLDEF(updatePrior_ExchRobustZeroKnown_R, 3),
  CALLDEF(updatePrior_ExchRobustZeroUnknown_R, 3),
  CALLDEF(updatePrior_ExchRobustCovKnown_R, 3),
  CALLDEF(updatePrior_ExchRobustCovUnknown_R, 3),
  CALLDEF(updatePrior_Uniform_R, 3),
  CALLDEF(updatePrior_KnownCertain_R, 3),
  CALLDEF(updatePrior_KnownUncertain_R, 3),
  CALLDEF(updatePrior_Poly_R, 3),
  CALLDEF(updatePrior_PolyPredict_R, 3),
  CALLDEF(updatePrior_AR10_R, 3),
  CALLDEF(updatePrior_AR11_R, 3),
/* ****************** inline versions *************************** */

/* Exchangeable Normal */

static __inline__ void
updatePrior_ExchNormZeroKnown_i(SEXP prior, SEXP beta_R, double zeta)
{
    /* functions deleted */
    #if(0)
    updateTauKnown(prior, zeta);
    updateGammaNorm(prior, beta_R);
    #endif
}


static __inline__ void
updatePrior_ExchNormZeroUnknown_i(SEXP prior, SEXP beta_R, double zeta)
{
    /* functions deleted */
    #if(0)
    updateTauNormZeroUnknown(prior, beta_R, zeta);
    updateGammaNorm(prior, beta_R);
    #endif
}

static __inline__ void
updatePrior_ExchNormCovKnown_i(SEXP prior, SEXP beta_R, double zeta)
{
    #if(0) /* function deleted */
    updateTauKnown(prior, zeta);
    updateEtaNorm(prior, beta_R);
    #endif
    
}

static __inline__ void
updatePrior_ExchNormCovUnknown_i(SEXP prior, SEXP beta_R, double zeta)
{
    int n_update = N_UPDATE;
    for (int i = 0; i < n_update; ++i) {
        
        #if(0) /* function deleted */
        updateTauNormCovUnknown(prior, beta_R, zeta);
        updateEtaNorm(prior, beta_R);
        #endif
    }
  
}

/* Exchangeable Robust */

static __inline__ void
updatePrior_ExchRobustZeroKnown_i(SEXP prior, SEXP beta_R, double zeta)
{
    int n_update = N_UPDATE;
     /* function deleted */
	#if(0)
	updateTauKnown(prior, zeta);
	#endif
    for (int i = 0; i < n_update; ++i) {
        /* functions deleted */
        #if(0)
        updateUZero(prior, beta_R);
        updateGammaRobust(prior, beta_R);
        #endif
    }
}

static __inline__ void
updatePrior_ExchRobustZeroUnknown_i(SEXP prior, SEXP beta_R, double zeta)
{
    int n_update = N_UPDATE;
    for (int i = 0; i < n_update; ++i) {
        /* functions deleted */
        #if(0)
        updateTauRobustUnknown(prior, beta_R, zeta);
        updateUZero(prior, beta_R);
        updateGammaRobust(prior, beta_R);
        #endif
    }
}

static __inline__ void
updatePrior_ExchRobustCovKnown_i(SEXP prior, SEXP beta_R, double zeta)
{
    int n_update = N_UPDATE;
    #if(0) /* function deleted */
    updateTauKnown(prior, zeta);
    #endif
    for (int i = 0; i < n_update; ++i) {
                
        #if(0) /* functions deleted */
        updateUCov(prior, beta_R);
        updateEtaRobust(prior, beta_R);
        #endif
        
    }  
}

static __inline__ void
updatePrior_ExchRobustCovUnknown_i(SEXP prior, SEXP beta_R, double zeta)
{
    int n_update = N_UPDATE;
    for (int i = 0; i < n_update; ++i) {
        /* functions deleted */
        #if(0)
        updateTauRobustUnknown(prior, beta_R, zeta);
        updateUCov(prior, beta_R);
        updateEtaRobust(prior, beta_R);
        #endif
    }
}


/* random walk */
#if(0)
static __inline__ void
updatePrior_RWNormZeroKnown_i(SEXP prior, SEXP beta_R)
{
    SEXP beta_diffed_R;
    PROTECT(beta_diffed_R= diffRandomWalk_Internal(prior, beta_R));
    
    /* function deleted */
    #if(0)
    updateGammaNorm(prior, beta_diffed_R);
    #endif

    UNPROTECT(1); /* beta_diffed_R */
}

static __inline__ void
updatePrior_RWNormZeroUnknown_i(SEXP prior, SEXP beta_R)
{
    SEXP beta_diffed_R;
    PROTECT(beta_diffed_R= diffRandomWalk_Internal(prior, beta_R));
    
    updateTauAndAlphaNormZero(prior, beta_diffed_R);
    /* function deleted */
    #if(0)
    updateGammaNorm(prior, beta_diffed_R);
    #endif
    
    UNPROTECT(1); /* beta_diffed_R */
}



static __inline__ void
updatePrior_RWNormCovKnown_i(SEXP prior, SEXP beta_R)
{
    SEXP beta_diffed_R;
    PROTECT(beta_diffed_R= diffRandomWalk_Internal(prior, beta_R));
    
    #if(0) /* function deleted */
    updateEtaNorm(prior, beta_diffed_R);
    #endif
    
    UNPROTECT(1); /* beta_diffed_R */
}


static __inline__ void
updatePrior_RWNormCovUnknown_i(SEXP prior, SEXP beta_R)
{
    SEXP beta_diffed_R;
    PROTECT(beta_diffed_R= diffRandomWalk_Internal(prior, beta_R));
    
    updateTauAndAlphaNormCov(prior, beta_diffed_R);
    
    #if(0) /* function deleted */
    updateEtaNorm(prior, beta_diffed_R);
    #endif
    
    UNPROTECT(1); /* beta_diffed_R */
}


static __inline__ void
updatePrior_RWRobustZeroKnown_i(SEXP prior, SEXP beta_R)
{
    SEXP beta_diffed_R;
    PROTECT(beta_diffed_R= diffRandomWalk_Internal(prior, beta_R));
    
    /* functions deleted */
	#if(0)
	updateUZero(prior, beta_diffed_R);
	updateGammaRobust(prior, beta_diffed_R);
    #endif
    UNPROTECT(1); /* beta_diffed_R */
}

         
static __inline__ void
updatePrior_RWRobustZeroUnknown_i(SEXP prior, SEXP beta_R)
{
    SEXP beta_diffed_R;
    PROTECT(beta_diffed_R= diffRandomWalk_Internal(prior, beta_R));
    
    updateTauAndAlphaRobust(prior, beta_diffed_R);
    /* functions deleted */
	#if(0)
	updateUZero(prior, beta_diffed_R);
    updateGammaRobust(prior, beta_diffed_R);
    #endif
    UNPROTECT(1); /* beta_diffed_R */
}

          
static __inline__ void 
updatePrior_RWRobustCovKnown_i(SEXP prior, SEXP beta_R)
{
    SEXP beta_diffed_R;
    PROTECT(beta_diffed_R= diffRandomWalk_Internal(prior, beta_R));
    
    #if(0) /* functions deleted */
    updateUCov(prior, beta_diffed_R);
    updateEtaRobust(prior, beta_diffed_R);
    #endif
    
    UNPROTECT(1); /* beta_diffed_R */
}


static __inline__ void 
updatePrior_RWRobustCovUnknown_i(SEXP prior, SEXP beta_R)
{
    SEXP beta_diffed_R;
    PROTECT(beta_diffed_R= diffRandomWalk_Internal(prior, beta_R));

    updateTauAndAlphaRobust(prior, beta_diffed_R);
    
    
    #if(0) /* functions deleted */
    updateUCov(prior, beta_diffed_R);
    updateEtaRobust(prior, beta_diffed_R);
    #endif
    
    UNPROTECT(1); /* beta_diffed_R */
}
#endif

/* no updates */

static __inline__ void
updatePrior_NullOp_i(SEXP prior, SEXP beta_R, double zeta)
{
    /* Do nothing. Prior is not updated. */
}

static __inline__ void
updatePrior_KnownCertain_i(SEXP prior, SEXP beta_R, double zeta)
{
    double *valuesUnscaled = REAL(GET_SLOT(prior, valuesUnscaled_sym));
    SEXP values_R = GET_SLOT(prior, values_sym);
    double *values = REAL(values_R);
    int nValues = LENGTH(values_R);
    
    for (int i = 0; i < nValues; ++i) {
        values[i] = valuesUnscaled[i] / zeta;
    }
    
}

static __inline__ void
updatePrior_UnknownCertain_i(SEXP prior, SEXP beta_R, double zeta)
{
    SEXP meanUnscaled_R = GET_SLOT(prior, meanUnscaled_sym);
    int nMean = LENGTH(meanUnscaled_R);
    double *meanUnscaled = REAL(meanUnscaled_R);
    double *sdUnscaled = REAL(GET_SLOT(prior, sdUnscaled_sym));
    double *mean = REAL(GET_SLOT(prior, mean_sym));
    double *sd = REAL(GET_SLOT(prior, sd_sym));
    
    for (int i = 0; i < nMean; ++i) {
        mean[i] = meanUnscaled[i] / zeta;
        sd[i] = sdUnscaled[i] / fabs(zeta);
    }
}


static __inline__ void
updatePrior_AR10_i(SEXP prior, SEXP beta_R, double zeta)
{
    int n_update = N_UPDATE;
    for (int i = 0; i < n_update; ++i) {
        /* functions removed */
		#if(0)
		updateVPriorVAR1(prior, beta_R, zeta);
        updateWPriorWAR10(prior, zeta);
        updateGammaAR10(prior, beta_R); /* changed name */
        updateGammaNoInitialAR1(prior);
        updateGammaHatAR10(prior);
        updatePhiAR10(prior);
		#endif
    }
}

static __inline__ void
updatePrior_AR11_i(SEXP prior, SEXP beta_R, double zeta)
{
    
    int forward = 1; /* true */
    
    int n_update = N_UPDATE;
    for (int i = 0; i < n_update; ++i) {
        /* functions removed */
		#if(0)
		updateVPriorVAR1(prior, beta_R, zeta);
        updateWPriorWAR11(prior, zeta);
        updateGammaDeltaAR11(prior, beta_R, forward);
        updateGammaNoInitialAR1(prior);
        updateDeltaNoInitialAR11(prior);
        updateDeltaHatAR11(prior);
        updatePhiAR11(prior);
        updateGAR11(prior);
		#endif
    }
}

/* uber-updatePrior function that uses the iMethodPrior identifier to
 * call appropriate specific updatePrior function for prior type.
 * 
 * This (or some equivalent) is necessary to emulate method-dispatch
 * in the C code.  It could be done more elegantly but this method
 * is simple, easy to understand and update, and does not carry a 
 * large overhead. 
 * 
 */
void
updatePrior(SEXP prior, SEXP beta_R, double zeta)
{
    int i_method_prior = *(INTEGER(GET_SLOT(prior, iMethodPrior_sym)));
    
    switch(i_method_prior)
    {
        case 1:
            updatePrior_ExchNormZeroKnown_i(prior, beta_R, zeta);
            break;
        case 2:
            updatePrior_ExchNormZeroUnknown_i(prior, beta_R, zeta);
            break;
        case 3:
            updatePrior_ExchNormCovKnown_i(prior, beta_R, zeta);
            break;
        case 4:
            updatePrior_ExchNormCovUnknown_i(prior, beta_R, zeta);
            break;
        case 5:
            updatePrior_ExchRobustZeroKnown_i(prior, beta_R, zeta);
            break;
        case 6:
            updatePrior_ExchRobustZeroUnknown_i(prior, beta_R, zeta);
            break;
        case 7:
            updatePrior_ExchRobustCovKnown_i(prior, beta_R, zeta);
            break;
        case 8:
            updatePrior_ExchRobustCovUnknown_i(prior, beta_R, zeta);
            break;
        case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24:
            error("updates not yet translated: %d", i_method_prior);
            break;
        case 25:
            updatePrior_NullOp_i(prior, beta_R, zeta); /* null op */
            break;
        case 26:
            updatePrior_KnownCertain_i(prior, beta_R, zeta);
            break;
        case 27:
            updatePrior_UnknownCertain_i(prior, beta_R, zeta);
            break;
        case 28:
            updatePrior_Poly(prior, beta_R, zeta); 
            break;
        case 29:
            updatePrior_AR10_i(prior, beta_R, zeta); 
            break;
        case 30:
            updatePrior_AR11_i(prior, beta_R, zeta); 
            break;
        case 128:
            updatePrior_PolyPredict(prior, beta_R, zeta); 
            break;
        default:
            error("unknown i_method_prior: %d", i_method_prior);
            break;
    }
}

void
updatePrior_ExchNormZeroKnown(SEXP prior, SEXP beta_R, double zeta)
{
    updatePrior_ExchNormZeroKnown_i(prior, beta_R, zeta);
}



void
updatePrior_ExchNormZeroUnknown(SEXP prior, SEXP beta_R, double zeta)
{
    updatePrior_ExchNormZeroUnknown_i(prior, beta_R, zeta);
}

void
updatePrior_ExchNormCovKnown(SEXP prior, SEXP beta_R, double zeta)
{
    updatePrior_ExchNormCovKnown_i(prior, beta_R, zeta);
}

void
updatePrior_ExchNormCovUnknown(SEXP prior, SEXP beta_R, double zeta)
{
    updatePrior_ExchNormCovUnknown_i(prior, beta_R, zeta);
}

/* Exchangeable Robust */

void
updatePrior_ExchRobustZeroKnown(SEXP prior, SEXP beta_R, double zeta)
{
    updatePrior_ExchRobustZeroKnown_i(prior, beta_R, zeta);
}


void
updatePrior_ExchRobustZeroUnknown(SEXP prior, SEXP beta_R, double zeta)
{
    updatePrior_ExchRobustZeroUnknown_i(prior, beta_R, zeta);
}


     
void
updatePrior_ExchRobustCovKnown(SEXP prior, SEXP beta_R, double zeta)
{
    updatePrior_ExchRobustCovKnown_i(prior, beta_R, zeta);
}



void
updatePrior_ExchRobustCovUnknown(SEXP prior, SEXP beta_R, double zeta)
{
    updatePrior_ExchRobustCovUnknown_i(prior, beta_R, zeta);
}


/* random walk */
#if(0)
void
updatePrior_RWNormZeroKnown(SEXP prior, SEXP beta_R)
{
    updatePrior_RWNormZeroKnown_i(prior, beta_R);
}

void
updatePrior_RWNormZeroUnknown(SEXP prior, SEXP beta_R)
{
    updatePrior_RWNormZeroUnknown_i(prior, beta_R);
}



void
updatePrior_RWNormCovKnown(SEXP prior, SEXP beta_R)
{
    updatePrior_RWNormCovKnown_i(prior, beta_R);
}


void
updatePrior_RWNormCovUnknown(SEXP prior, SEXP beta_R)
{
    updatePrior_RWNormCovUnknown_i(prior, beta_R);
}


void
updatePrior_RWRobustZeroKnown(SEXP prior, SEXP beta_R)
{
    updatePrior_RWRobustZeroKnown_i(prior, beta_R);
}

         
void
updatePrior_RWRobustZeroUnknown(SEXP prior, SEXP beta_R)
{
    updatePrior_RWRobustZeroUnknown_i(prior, beta_R);
}

          
void 
updatePrior_RWRobustCovKnown(SEXP prior, SEXP beta_R)
{
    updatePrior_RWRobustCovKnown_i(prior, beta_R);
}


void 
updatePrior_RWRobustCovUnknown(SEXP prior, SEXP beta_R)
{
    updatePrior_RWRobustCovUnknown_i(prior, beta_R);
}
#endif

/* Uniform */
void
updatePrior_Uniform(SEXP prior, SEXP beta_R, double zeta)
{
    updatePrior_NullOp_i(prior, beta_R, zeta);
}

/* KnownCertain */
void
updatePrior_KnownCertain(SEXP prior, SEXP beta_R, double zeta)
{
    updatePrior_KnownCertain_i(prior, beta_R, zeta);
}

/* KnownUncertain */
void
updatePrior_KnownUncertain(SEXP prior, SEXP beta_R, double zeta)
{
    updatePrior_UnknownCertain_i(prior, beta_R, zeta);
}

void
updatePrior_Poly(SEXP prior_R, SEXP beta_R, double zeta)
{
	SEXP components_R = GET_SLOT(prior_R, components_sym);
	int n = LENGTH(components_R);
	
	int J = LENGTH(beta_R);
	double *beta = REAL(beta_R);
    
    double *v = REAL(GET_SLOT(prior_R, v_sym));
	
	SEXP priorV = GET_SLOT(prior_R, priorV_sym); /* a PriorVarDLM */
    
    int n_update = N_UPDATE;
        
    double *workspace = (double *)R_alloc(J, sizeof(double));
    
    int forward = 1; /* true */
	
    for (int j = 0; j < n_update; ++j) {
    
        /* treat workspace as beta.hat here */
        betaHatPoly_Internal(workspace, J, components_R, forward);
            
        /* priorV changed in place */
        updatePriorVarDLM_Internal(priorV, v, J, beta, workspace, zeta);
                
        /* v changed in place */
        updateVarDLM_Internal(v, J, priorV, beta, workspace);
        
        for (int i = 0; i < n; ++i) {
            
            SEXP component_R = VECTOR_ELT(components_R, i);
			/* function deleted */
			#if(0)
            updateWAndPriorsW(component_R, zeta);
			#endif
            /* treat workspace as betaTilde here */
            memcpy(workspace, beta, J*sizeof(double));
            betaTilde_Internal(workspace, J, components_R, i, forward);
            
            FFBS_Internal(component_R, workspace, v, forward);
        }
    }
}

void
updatePrior_PolyPredict(SEXP prior_R, SEXP beta_R, double zeta)
{
	SEXP components_R = GET_SLOT(prior_R, components_sym);
	int n = LENGTH(components_R);
	
	int J = LENGTH(beta_R);
	double *beta = REAL(beta_R);
    
    double *v = REAL(GET_SLOT(prior_R, v_sym));
	
	SEXP priorV = GET_SLOT(prior_R, priorV_sym); /* a PriorVarDLM */
    
    int n_update = N_UPDATE;
        
    double *workspace = (double *)R_alloc(J, sizeof(double));
    
    int forward = *INTEGER(GET_SLOT(prior_R, forward_sym));

    for (int j = 0; j < n_update; ++j) {
    
        /* treat workspace as beta.hat here */
        betaHatPoly_Internal(workspace, J, components_R, forward);
            
        /* priorV changed in place */
        updatePriorVarDLM_Internal(priorV, v, J, beta, workspace, zeta);
                
        /* v changed in place */
        updateVarDLM_Internal(v, J, priorV, beta, workspace);
        
        for (int i = 0; i < n; ++i) {
            
            SEXP component_R = VECTOR_ELT(components_R, i);

            /* function deleted */
			#if(0)
            updateWAndPriorsW(component_R, zeta);
			#endif
            /* treat workspace as betaTilde here */
            memcpy(workspace, beta, J*sizeof(double));
            betaTilde_Internal(workspace, J, components_R, i, forward);
            
            FFBS_Internal(component_R, workspace, v, forward);
        }
    }
}


void 
updatePrior_AR10(SEXP prior_R, SEXP beta_R, double zeta)
{
    updatePrior_AR10_i(prior_R, beta_R, zeta);
}

void 
updatePrior_AR11(SEXP prior_R, SEXP beta_R, double zeta)
{
    updatePrior_AR11_i(prior_R, beta_R, zeta);
}
  
/* update beta methods */
void updateBeta_ExchNormZero(SEXP beta_R, SEXP prior, 
                        double* vbar, int n, double sigma);
void updateBeta_ExchNormCov(SEXP beta_R, SEXP prior, 
                        double* vbar, int n, double sigma);
void updateBeta_ExchRobustZero(SEXP beta_R, SEXP prior, 
                        double* vbar, int n, double sigma);
void updateBeta_ExchRobustCov(SEXP beta_R, SEXP prior, 
                        double* vbar, int n, double sigma);
void updateBeta_RWNormZero(SEXP beta_R, SEXP prior, 
                        double* vbar, int n, double sigma);
void updateBeta_RWNormCov(SEXP beta_R, SEXP prior, 
                        double* vbar, int n, double sigma);
void updateBeta_RWRobustZero(SEXP beta_R, SEXP prior, 
                        double* vbar, int n, double sigma);
void updateBeta_RWRobustCov(SEXP beta_R, SEXP prior, 
                        double* vbar, int n, double sigma);
void updateBeta_Uniform(SEXP beta_R, SEXP prior, 
                        double* vbar, int n, double sigma);       
void updateBeta_KnownCertain(SEXP beta_R, SEXP prior, 
                        double* vbar, int n, double sigma);       
void updateBeta_KnownUncertain(SEXP beta_R, SEXP prior, 
                        double* vbar, int n, double sigma);       
void updateBeta_Poly(SEXP beta_R, SEXP prior, 
                        double *vbar, int n, double sigma);
void updateBeta_AR10(SEXP beta_R, SEXP prior_R,
                        double *vbar, int n, double sigma);
void updateBeta_AR11(SEXP beta_R, SEXP prior_R,
                        double *vbar, int n, double sigma);
UPDATEBETA_WRAPPER_R(updateBeta);
UPDATEBETA_WRAPPER_R(updateBeta_ExchNormZero);
UPDATEBETA_WRAPPER_R(updateBeta_ExchNormCov);
UPDATEBETA_WRAPPER_R(updateBeta_ExchRobustZero);
UPDATEBETA_WRAPPER_R(updateBeta_ExchRobustCov);
UPDATEBETA_WRAPPER_R(updateBeta_RWNormZero);
UPDATEBETA_WRAPPER_R(updateBeta_RWNormCov);
UPDATEBETA_WRAPPER_R(updateBeta_RWRobustZero);
UPDATEBETA_WRAPPER_R(updateBeta_RWRobustCov);
UPDATEBETA_WRAPPER_R(updateBeta_Uniform);
UPDATEBETA_WRAPPER_R(updateBeta_KnownCertain);
UPDATEBETA_WRAPPER_R(updateBeta_KnownUncertain);
UPDATEBETA_WRAPPER_R(updateBeta_Poly);
UPDATEBETA_WRAPPER_R(updateBeta_AR10);
UPDATEBETA_WRAPPER_R(updateBeta_AR11);
  CALLDEF(updateBeta_ExchNormZero_R, 5),
  CALLDEF(updateBeta_ExchNormCov_R, 5),
  CALLDEF(updateBeta_ExchRobustZero_R, 5),
  CALLDEF(updateBeta_ExchRobustCov_R, 5),
  CALLDEF(updateBeta_RWNormZero_R, 5),
  CALLDEF(updateBeta_RWNormCov_R, 5),
  CALLDEF(updateBeta_RWRobustZero_R, 5),
  CALLDEF(updateBeta_RWRobustCov_R, 5),
  CALLDEF(updateBeta_Uniform_R, 5),
  CALLDEF(updateBeta_KnownCertain_R, 5),
  CALLDEF(updateBeta_KnownUncertain_R, 5),
  CALLDEF(updateBeta_Poly_R, 5),
  CALLDEF(updateBeta_AR10_R, 5),
  CALLDEF(updateBeta_AR11_R, 5),

#if(0) /* function deleted (replaced)*/
void
updateBeta(SEXP beta_R, SEXP prior, 
                        double* vbar, int n, double sigma) 
{
    int i_method_prior = *(INTEGER(GET_SLOT(prior, iMethodPrior_sym)));
    
	switch(i_method_prior)
    {
        case 1: case 2:
            updateBeta_ExchNormZero(beta_R, prior, vbar, 
                                n, sigma); 
            break;
        case 3: case 4:
            updateBeta_ExchNormCov(beta_R, prior, vbar, 
                                n, sigma);
            break;
        case 5: case 6:
            updateBeta_ExchRobustZero(beta_R, prior, vbar, 
                                n, sigma);
            break;
        case 7: case 8:
            updateBeta_ExchRobustCov(beta_R, prior, vbar, 
                                n, sigma);
            break;
        case 9: case 10:
            updateBeta_RWNormZero(beta_R, prior, vbar, 
                                n, sigma); 
            break;
        case 11: case 12:
            updateBeta_RWNormCov(beta_R, prior, vbar, 
                                n, sigma);
            break;
        case 13: case 14:
            updateBeta_RWRobustZero(beta_R, prior, vbar, 
                                n, sigma);
            break;
        case 15: case 16:
            updateBeta_RWRobustCov(beta_R, prior, vbar, 
                                n, sigma);
            break;
        case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24:
            error("updates not yet translated: %d", i_method_prior);
            break;
        case 25:
            updateBeta_Uniform(beta_R, prior, vbar, 
                                n, sigma); 
            break;
        case 26:
            updateBeta_KnownCertain(beta_R, prior, vbar, 
                                n, sigma); 
            break;
        case 27:
            updateBeta_KnownUncertain(beta_R, prior, vbar, 
                                n, sigma); 
            break;
        case 28:
            updateBeta_Poly(beta_R, prior, vbar, 
                                n, sigma); 
            break;
        case 29:
            updateBeta_AR1_Internal(beta_R, prior, vbar, 
                                n, sigma); 
            break;
        case 30:
            updateBeta_AR1_Internal(beta_R, prior, vbar, 
                                n, sigma); 
            break;
        default:
            error("unknown i_method_prior: %d", i_method_prior);
            break;
    }
}
#endif


/* ******************************************************************************** */
/* Functions for updating betas. ************************************************* */
/* ******************************************************************************** */
/*
 * Functions that draw straight from the posterior distribution
 *
 * Include 'beta' argument in these functions even when it is not used,
 * because calling function passes the same arguments to all 'updateBeta'
 * functions, and 'beta' arguments will be needed by any future
 * 'updateBeta' functions that use Metropolis-Hastings updates.
 *
 * No helper functions, so do validity checking within
 * the R methods themselves.  (Still no validity checking
 * in the C code though.)
 */


#if(0) /* function deleted */
void
updateBeta_ExchNormZero(SEXP beta_R, SEXP prior, 
                        double *vbar, int n, double sigma)
{
    int J = LENGTH(beta_R);
    double *beta = REAL(beta_R);
    
    /* gamma and tau by value */
    double gamma = *(REAL(GET_SLOT(prior, gamma_sym)));
    double tau = *(REAL(GET_SLOT(prior, tau_sym)));
    
    /* gamma <- prior@gamma
      tau <- prior@tau
      J <- length(beta)
      prec.data <- n / sigma^2
      prec.prior <- 1 / tau^2
      var <- 1 / (prec.data + prec.prior)
      sd <- sqrt(var)
      mean <- var * (prec.data * vbar + prec.prior * gamma)
      rnorm(n = J, mean = mean, sd = sd) */
    
    double prec_data = n/(sigma*sigma);
    double prec_prior = 1/(tau*tau);
    double var = 1/(prec_data + prec_prior);
    double sd = sqrt(var);
    
    double mult_data = var * prec_data;
    double mean_prior = var * prec_prior * gamma;
    /* mean <- var * (prec.data * vbar + prec.prior * gamma)
      rnorm(n = J, mean = mean, sd = sd)*/
    for (int i = 0; i < J; ++i ) {
        beta[i] = rnorm(mult_data*vbar[i] + mean_prior, sd);
    }
}
#endif

#if(0) /* function deleted */
void
updateBeta_ExchNormCov(SEXP beta_R, SEXP prior, 
                        double *vbar, int n, double sigma)
{
    double *beta = REAL(beta_R);
    int J = LENGTH(beta_R);
    
    /* tau by value */
    double tau = *(REAL(GET_SLOT(prior, tau_sym)));
    
    /* tau <- prior@tau
      J <- length(beta)
      prec.data <- n / sigma^2
      prec.prior <- 1 / tau^2
      var <- 1 / (prec.data + prec.prior)
      sd <- sqrt(var)
      beta.hat <- betaHat(prior)
      mean <- var * (prec.data * vbar + prec.prior * beta.hat)
      rnorm(n = J, mean = mean, sd = sd)*/
    
    double prec_data = n/(sigma*sigma);
    double prec_prior = 1/(tau*tau);
    double var = 1/(prec_data + prec_prior);
    double sd = sqrt(var);
    
    /* beta.hat <- betaHat(prior) */
    double *beta_hat = (double *)R_alloc(J, sizeof(double));
    betaHat(beta_hat, prior, J);
    
    /* mean <- var * (prec.data * vbar + prec.prior * beta.hat)
      rnorm(n = J, mean = mean, sd = sd)*/
    for (int i = 0; i < J; ++i ) {
        
        beta[i] = rnorm( var*(prec_data*vbar[i] + prec_prior*beta_hat[i])
                            , sd);
    }
}
#endif


/* Exchangeable Robust betas*/

#if(0) /* function deleted */
void
updateBeta_ExchRobustZero(SEXP beta_R, SEXP prior, 
                        double *vbar, int n, double sigma)
{
    int J = LENGTH(beta_R);
    double *beta = REAL(beta_R);
    
    double gamma = *(REAL(GET_SLOT(prior, gamma_sym)));

    double *u = REAL(GET_SLOT(prior, U_sym));
    
    
    /* prec.data <- n / sigma^2 */
    double prec_data = n/(sigma*sigma);
    
    /* gamma <- prior@gamma
      U <- prior@U
      J <- length(beta)
      prec.data <- n / sigma^2
      prec.prior <- 1 / U
      var <- 1 / (prec.data + prec.prior)
      sd <- sqrt(var)
      mean <- var * (prec.data * vbar + prec.prior * gamma)
      rnorm(n = J, mean = mean, sd = sd)*/
    for (int i = 0; i < J; ++i ) {

        double prec_prior = 1/u[i];
        double var = 1/(prec_data + prec_prior);
        double sd = sqrt(var);
    
        beta[i] = rnorm(var * (prec_data*vbar[i] + prec_prior*gamma), sd);
    }
        
}
#endif

#if(0) /* function deleted */
void
updateBeta_ExchRobustCov(SEXP beta_R, SEXP prior, 
                        double *vbar, int n, double sigma)
{
    int J = LENGTH(beta_R);
    double *beta = REAL(beta_R);
    
    double *u = REAL(GET_SLOT(prior, U_sym));
    
    /* beta.hat <- betaHat(prior) */
    double *beta_hat = (double *)R_alloc(J, sizeof(double));
    betaHat(beta_hat, prior, J);
    
    /* prec.data <- n / sigma^2 */
    double prec_data = n/(sigma*sigma);
    
    /*  tau <- prior@tau
          U <- prior@U
          J <- length(beta)
          prec.data <- n / sigma^2
          prec.prior <- 1 / U
          var <- 1 / (prec.data + prec.prior)
          sd <- sqrt(var)
          beta.hat <- betaHat(prior)
          mean <- var * (prec.data * vbar + prec.prior * beta.hat)
          rnorm(n = J, mean = mean, sd = sd)
*/
    for (int i = 0; i < J; ++i ) {
        
        double prec_prior = 1/u[i];
        double var = 1/(prec_data + prec_prior);
        double sd = sqrt(var);
    
        beta[i] = rnorm( var*(prec_data*vbar[i] + prec_prior*beta_hat[i])
                        , sd);
    }
}
#endif
/* Random walk norm betas */

#if(0) /* function deleted */
void
updateBeta_RWNormZero(SEXP beta_R, SEXP prior, 
                        double *vbar, int n, double sigma)
{
    
    #ifdef DEBUGGING
        PrintValue(ScalarInteger(200));
        PrintValue(beta_R);
        PrintValue(ScalarInteger(300));
        printDblArray(vbar, n);
    #endif
    
    double *beta = REAL(beta_R);
    
    /* tau by value */
    double tau = *(REAL(GET_SLOT(prior, tau_sym)));
    
    SEXP gq_R = GET_SLOT(prior, Gq_sym);
    int *gq_dim =  INTEGER(GET_DIM(gq_R));
    /* J <- ncol(Gq) */
    int k = gq_dim[0]; 
    int J = gq_dim[1]; 
    int *gq = INTEGER(gq_R);
    
    /* FqTFq is a square matrix of doubles
     * ncol(FqTFq) equal to ncol(Gq) = J */
    double *fqTfq = REAL(GET_SLOT(prior, FqTFq_sym));
    
    double gamma = *REAL(GET_SLOT(prior, gamma_sym));
    
    /* iterator <- prior@iteratorBeta */
    SEXP iteratorBeta_R = GET_SLOT(prior, iteratorBeta_sym); 
    
    /* prec.prior <- (1 / tau^2) * crossprod(Gq) + FqTFq
     * but I just do (1 / tau^2) * crossprod(Gq) and store
     * result in an array var_inv */
    
    /* need Gq elements as doubles, and do a malloc that allows space for
     * J*k elements of Gq 
     * J*J elements of the crossproduct as well, 
     * J elements of qraux, 
     * 3* J doubles for three more vectors of length J
     * ie J*(k+J+4) doubles in all*/
    double *workspace = (double *)R_alloc(J*(k + J + 4), sizeof(double));
     
    /* workspace for qg is the first J*(k + J + 1) elements of this*/
    double *workspace_gq = workspace;
    /* and workspace for solving and 
     * doing mean.prior = (1 / tau^2) * crossprod(Gq, gamma)
     * is the last 3*J elements*/
    double *workspace_sl = workspace + J*(k + J + 1);
    
    /* first k*J elements of workspace_gq for gq as doubles */
    double *gq_doubles = workspace_gq; 
    memset(gq_doubles, 0, J*k * sizeof(double)); /* set all to 0.0 */
    
    /* last J elements of workspace_sl for 
     * mean.prior = (1 / tau^2) * crossprod(Gq, gamma) */
    double *mean_prior = workspace_sl + 2*J;
    
    /* loop to get doubles values into Gq and mean_prior
     *  - probably better ways to do this ... */
    for (int j = 0; j < J; ++j) {
        
        int crossProdGqGammaValue = 0;
        
        int i = 0;
        while ((i < k) && (gq[j*k+i]==0)) { /* gq element is 0 */
            ++i;
        }
        while ((i < k) && (gq[j*k+i]!=0)) { /* gq element is not 0 */
            int gqValue = gq[j*k+i];
            gq_doubles[j*k+i] = 1.0*gqValue;
            crossProdGqGammaValue += gqValue;
            ++i;
        }
        /* nothing more once at end of the non-zero elements in col j */
        mean_prior[j] = gamma*crossProdGqGammaValue/(tau*tau);
    }
    
    #ifdef DEBUGGING
    
        PrintValue(ScalarInteger(325));
        PrintValue(GET_SLOT(prior, FqTFq_sym));
        PrintValue(ScalarInteger(350));
        printDblArray(mean_prior, J);
    #endif
    
    /* use blas dgemm for crossproduct 
     * void dgemm(const char *transT, const char *transN,
       int *l, int *n, int *m, double *alpha, 
       const void *a, int *lda, void *b, int *ldb, 
       double *beta, void *c, int *ldc);*/
    char transT = 'T'; /* transpose operation */
    char transN = 'N'; /* no operation */
    double alpha_blas = 1/(tau*tau); /* scalar multiple to be applied */
    double beta_blas = 0.0; /* no multiple of c (input and return vec) */
    /* point var_inv to (k*J)th element in workspace_gq */
    double *var_inv = workspace_gq + k*J; 
    
    F77_CALL(dgemm)(&transT, &transN, &J, &J, &k, &alpha_blas, 
                    gq_doubles, &k, gq_doubles, &k, &beta_blas,
                    var_inv, &J);              
    /* var_inv should now contain the crossproduct/(tau^2) 
     * ie now var_inv = 1/(tau^2)crossproduct)Gq)
     * and final adj to add prec.data = n / sigma^2 and FqTFq*/
    
    /* prec.data <- diag(n / sigma^2, nrow = J)
     *   prec.prior <- (1 / tau^2) * crossprod(Gq) + FqTFq
     *   var.inv <- prec.data + prec.prior
 
     * ie need addition of n / sigma^2 to diagonal only 
     * and addition of FqTFq to the whole */
    double prec_data_value = n/(sigma*sigma);
    
    
    #ifdef DEBUGGING
        PrintValue(ScalarInteger(375));
        printDblArray(var_inv, J*J);
    #endif
    
    for (int j = 0 ; j < J; ++j) {
        /* non-diagonals */
        for (int i = 0; i < j; ++i) {
            double fqval = fqTfq[j*J + i];
            var_inv[j*J + i] += fqval;
            /* FqTFq is symmetrical */
            var_inv[i*J + j] += fqval;
        }
        /* diagonals */
        var_inv[j*J + j] += (prec_data_value + fqTfq[j*J + j]);
    }
    
    #ifdef DEBUGGING
        PrintValue(ScalarInteger(400));
        printDblArray(var_inv, J*J);
    #endif

    /* R <- qr.R(qr(var.inv)) 
     * Need to do qr decomposition of var_inv */
   
    /* stuff to do qr decomposition */
    int jpvt = 0; /* not pivoting */
    double work_qr = 0; /* work not needed since we are not pivoting */
    int job_qr = 0; /* no pivoting */
    
    /* qraux is filled in by call to dqrdc and used in call to dqrsl
     * we will use the last J elements allocated for workspace _gq
     * for this... */
    
    /* point qraux to (k*J + J*J) = (k+J)*J th element in workspace_gq */
    double *qraux = workspace_gq + (k+J)*J; 
    
    F77_CALL(dqrdc)(var_inv, &J, &J, &J, qraux, &jpvt, 
                            &work_qr, &job_qr);
                           
    /* after the call, var_inv contains R in its upper triangle and below
     * the diagonal var_inv contains info from which the orthogonal part
     * of the decomposition can be recovered, 
     * and qraux contains the information required to be able to do this
     */ 
    
    /* we will then need to use dqrsl and dtrsl for solve/backsolve */
    
    #ifdef DEBUGGING
        PrintValue(ScalarInteger(425));
        printDblArray(var_inv, k*J);
    #endif
    
    /* dummy variables for dqrsl */
    double qy = 0; 
    double rsd = 0;
    double xb = 0;
    
    /* things we want using dqrsl in the while loop */
    int job_sl = 100; /* compute coefficients */
    
    /* and point to the two different J-length parts of workspace_sl */
    double *y_and_g = workspace_sl;
    double *mean_coeff = workspace_sl + J;
    /* reuse y_and_g for qty */
    
    /* things we want using dtrsl in the while loop */
    int job_bsl = 01; /* solve t*x = b, t upper triangular */
    /* y_and_g used by dtrsl as well */
        
    /* used by by all F77 calls in the loop */
    int info = 0; /* could be changed by calls */
        
    /* iterator <- resetA(iterator) */
    resetA(iteratorBeta_R); 
    
    /*n.classifying <- length(beta) / J
      for (i in seq_len(n.classifying)) {
          indices <- iterator@indices
          g <- rnorm(n = J)
          mean.data <- prec.data %*% vbar[indices]
          mean.prior <- (1 / tau^2) * crossprod(Gq, gamma)
          mean <- solve(var.inv, mean.data + mean.prior)
          error <- backsolve(R, g)
          ans.i <- mean + error
          ans[indices] <- ans.i
          iterator <- advanceA(iterator)
    } */
    
    int *indices = INTEGER(GET_SLOT(iteratorBeta_R, indices_sym));
    
    int n_classifying = LENGTH(beta_R)/J; /* integer division */
    
    while (n_classifying > 0) {
        
        #ifdef DEBUGGING
            PrintValue(ScalarInteger(500));
            PrintValue(ScalarInteger(n_classifying));
        #endif
        
        /* mean.data <- prec.data %*% vbar[indices]
          mean.prior <- (1 / tau^2) * crossprod(Gq, gamma)
          mean <- solve(var.inv, mean.data + mean.prior) */

        
        /* use dqrsl to solve 
         * Ax = y, where y =  prec.data %*% vbar[indices] + mean_prior
         * dqrsl is used to get the coefficients x
         * which solve this, and which are called the
         * mean here*/
         
        /* first need y = prec.data %*% vbar[indices] + mean_prior*/
        for (int i = 0; i < J; ++i) {
            y_and_g[i] = vbar[indices[i]-1] * prec_data_value
                            + mean_prior[i];
        }
        
        #ifdef DEBUGGING_EXTRA
            PrintValue(ScalarInteger(600));
            printDblArray(y_and_g, J);
        #endif
        
        F77_CALL(dqrsl)(var_inv, &J, &J, &J, qraux, y_and_g, 
                    &qy, y_and_g, mean_coeff, &rsd, &xb, &job_sl, &info);
        if (info) error("error in dqrsl in updateBeta_RWNormZero: %d", info);
        /* after the call, we have the mean in mean_coeff */
        
        #ifdef DEBUGGING_EXTRA
            PrintValue(ScalarInteger(700));
            printDblArray(mean_coeff, J);
        #endif
        
        /* Do not need y from y_and_g any more, so reuse for g */
        for (int i = 0; i < J; ++i) {
            y_and_g[i] = rnorm(0.0, 1.0);
        }
    
        #ifdef DEBUGGING_EXTRA
            PrintValue(ScalarInteger(750));
            printDblArray(y_and_g, J);
        #endif
        
        /* now use dtrsl to solve Re = g for e*/
        F77_CALL(dtrsl)(var_inv, &J, &J, y_and_g, &job_bsl, &info);
        if (info) error("error in dtrsl in updateBeta_RWNormZero: %d", info);
        /* after the call, y_and_g contains the solution e for Re = g*/

        #ifdef DEBUGGING_EXTRA
            PrintValue(ScalarInteger(800));
            printDblArray(y_and_g, J);
        #endif

        /* update beta:
         * ans.i <- mean + error
         * ans[indices] <- ans.i*/
        for (int i = 0; i < J; ++i) {
            beta[indices[i]-1] = mean_coeff[i] + y_and_g[i];
        }
        #ifdef DEBUGGING_EXTRA
            PrintValue(ScalarInteger(900));
            PrintValue(beta_R);
        #endif
        
        advanceA(iteratorBeta_R); 
        
        --n_classifying;
    }
	//free(workspace);
}
#endif

#if(0) /* function deleted */
void
updateBeta_RWNormCov(SEXP beta_R, SEXP prior, 
                        double *vbar, int n, double sigma)
{
    double *beta = REAL(beta_R);
    
    /* tau by value */
    double tau = *(REAL(GET_SLOT(prior, tau_sym)));
    
    SEXP gq_R = GET_SLOT(prior, Gq_sym);
    int *gq_dim =  INTEGER(GET_DIM(gq_R));
    /* J <- ncol(Gq) */
    int k = gq_dim[0]; 
    int J = gq_dim[1]; 
    int *gq = INTEGER(gq_R);
    
    /* FqTFq is a square matrix of doubles
     * ncol(FqTFq) equal to ncol(Gq) = J */
    double *fqTfq = REAL(GET_SLOT(prior, FqTFq_sym));
        
    /* iteratorBeta <- prior@iteratorBeta */
    SEXP iteratorBeta_R = GET_SLOT(prior, iteratorBeta_sym); 
      
    /* iteratorDiffBeta <- prior@iteratorDiffBeta */
    SEXP iteratorDiffBeta_R = GET_SLOT(prior, iteratorDiffBeta_sym); 
     
    /* prec.prior <- (1 / tau^2) * crossprod(Gq) + FqTFq
     * but I just do (1 / tau^2) * crossprod(Gq) and store
     * result in an array var_inv */
    
    /* need Gq elements as doubles, and do a malloc that allows space for
     * J*k elements of Gq 
     * J*J elements of the crossproduct as well, 
     * J elements of qraux, 
     * 2* J doubles for two more vectors of length J
     * ie J*(k+J+4) doubles in all*/
    double *workspace = (double *)R_alloc(J*(k + J + 3), sizeof(double)); 
     
    /* workspace for qg is the first J*(k + J + 1) elements of this*/
    double *workspace_gq = workspace;
    /* and workspace for solving and 
     * doing mean.prior = (1 / tau^2) * crossprod(Gq, gamma)
     * is the last 3*J elements*/
    double *workspace_sl = workspace + J*(k + J + 1);
    
    /* first k*J elements of workspace_gq for gq as doubles */
    double *gq_doubles = workspace_gq; 
    memset(gq_doubles, 0, J*k * sizeof(double)); /* set all to 0.0 */
    
    /* loop to get values in - probably better ways to do this ... */
    for (int j = 0; j < J; ++j) {
        
        int i = 0;
        while ((i < k) && (gq[j*k+i]==0)) { /* gq element is 0 */
            ++i;
        }
        while ((i < k) && (gq[j*k+i]!=0)) { /* gq element is not 0 */
            gq_doubles[j*k+i] = 1.0*gq[j*k+i];
            ++i;
        }
        /* nothing more once at end of the non-zero elements in col j */
    }
    
    /* use blas dgemm for crossproduct 
     * void dgemm(const char *transT, const char *transN,
       int *l, int *n, int *m, double *alpha, 
       const void *a, int *lda, void *b, int *ldb, 
       double *beta, void *c, int *ldc);*/
    char transT = 'T'; /* transpose operation */
    char transN = 'N'; /* no operation */
    double alpha_blas = 1/(tau*tau); /* scalar multiple to be applied */
    double beta_blas = 0.0; /* no multiple of c (input and return vec) */
    /* point var_inv to (k*J)th element in workspace_gq */
    double *var_inv = workspace_gq + k*J; 
    
    F77_CALL(dgemm)(&transT, &transN, &J, &J, &k, &alpha_blas, 
                    gq_doubles, &k, gq_doubles, &k, &beta_blas,
                    var_inv, &J);              
    
    /* var_inv should now contain the crossproduct/(tau^2) 
     * ie now var_inv = 1/(tau^2)crossproduct)Gq)
     * and final adj to add prec.data = n / sigma^2 and FqTFq*/
    
    /* prec.data <- diag(n / sigma^2, nrow = J)
     *   prec.prior <- (1 / tau^2) * crossprod(Gq) + FqTFq
     *   var.inv <- prec.data + prec.prior
 
     * ie need addition of n / sigma^2 to diagonal only 
     * and addition of FqTFq to the whole */
    
    double prec_data_value = n/(sigma*sigma);
    for (int j = 0 ; j < J; ++j) {
        /* non-diagonals */
        for (int i = 0; i < j; ++i) {
            double fqval = fqTfq[j*J + i];
            var_inv[j*J + i] += fqval;
            /* FqTFq is symmetrical */
            var_inv[i*J + j] += fqval;
        }
        /* diagonals */
        var_inv[j*J + j] += (prec_data_value + fqTfq[j*J + j]);
    }
    
    /* R <- qr.R(qr(var.inv)) 
     * Need to do qr decomposition of var_inv */
   
    /* stuff to do qr decomposition */
    int jpvt = 0; /* not pivoting */
    double work_qr = 0; /* work not needed since we are not pivoting */
    int job_qr = 0; /* no pivoting */
    
    /* qraux is filled in by call to dqrdc and used in call to dqrsl
     * we will use the last J elements allocated for workspace _gq
     * for this... */
    
    /* point qraux to (k*J + J*J) = (k+J)*J th element in workspace_gq */
    double *qraux = workspace_gq + (k+J)*J; 
    
    F77_CALL(dqrdc)(var_inv, &J, &J, &J, qraux, &jpvt, 
                            &work_qr, &job_qr);
                           
    /* after the call, var_inv contains R in its upper triangle and below
     * the diagonal var_inv contains info from which the orthogonal part
     * of the decomposition can be recovered, 
     * and qraux contains the information required to be able to do this
     */ 
    
    /* we will then need to use dqrsl and dtrsl for solve/backsolve */
    
    /* dummy variables for dqrsl */
    double qy = 0; 
    double rsd = 0;
    double xb = 0;
    
    /* things we want using dqrsl in the while loop */
    int job_sl = 100; /* compute coefficients */
    
    /* things we want using dgemv in the while loop */
    int inc = 1; /* steps in matrix and vector */
    
    /* and point to the two different j-length parts of workspace_sl */
    double *y_and_g = workspace_sl;
    double *mean_coeff = workspace_sl + J;
    /* reuse y_and_g for qty */
    
    /* things we want using dtrsl in the while loop */
    int job_bsl = 01; /* solve t*x = b, t upper triangular */
    /* y_and_g used by dtrsl as well */
        
    /* used by by all F77 calls in the loop */
    int info = 0; /* could be changed by calls */
    
    /* beta.hat <- betaHat(prior) */
    double *beta_hat = (double *)R_alloc(J, sizeof(double));
    betaHat(beta_hat, prior, J);
    
    /* iteratorBeta <- resetA(iteratorBeta)
     * iteratorDiffBeta <- resetA(iteratorDiffBeta) */
    resetA(iteratorBeta_R); 
    resetA(iteratorDiffBeta_R); 
    
    /* n.classifying <- length(beta) / J
      for (i in seq_len(n.classifying)) {
                      indicesBeta <- iteratorBeta@indices
                      indicesDiffBeta <- iteratorDiffBeta@indices
                      g <- rnorm(n = J)
                      mean.data <- prec.data %*% vbar[indicesBeta]
                      mean.prior <- (1 / tau^2) * crossprod(Gq, beta.hat[indicesDiffBeta])
                      mean <- solve(var.inv, mean.data + mean.prior)
                      error <- backsolve(R, g)
                      ans.i <- mean + error
                      ## deleted the line 'ans.i <- drop(Cq %*% ans.i)'
                      ans[indicesBeta] <- ans.i
                      iteratorBeta <- advanceA(iteratorBeta)
                      iteratorDiffBeta <- advanceA(iteratorDiffBeta)
                  } */
    
    int *indicesBeta = INTEGER(GET_SLOT(iteratorBeta_R,
                                                        indices_sym));
    int *indicesDiffBeta = INTEGER(GET_SLOT(iteratorDiffBeta_R,
                                                        indices_sym));
        
    int n_classifying = LENGTH(beta_R)/J; /* integer division */
   
    while (n_classifying > 0) {
        
        /* mean.data <- prec.data %*% vbar[indicesBeta]
           mean.prior <- (1 / tau^2) * crossprod(Gq, beta.hat[indicesDiffBeta])
           mean <- solve(var.inv, mean.data + mean.prior) */
        
        /* use mean_coeff for beta.hat[indicesDiffBeta] 
         * beta.hat[indicesDiffBeta] is k long (mean_coeff is J long)
         * but this is okay because k <= J always */
        for (int i = 0; i < k; ++i) {
            mean_coeff[i] = beta_hat[indicesDiffBeta[i]-1];
        }
        
        /* do (1 / tau^2) * crossprod(Gq, beta.hat[indicesDiffBeta]) */
        F77_CALL(dgemv)(&transT, &k, &J, &alpha_blas, 
                    gq_doubles, &k, mean_coeff, &inc, &beta_blas, 
                    y_and_g, &inc);    
        /* result is stored in y_and_g */
        
        /* now add prec.data %*% vbar[indicesBeta] to y
         *    y_and_g*/
        for (int i = 0; i < J; ++i) {
            y_and_g[i] += vbar[indicesBeta[i]-1] * prec_data_value;
        }
        
        /* use dqrsl to solve 
         * Ax = y, where y =  mean.data + mean.prior, as above.
         * dqrsl is used to get the coefficients x
         * which solve this, and which are called the
         * mean_coeff here*/
        F77_CALL(dqrsl)(var_inv, &J, &J, &J, qraux, y_and_g, 
                    &qy, y_and_g, mean_coeff, &rsd, &xb, &job_sl, &info);
        if (info) error("error in dqrsl in updateBeta_RWNormCov: %d", info);
        /* after the call, we have the mean in mean_coeff */
        
        /* Do not need y from y_and_g any more, so reuse for g */
        for (int i = 0; i < J; ++i) {
            y_and_g[i] = rnorm(0.0, 1.0);
        }
    
        /* now use dtrsl to solve Re = g for e*/
        F77_CALL(dtrsl)(var_inv, &J, &J, y_and_g, &job_bsl, &info);
        if (info) error("error in dtrsl in updateBeta_RWNormCov: %d", info);
        /* after the call, g contains the solution e for Re = g*/

        /* update beta:
         * ans.i <- mean + error
         * ans[indices] <- ans.i*/
        for (int i = 0; i < J; ++i) {
            beta[indicesBeta[i]-1] = mean_coeff[i] + y_and_g[i];
        }
        
        advanceA(iteratorBeta_R); 
        advanceA(iteratorDiffBeta_R); 
        
        --n_classifying;
        
    }
}
#endif
              
#if(0) /* function deleted */
void
updateBeta_RWRobustZero(SEXP beta_R, SEXP prior, 
                        double *vbar, int n, double sigma)
{
    double *beta = REAL(beta_R);
    
    SEXP gq_R = GET_SLOT(prior, Gq_sym);
    int *gq_dim =  INTEGER(GET_DIM(gq_R));
    /* J <- ncol(Gq) */
    int k = gq_dim[0]; 
    int J = gq_dim[1]; 
    int *gq = INTEGER(gq_R);

    /* FqTFq is a square matrix of doubles
     * ncol(FqTFq) equal to ncol(Gq) = J */
    double *fqTfq = REAL(GET_SLOT(prior, FqTFq_sym));
    
    double gamma = *REAL(GET_SLOT(prior, gamma_sym));
            
    double *u = REAL(GET_SLOT(prior, U_sym));
    
    /* iterator <- prior@iteratorBeta */
    SEXP iteratorBeta_R = GET_SLOT(prior, iteratorBeta_sym); 
     
    /* iteratorDiffBeta <- prior@iteratorDiffBeta */
    SEXP iteratorDiffBeta_R = GET_SLOT(prior, iteratorDiffBeta_sym); 
    
    /* need Gq elements as doubles, and do a malloc that allows space for
     * k*J elements of Gq 
     * k*J elements for crossproduct(Gq, diag(1/U))
     * J*J elements of the crossproduct as well, 
     * J elements of qraux, 
     * 2* J doubles for two more vectors of length J
     * ie J*(k+J+3) doubles in all*/
    double *workspace = (double *)R_alloc(J*(2*k + J + 3), sizeof(double));
    
    /* workspace for qg is the first J*(2*k + J + 1) elements of this*/
    double *workspace_gq = workspace;
    /* and workspace for solving is the last 2*J elements*/
    double *workspace_sl = workspace + J*(2*k + J + 1);
    
    /* first k*J elements of workspace_gq for gq as doubles */
    double *gq_doubles = workspace_gq; 
    memset(gq_doubles, 0, J*k * sizeof(double)); /* set all to 0.0 */
    
    /* loop to get values in - probably better ways to do this ... */
    for (int j = 0; j < J; ++j) {
        
        int i = 0;
        while ((i < k) && (gq[j*k+i]==0)) { /* gq element is 0 */
            ++i;
        }
        while ((i < k) && (gq[j*k+i]!=0)) { /* gq element is not 0 */
            gq_doubles[j*k+i] = 1.0*gq[j*k+i];
            ++i;
        }
        /* nothing more once at end of the non-zero elements in col j */
    }
    
    /* point space for crossproduct(Gq, diag(1/U)) to j*Kth element of
     * of workspace_gq */
    double *gq_doubles_inv_u = workspace_gq + k*J; 
    /* but only set values in this within the while loop */
    
    /* prec.data <- diag(n / sigma^2, nrow = J) */
    double prec_data_value = n/(sigma*sigma);
    
    /* use blas dgemm for crossproducts in while loop
     * void dgemm(const char *transT, const char *transN,
       int *l, int *n, int *m, double *alpha, 
       const void *a, int *lda, void *b, int *ldb, 
       double *beta, void *c, int *ldc);*/
    char transT = 'T'; /* transpose operation */
    char transN = 'N'; /* no operation */
    double alpha_blas = 1.0; /* scalar multiple to be applied */
    double beta_blas = 0.0; /* no multiple of c (input and return vec) */
    /* point var_inv to (2*k*J)th element in workspace_gq */
    double *var_inv = workspace_gq + 2*k*J; 
    
    /* stuff to do qr decomposition */
    int jpvt = 0; /* not pivoting */
    double work_qr = 0; /* work not needed since we are not pivoting */
    int job_qr = 0; /* no pivoting */
    /* qraux is filled in by call to dqrdc and used in call to dqrsl
     * we will use the last J elements allocated for workspace _gq
     * for this... */
    
    /* point qraux to (2*k*J + J*J) = (2*k+J)*J th element in workspace_gq */
    double *qraux = workspace_gq + (2*k+J)*J; 
    
    /* we will then need to use dqrsl and dtrsl for solve/backsolve,
     * so set up dummy variables and others needed for dqrsl */
    double qy = 0; 
    double rsd = 0;
    double xb = 0;
    int job_sl = 100; /* compute coefficients */
    
    /* and point to the two different j-length parts of workspace_sl */
    double *y_and_g = workspace_sl;
    double *mean_coeff = workspace_sl + J;
    /* reuse y_and_g for qty */
    
    /* things we want using dtrsl in the while loop */
    int job_bsl = 01; /* solve t*x = b, t upper triangular */
    /* y_and_g used by dtrsl as well */
        
    /* used by by all F77 calls in the loop */
    int info = 0; /* could be changed by calls */
        
    /* iteratorBeta <- resetA(iteratorBeta) 
       iteratorDiffBeta <- resetA(iteratorDiffBeta) */
    resetA(iteratorBeta_R); 
    resetA(iteratorDiffBeta_R); 
    
    /*n.classifying <- length(beta) / J
      for (i in seq_len(n.classifying)) {
          indicesBeta <- iteratorBeta@indices
          indicesDiffBeta <- iteratorDiffBeta@indices
          D <- diag(U.inv[indicesDiffBeta])
          ## added '+ FqTFq' to following line
          prec.prior <- crossprod(Gq, D) %*% Gq + FqTFq
          var.inv <- prec.data + prec.prior
          R <- qr.R(qr(var.inv))
          g <- rnorm(n = J)
          ## the following 3 lines replace the single line
          ## 'mean <- solve(var.inv, prec.data %*% vbar[indicesBeta])'
          mean.data <- prec.data %*% vbar[indicesBeta]
          mean.prior <- crossprod(Gq, D) %*% gamma
          mean <- solve(var.inv, mean.data + mean.prior)
          error <- backsolve(R, g)
          ans.i <- mean + error
          ## dropped the line 'ans.i <- drop(Cq %*% ans.i)'
          ans[indicesBeta] <- ans.i
          iteratorBeta <- advanceA(iteratorBeta)
          iteratorDiffBeta <- advanceA(iteratorDiffBeta)
      } */
      
    int *indicesBeta = INTEGER(GET_SLOT(iteratorBeta_R,
                                                        indices_sym));
    int *indicesDiffBeta = INTEGER(GET_SLOT(iteratorDiffBeta_R,
                                                        indices_sym));
        
    int n_classifying = LENGTH(beta_R)/J; /* integer division */

    while (n_classifying > 0) {
        
        #ifdef DEBUGGING
            PrintValue(ScalarInteger(300));
            PrintValue(ScalarInteger(n_classifying));
        #endif
        
        /* D <- diag(U.inv[indicesDiffBeta]) 
          prec.prior <- crossprod(Gq, D) %*% Gq + FqTFq
          var.inv <- prec.data + prec.prior*/
          
        /* copy from gq_doubles into gq_doubles_inv_u 
         * and adjust to get crossprod(Gq, D) using us */
        memcpy(gq_doubles_inv_u, gq_doubles, k*J*sizeof(double));
        for (int j = 0; j < k; ++j) {
            
            double this_u = u[indicesDiffBeta[j] - 1]; 
            
            for (int i = 0; i < J; ++i) {
                gq_doubles_inv_u[j + i*k] /= this_u;
            }
        }
        
        /* dgemm for matrix crossproduct */                                                
        F77_CALL(dgemm)(&transT, &transN, &J, &J, &k, &alpha_blas, 
                    gq_doubles_inv_u, &k, gq_doubles, &k, &beta_blas,
                    var_inv, &J);              
        
        /* var_inv should now contain the crossproduct 
         * ie now var_inv = crossprod(Gq, D) %*% Gq
         * and final adj to add prec.data = n / sigma^2 and FqTFq*/
        
        /* prec.data <- diag(n / sigma^2, nrow = J)
         *   prec.prior <- crossprod(Gq, D) %*% Gq + FqTFq
              var.inv <- prec.data + prec.prior
     
         * ie need addition of n / sigma^2 to diagonal only 
         * and addition of FqTFq to the whole */
        for (int j = 0 ; j < J; ++j) {
            /* non-diagonals */
            for (int i = 0; i < j; ++i) {
                double fqval = fqTfq[j*J + i];
                var_inv[j*J + i] += fqval;
                /* FqTFq is symmetrical */
                var_inv[i*J + j] += fqval;
            }
            /* diagonals */
            var_inv[j*J + j] += (prec_data_value + fqTfq[j*J + j]);
        }
        
        #ifdef DEBUGGING
            PrintValue(ScalarInteger(400));
            printDblArray(var_inv, J*J);
        #endif
        
        /* R <- qr.R(qr(var.inv)) 
        * Need to do qr decomposition of var_inv */
        F77_CALL(dqrdc)(var_inv, &J, &J, &J, qraux, &jpvt, 
                            &work_qr, &job_qr);
                           
        /* after the call, var_inv contains R in its upper triangle 
         * and below the diagonal var_inv contains info from which
         * the orthogonal part of the decomposition can be recovered, 
         * and qraux contains the information required to do this */ 
        
        /* use dqrsl to solve 
         * Ax = y, where y =  prec.data %*% vbar[indicesBeta] 
         *          + crossprod(Gq, D) %*% gamma
        
         dqrsl is used to get the coefficients x
         * which solve this, and which are called the
         * mean here*/
        
        /* first need y = prec.data %*% vbar[indicesBeta] +
         *                  crossprod(Gq, D) %*% gamma */
        for (int j = 0; j < J; ++j) {
            
            /* accumulate all the elements in column j of 
             * crossprod(Gq, D) = gq_doubles_inv_u into the first element
             * in that column  -- this is okay because gq_doubles_inv_u
             * is reset every time we start at the top of the loop*/
            for (int i = 1; i < k; ++i) {
                gq_doubles_inv_u[j*k] += gq_doubles_inv_u[j*k+i];
            }
            /* mult first element in jth column of gq_doubles_inv_u 
             * by gamma, to get mean.prior = crossprod(Gq, D) %*% gamma 
             * in first row of gq_doubles_inv_u and add it to y*/
            
            y_and_g[j] = vbar[indicesBeta[j]-1] * prec_data_value
                            + gq_doubles_inv_u[j*k]*gamma;
        }
        
        #ifdef DEBUGGING_EXTRA
            PrintValue(ScalarInteger(600));
            printDblArray(y_and_g, J);
        #endif
        
        F77_CALL(dqrsl)(var_inv, &J, &J, &J, qraux, y_and_g, 
                    &qy, y_and_g, mean_coeff, &rsd, &xb, &job_sl, &info);
        if (info) error("error in dqrsl in updateBeta_RWRobustZero: %d", info);
        /* after the call, we have the mean in mean_coeff */
    
        #ifdef DEBUGGING_EXTRA
            PrintValue(ScalarInteger(700));
            printDblArray(mean_coeff, J);
        #endif
    
        /* Do not need y from y_and_g any more, so reuse for g */
        for (int i = 0; i < J; ++i) {
            y_and_g[i] = rnorm(0.0, 1.0);
        }
        
        #ifdef DEBUGGING_EXTRA
            PrintValue(ScalarInteger(750));
            printDblArray(y_and_g, J);
        #endif
        
        /* now use dtrsl to solve Re = g for e*/
        F77_CALL(dtrsl)(var_inv, &J, &J, y_and_g, &job_bsl, &info);
        if (info) error("error in dtrsl in updateBeta_RWRobustZero: %d", info);
        /* after the call, g contains the solution e for Re = g*/
        
        #ifdef DEBUGGING_EXTRA
            PrintValue(ScalarInteger(800));
            printDblArray(y_and_g, J);
        #endif
        
        /* update beta:
         * ans.i <- mean + error
         * ans[indices] <- ans.i*/
        for (int i = 0; i < J; ++i) {
            beta[indicesBeta[i]-1] = mean_coeff[i] + y_and_g[i];
        }
        
        #ifdef DEBUGGING_EXTRA
            PrintValue(ScalarInteger(900));
            PrintValue(beta_R);
        #endif
        
        advanceA(iteratorBeta_R); 
        advanceA(iteratorDiffBeta_R); 
        
        --n_classifying;
        
    }
}
#endif

#if(0) /* function deleted */
void
updateBeta_RWRobustCov(SEXP beta_R, SEXP prior, 
                        double *vbar, int n, double sigma)
{
    double *beta = REAL(beta_R);
    
    SEXP gq_R = GET_SLOT(prior, Gq_sym);
    int *gq_dim =  INTEGER(GET_DIM(gq_R));
    /* J <- ncol(Gq) */
    int k = gq_dim[0]; 
    int J = gq_dim[1]; 
    int *gq = INTEGER(gq_R);
    
    /* FqTFq is a square matrix of doubles
     * ncol(FqTFq) equal to ncol(Gq) = J */
    double *fqTfq = REAL(GET_SLOT(prior, FqTFq_sym));
    
    double *u = REAL(GET_SLOT(prior, U_sym));
    
    /* iterator <- prior@iteratorBeta */
    SEXP iteratorBeta_R = GET_SLOT(prior, iteratorBeta_sym); 
     
    /* iteratorDiffBeta <- prior@iteratorDiffBeta */
    SEXP iteratorDiffBeta_R = GET_SLOT(prior, iteratorDiffBeta_sym); 
    
    /* need Gq elements as doubles, and do a malloc that allows space for
     * J*k elements of Gq 
     * k*J elements for crossproduct(Gq, diag(1/U))
     * J*J elements of the crossproduct as well, 
     * J elements of qraux, 
     * 2* J doubles for two more vectors of length J
     * ie J*(k+J+3) doubles in all*/
    double *workspace = (double *)R_alloc(J*(2*k + J + 3), sizeof(double));   
     
    /* workspace for qg is the first J*(2*k + J + 1) elements of this*/
    double *workspace_gq = workspace;
    /* and workspace for solving is the last 2*J elements*/
    double *workspace_sl = workspace + J*(2*k + J + 1);
    
    /* first k*J elements of workspace_gq for gq as doubles */
    double *gq_doubles = workspace_gq; 
    memset(gq_doubles, 0, J*k * sizeof(double)); /* set all to 0.0 */
    
    /* loop to get values in - probably better ways to do this ... */
    for (int j = 0; j < J; ++j) {
        
        int i = 0;
        while ((i < k) && (gq[j*k+i]==0)) { /* gq element is 0 */
            ++i;
        }
        while ((i < k) && (gq[j*k+i]!=0)) { /* gq element is not 0 */
            gq_doubles[j*k+i] = 1.0*gq[j*k+i];
            ++i;
        }
        /* nothing more once at end of the non-zero elements in col j */
    }
    
    /* point space for crossproduct(Gq, diag(1/U)) to j*Kth element of
     * of workspace_gq */
    double *gq_doubles_inv_u = workspace_gq + k*J; 
    /* but only set values in this within the while loop */
    
    /* prec.data <- diag(n / sigma^2, nrow = J) */
    double prec_data_value = n/(sigma*sigma);
    
    /* use blas dgemm for crossproducts in while loop
     * void dgemm(const char *transT, const char *transN,
       int *l, int *n, int *m, double *alpha, 
       const void *a, int *lda, void *b, int *ldb, 
       double *beta, void *c, int *ldc);*/
    char transT = 'T'; /* transpose operation */
    char transN = 'N'; /* no operation */
    double alpha_blas = 1.0; /* scalar multiple to be applied */
    double beta_blas = 0.0; /* no multiple of c (input and return vec) */
    /* point var_inv to (2*k*J)th element in workspace_gq */
    double *var_inv = workspace_gq + 2*k*J; 
    
    /* stuff to do qr decomposition */
    int jpvt = 0; /* not pivoting */
    double work_qr = 0; /* work not needed since we are not pivoting */
    int job_qr = 0; /* no pivoting */
    /* qraux is filled in by call to dqrdc and used in call to dqrsl
     * we will use the last J elements allocated for workspace _gq
     * for this... */
    
    /* point qraux to (2*k*J + J*J) = (2*k+J)*J th element in workspace_gq */
    double *qraux = workspace_gq + (2*k+J)*J; 
    
    /* we will then need to use dqrsl and dtrsl for solve/backsolve,
     * so set up dummy variables and others needed for dqrsl */
    double qy = 0; 
    double rsd = 0;
    double xb = 0;
    int job_sl = 100; /* compute coefficients */
    
    /* things we want using dgemv in the while loop */
    int inc = 1; /* steps in matrix and vector */
    
    /* and point to the two different j-length parts of workspace_sl */
    double *y_and_g = workspace_sl;
    double *mean_coeff = workspace_sl + J;
    /* reuse y_and_g for qty */
    
    /* things we want using dtrsl in the while loop */
    int job_bsl = 01; /* solve t*x = b, t upper triangular */
    /* y_and_g used by dtrsl as well */
        
    /* used by by all F77 calls in the loop */
    int info = 0; /* could be changed by calls */
        
    /* iteratorBeta <- resetA(iteratorBeta) 
       iteratorDiffBeta <- resetA(iteratorDiffBeta) */
    resetA(iteratorBeta_R); 
    resetA(iteratorDiffBeta_R); 
    
    /* beta.hat <- betaHat(prior) */
    double *beta_hat = (double *)R_alloc(J, sizeof(double));
    betaHat(beta_hat, prior, J);
    
    /*for (i in seq_len(n.classifying)) {
          indicesBeta <- iteratorBeta@indices
          indicesDiffBeta <- iteratorDiffBeta@indices
          D <- diag(U.inv[indicesDiffBeta])
          prec.prior <- crossprod(Gq, D) %*% Gq + FqTFq
          var.inv <- prec.data + prec.prior
          R <- qr.R(qr(var.inv))
          mean.data <- prec.data %*% vbar[indicesBeta]
          mean.prior <- crossprod(Gq, D) %*% beta.hat[indicesDiffBeta]
          mean <- solve(var.inv, mean.data + mean.prior)
          g <- rnorm(n = J)
          error <- backsolve(R, g)
          ans.i <- mean + error
          ans[indicesBeta] <- ans.i
          iteratorBeta <- advanceA(iteratorBeta)
          iteratorDiffBeta <- advanceA(iteratorDiffBeta)
        }*/
    
    int *indicesBeta = INTEGER(GET_SLOT(iteratorBeta_R,
                                                    indices_sym));
    int *indicesDiffBeta = INTEGER(GET_SLOT(iteratorDiffBeta_R,
                                                    indices_sym));
    
    int n_classifying = LENGTH(beta_R)/J; /* integer division */
    
    while (n_classifying > 0) {
        
        #ifdef DEBUGGING
            PrintValue(ScalarInteger(300));
            PrintValue(ScalarInteger(n_classifying));
        #endif
        
        /* copy from gq_doubles into gq_doubles_inv_u 
         * and adjust to get crossprod(Gq, D) using us */
        memcpy(gq_doubles_inv_u, gq_doubles, k*J*sizeof(double));
        for (int j = 0; j < k; ++j) {
            
            double this_u = u[indicesDiffBeta[j] - 1]; 
            
            for (int i = 0; i < J; ++i) {
                gq_doubles_inv_u[j + i*k] /= this_u;
            }
        }
        
        #ifdef DEBUGGING
            PrintValue(ScalarInteger(350));
            printDblArray(gq_doubles_inv_u, k*J);
        #endif
        
        /* dgemm for matrix crossproduct */                                                
        F77_CALL(dgemm)(&transT, &transN, &J, &J, &k, &alpha_blas, 
                    gq_doubles_inv_u, &k, gq_doubles, &k, &beta_blas,
                    var_inv, &J);              
        
        /* var_inv should now contain the crossproduct 
         * ie now var_inv = crossprod(Gq, D) %*% Gq
         * and final adj to add prec.data = n / sigma^2 and FqTFq*/
        
        /* prec.data <- diag(n / sigma^2, nrow = J)
         *   prec.prior <- crossprod(Gq, D) %*% Gq + FqTFq
              var.inv <- prec.data + prec.prior
     
         * ie need addition of n / sigma^2 to diagonal only 
         * and addition of FqTFq to the whole */
        for (int j = 0 ; j < J; ++j) {
            /* non-diagonals */
            for (int i = 0; i < j; ++i) {
                double fqval = fqTfq[j*J + i];
                var_inv[j*J + i] += fqval;
                /* FqTFq is symmetrical */
                var_inv[i*J + j] += fqval;
            }
            /* diagonals */
            var_inv[j*J + j] += (prec_data_value + fqTfq[j*J + j]);
        }
        
         
        #ifdef DEBUGGING
            PrintValue(ScalarInteger(400));
            printDblArray(var_inv, J*J);
        #endif
        
         /* R <- qr.R(qr(var.inv)) 
        * Need to do qr decomposition of var_inv */
        F77_CALL(dqrdc)(var_inv, &J, &J, &J, qraux, &jpvt, 
                            &work_qr, &job_qr);
                           
        /* after the call, var_inv contains R in its upper triangle 
         * and below the diagonal var_inv contains info from which
         * the orthogonal part of the decomposition can be recovered, 
         * and qraux contains the information required to do this */ 
        
        /* use dqrsl to solve 
         * Ax = y, where y =  prec.data %*% vbar[indicesBeta] 
         *          + crossprod(Gq, D) %*% beta.hat[indicesDiffBeta]
        
         dqrsl is used to get the coefficients x
         * which solve this, and which are called the
         * mean here*/
        
        /* first need y = prec.data %*% vbar[indicesBeta] +
         *             crossprod(Gq, D) %*% beta.hat[indicesDiffBeta] */
        
        /* use mean_coeff for beta.hat[indicesDiffBeta] 
         * beta.hat[indicesDiffBeta] is k long (mean_coeff is J long)
         * but this is okay because k <= J always */
        for (int i = 0; i < k; ++i) {
            mean_coeff[i] = beta_hat[indicesDiffBeta[i]-1];
        }
        
        /* do crossprod(Gq, D) %*% beta.hat[indicesDiffBeta] */
        F77_CALL(dgemv)(&transT, &k, &J, &alpha_blas, 
                    gq_doubles_inv_u, &k, mean_coeff, &inc, &beta_blas, 
                    y_and_g, &inc);    
        /* result is stored in y_and_g */
        
        /* now add prec.data %*% vbar[indicesBeta] to y
         *    y_and_g*/
        for (int i = 0; i < J; ++i) {
            y_and_g[i] += vbar[indicesBeta[i]-1] * prec_data_value;
        }
        
        #ifdef DEBUGGING_EXTRA
            PrintValue(ScalarInteger(600));
            printDblArray(y_and_g, J);
        #endif
        
        /* use dqrsl to solve 
         * Ax = y, where y =  prec.data %*% vbar[indicesBeta] 
         *   + crossprod(Gq, D) %*% beta.hat[indicesDiffBeta], as above.
         * dqrsl is used to get the coefficients x
         * which solve this, and which are called the
         * mean_coeff here*/
        F77_CALL(dqrsl)(var_inv, &J, &J, &J, qraux, y_and_g, 
                    &qy, y_and_g, mean_coeff, &rsd, &xb, &job_sl, &info);
        if (info) error("error in dqrsl in updateBeta_RWNormCov: %d", info);
        /* after the call, we have the mean in mean_coeff */
        
        #ifdef DEBUGGING_EXTRA
            PrintValue(ScalarInteger(700));
            printDblArray(mean_coeff, J);
        #endif
        
        /* Do not need y from y_and_g any more, so reuse for g */
        for (int i = 0; i < J; ++i) {
            y_and_g[i] = rnorm(0.0, 1.0);
        }
        
         #ifdef DEBUGGING_EXTRA
            PrintValue(ScalarInteger(750));
            printDblArray(y_and_g, J);
        #endif
        
        /* now use dtrsl to solve Re = g for e*/
        F77_CALL(dtrsl)(var_inv, &J, &J, y_and_g, &job_bsl, &info);
        if (info) error("error in dtrsl in updateBeta_RWRobustCov: %d", info);
        /* after the call, g contains the solution e for Re = g*/
        
        #ifdef DEBUGGING_EXTRA
            PrintValue(ScalarInteger(800));
            printDblArray(y_and_g, J);
        #endif
        
        /* update beta:
         * ans.i <- mean + error
         * ans[indices] <- ans.i*/
        for (int i = 0; i < J; ++i) {
            beta[indicesBeta[i]-1] = mean_coeff[i] + y_and_g[i];
        }
    
         #ifdef DEBUGGING_EXTRA
            PrintValue(ScalarInteger(900));
            PrintValue(beta_R);
        #endif
        
        advanceA(iteratorBeta_R); 
        advanceA(iteratorDiffBeta_R); 
        
        --n_classifying;
        
    }
}
#endif

#if(0) /* function deleted */
void
updateBeta_Uniform(SEXP beta_R, SEXP prior, 
                        double *vbar, int n, double sigma)
{
    int J = LENGTH(beta_R);
    double *beta = REAL(beta_R);
    
    double sd = sigma/sqrt(n);
    
    for (int i = 0; i < J; ++i ) {
        beta[i] = rnorm(vbar[i], sd);
    }
}
#endif

#if(0) /* function deleted */
void
updateBeta_KnownCertain(SEXP beta_R, SEXP prior, 
                        double *vbar, int n, double sigma)
{
    int J = LENGTH(beta_R);
    double *beta = REAL(beta_R);
    
    double *values = REAL(GET_SLOT(prior, values_sym));
    
    memcpy(values, beta, J*sizeof(double));
}
#endif

#if(0) /* function deleted */
void
updateBeta_KnownUncertain(SEXP beta_R, SEXP prior, 
                        double *vbar, int n, double sigma)
{
    int J = LENGTH(beta_R);
    double *beta = REAL(beta_R);
    
    double *sd_prior = REAL(GET_SLOT(prior, sd_sym));
    double *mean_prior = REAL(GET_SLOT(prior, mean_sym));
    
    double prec_data = n/(sigma*sigma);
    
    for (int j = 0; j < J; ++j ) {
        
        double this_sd_prior = sd_prior[j];
        
        if (this_sd_prior > 0) {
            
            double prec_prior = 1/(this_sd_prior*this_sd_prior);
            double var = 1/(prec_prior + prec_data);
            double sd = sqrt(var);
            double mean = var * ( prec_prior * mean_prior[j] 
                        + prec_data * vbar[j] );
            
            beta[j] = rnorm(mean, sd);
        }
        else {
            beta[j] = mean_prior[j];
        }
        
    }
}
#endif

#if(0) /* function deleted */
void
updateBeta_Poly(SEXP beta_R, SEXP prior_R,
                        double *vbar, int n, double sigma)
{
	SEXP components_R = GET_SLOT(prior_R, components_sym);
	int J = LENGTH(beta_R);
	double *beta = REAL(beta_R);
	
	double *v = REAL(GET_SLOT(prior_R, v_sym));
	
	double *beta_hat = (double *)R_alloc(J, sizeof(double));
    
    int forward = 1 /* true */;
	
	betaHatPoly_Internal(beta_hat, J, components_R, forward);
	
	double prec_data = n/(sigma*sigma);
	
	for (int j = 0; j < J; ++j) {
		double this_prec_prior = 1/v[j];
		double this_var = 1/(prec_data + this_prec_prior);
		double this_sd = sqrt(this_var);
		double this_mean = this_var*(prec_data*vbar[j] + 
									this_prec_prior * beta_hat[j]);
		beta[j] = rnorm(this_mean,this_sd);
	}
}
#endif

#if(0) /* function deleted */
void
updateBeta_AR1_Internal(SEXP beta_R, SEXP prior_R,
                        double *vbar, int n, double sigma)
{
	int J = LENGTH(beta_R);
	double *beta = REAL(beta_R);
	
    double *gammaNoInitial = REAL(GET_SLOT(prior_R, gammaNoInitial_sym));
	double *v = REAL(GET_SLOT(prior_R, v_sym));
	
	double prec_data = n/(sigma*sigma);
	
	for (int j = 0; j < J; ++j) {
		double this_prec_prior = 1/v[j];
		double this_var = 1/(prec_data + this_prec_prior);
		double this_sd = sqrt(this_var);
		double this_mean = this_var*(prec_data*vbar[j] + 
									this_prec_prior * gammaNoInitial[j]);
		beta[j] = rnorm(this_mean,this_sd);
	}
}
#endif

#if(0) /* function deleted */
void
updateBeta_AR10(SEXP beta_R, SEXP prior_R,
                        double *vbar, int n, double sigma)
{
	updateBeta_AR1_Internal(beta_R, prior_R,
                        vbar, n, sigma);
}
#endif

#if(0) /* function deleted */
void
updateBeta_AR11(SEXP beta_R, SEXP prior_R,
                        double *vbar, int n, double sigma)
{
	updateBeta_AR1_Internal(beta_R, prior_R,
                        vbar, n, sigma);
}
#endif


void updatePriorVarDLM_NormKnown(SEXP prior_R, SEXP var_R, 
                                    SEXP observed_R, SEXP expected_R,
                                    SEXP zeta_R);
void updatePriorVarDLM_NormUnknown(SEXP prior_R, SEXP var_R, 
                                    SEXP observed_R, SEXP expected_R,
                                    SEXP zeta_R);
void updatePriorVarDLM_RobustKnown(SEXP prior_R, SEXP var_R, 
                                    SEXP observed_R, SEXP expected_R,
                                    SEXP zeta_R);
void updatePriorVarDLM_RobustUnknown(SEXP prior_R, SEXP var_R, 
                                    SEXP observed_R, SEXP expected_R,
                                    SEXP zeta_R);
void updatePriorVarDLM_Zero(SEXP prior_R, SEXP var_R, 
                                    SEXP observed_R, SEXP expected_R,
                                    SEXP zeta_R);
void updatePriorVarDLM(SEXP prior_R, SEXP var_R, 
                                    SEXP observed_R, SEXP expected_R,
                                    SEXP zeta_R);

SEXP updateVarDLM_NormKnown(SEXP prior_R, 
                                SEXP observed_R, SEXP expected_R);
SEXP updateVarDLM_NormUnknown(SEXP prior_R, 
                                SEXP observed_R, SEXP expected_R);
SEXP updateVarDLM_RobustKnown(SEXP prior_R, 
                                SEXP observed_R, SEXP expected_R);
SEXP updateVarDLM_RobustUnknown(SEXP prior_R, 
                                SEXP observed_R, SEXP expected_R);
SEXP updateVarDLM_Zero(SEXP prior_R, 
                                SEXP observed_R, SEXP expected_R);
SEXP updateVarDLM(SEXP prior_R, 
                                SEXP observed_R, SEXP expected_R);
/* PriorsVarDLM updates */
/* Wrapper macro to use for the functions that update var poly priors in place.
 * The wrapper puts a _R suffix on end of function name,
 * and deals with RNGstate (relevant for prior update functions that
 * use prngs),
 * and ensures that the R version returns the updated prior as the SEXP */
#define UPDATEPRIORVARPOLY_WRAPPER_R(name)         \
    SEXP name##_R(SEXP prior_R, SEXP var_R, SEXP observed_R, SEXP expected_R, SEXP zeta_R) {    \
    SEXP ans_R;               \
    PROTECT(ans_R = duplicate(prior_R));    \
    GetRNGstate();              \
    name(ans_R, var_R, observed_R, expected_R, zeta_R);          \
    PutRNGstate();              \
    UNPROTECT(1);               \
    return ans_R;             \
    }

UPDATEPRIORVARPOLY_WRAPPER_R(updatePriorVarDLM_NormKnown);
UPDATEPRIORVARPOLY_WRAPPER_R(updatePriorVarDLM_NormUnknown);
UPDATEPRIORVARPOLY_WRAPPER_R(updatePriorVarDLM_RobustKnown);
UPDATEPRIORVARPOLY_WRAPPER_R(updatePriorVarDLM_RobustUnknown);
UPDATEPRIORVARPOLY_WRAPPER_R(updatePriorVarDLM_Zero);
UPDATEPRIORVARPOLY_WRAPPER_R(updatePriorVarDLM);
/* Wrapper macro to use for the functions that give var for poly priors.
 * The wrapper puts a _R suffix on end of function name,
 * and deals with RNGstate (relevant for prior update functions that
 * use prngs),
 * and ensures that the R version returns the var as the SEXP */
#define UPDATEVARPOLY_WRAPPER_R(name)         \
    SEXP name##_R(SEXP prior_R, SEXP observed_R, SEXP expected_R) {    \
    SEXP ans_R;               \
    GetRNGstate();              \
    PROTECT(ans_R = name(prior_R, observed_R, expected_R));          \
    PutRNGstate();              \
    UNPROTECT(1);               \
    return ans_R;             \
    }

UPDATEVARPOLY_WRAPPER_R(updateVarDLM_NormKnown);
UPDATEVARPOLY_WRAPPER_R(updateVarDLM_NormUnknown);
UPDATEVARPOLY_WRAPPER_R(updateVarDLM_RobustKnown);
UPDATEVARPOLY_WRAPPER_R(updateVarDLM_RobustUnknown);
UPDATEVARPOLY_WRAPPER_R(updateVarDLM_Zero);
UPDATEVARPOLY_WRAPPER_R(updateVarDLM);
  CALLDEF(updatePriorVarDLM_NormKnown_R, 5),
  CALLDEF(updatePriorVarDLM_NormUnknown_R, 5),
  CALLDEF(updatePriorVarDLM_RobustKnown_R, 5),
  CALLDEF(updatePriorVarDLM_RobustUnknown_R, 5),
  CALLDEF(updatePriorVarDLM_Zero_R, 5),
  CALLDEF(updatePriorVarDLM_R, 5),
  
  CALLDEF(updateVarDLM_NormKnown_R, 3),
  CALLDEF(updateVarDLM_NormUnknown_R, 3),
  CALLDEF(updateVarDLM_RobustKnown_R, 3),
  CALLDEF(updateVarDLM_RobustUnknown_R, 3),
  CALLDEF(updateVarDLM_Zero_R, 3),
  CALLDEF(updateVarDLM_R, 3),
/* ## updatePriorVarDLM ########################################## */

/* ## Update hyper-parameters for Poly priors ## */
    void updatePriorVarDLM_Internal(SEXP prior_R, double *var, 
                            int J, double *observed, double *expected,
                            double zeta);
                            
    void updatePriorVarDLM_NormKnown_Internal(SEXP prior_R, double *var, 
                            int J, double *observed, double *expected,
                            double zeta);
    
    void updatePriorVarDLM_NormUnknown_Internal(SEXP prior_R, double *var, 
                            int J, double *observed, double *expected,
                            double zeta);
    
    void updatePriorVarDLM_RobustKnown_Internal(SEXP prior_R, double *var, 
                            int J, double *observed, double *expected,
                            double zeta);
    
    void updatePriorVarDLM_RobustUnknown_Internal(SEXP prior_R, double *var, 
                            int J, double *observed, double *expected,
                            double zeta);
    
    void updatePriorVarDLM_Zero_Internal(SEXP prior_R, double *var, 
                            int J, double *observed, double *expected,
                            double zeta);
    
    void updateVarDLM_NormKnown_Internal(double *ans, int J, 
                        SEXP prior_R, double *observed, double *expected);
    
    void updateVarDLM_NormUnknown_Internal(double *ans, int J, 
                        SEXP prior_R, double *observed, double *expected);
                        
    void updateVarDLM_RobustKnown_Internal(double *ans, int J, 
                        SEXP prior_R, double *observed, double *expected);
    
    void updateVarDLM_RobustUnknown_Internal(double *ans, int J, 
                        SEXP prior_R, double *observed, double *expected);
    
    void updateVarDLM_Zero_Internal(double *ans, int J, 
                        SEXP prior_R, double *observed, double *expected);
    
    void updateVarDLM_Internal(double *ans, int J, 
                        SEXP prior_R, double *observed, double *expected);
    

void
updatePriorVarDLM(SEXP prior_R, SEXP var_R, 
                        SEXP observed_R, SEXP expected_R, SEXP zeta_R)
{
    int J = LENGTH(observed_R);
    double *var = REAL(var_R);
    double *observed = REAL(observed_R);
    double *expected = REAL(expected_R);
    double zeta = *REAL(zeta_R);
    
	updatePriorVarDLM_Internal(prior_R, var, J,
                            observed, expected, zeta);
}

void
updatePriorVarDLM_Internal(SEXP prior_R, double *var, 
                            int J, double *observed, double *expected,
                            double zeta)
{
    int iMethodPriorVarDLM = *(INTEGER(GET_SLOT(prior_R, 
                                            iMethodPriorVarDLM_sym)));
    
    switch(iMethodPriorVarDLM)
    {
        case 1: /*Normal Known */
            updatePriorVarDLM_NormKnown_Internal(prior_R, var, J,
                                        observed, expected, zeta);
            break;
        case 2: /*Normal Unknown */
            updatePriorVarDLM_NormUnknown_Internal(prior_R, var, J,
                                        observed, expected, zeta);
            break;
        case 3: /*Robust Known */
            updatePriorVarDLM_RobustKnown_Internal(prior_R, var, J,
                                        observed, expected, zeta);
            break;
        case 4: /*Robust Unknown */
            updatePriorVarDLM_RobustUnknown_Internal(prior_R, var, J,
                                        observed, expected, zeta);
            break;
        case 5: /*Zero Unknown */
            updatePriorVarDLM_Zero_Internal(prior_R, var, J,
                                        observed, expected, zeta);
            break;
        default:
            error("unknown iMethodPriorVarDLM: %d", iMethodPriorVarDLM);
            break;
    }
}

void
updatePriorVarDLM_NormKnown(SEXP prior_R, SEXP var_R, 
                            SEXP observed_R, SEXP expected_R, SEXP zeta_R)
{
    int J = LENGTH(observed_R);
    double *var = REAL(var_R);
    double *observed = REAL(observed_R);
    double *expected = REAL(expected_R);
    double zeta = *REAL(zeta_R);
    
	updatePriorVarDLM_NormKnown_Internal(prior_R, var, J,
                                observed, expected, zeta);
}

void
updatePriorVarDLM_NormKnown_Internal(SEXP prior_R, double *var, int J,
                                double *observed, double *expected,
                                double zeta)
{
    double tauUnscaled = *REAL(GET_SLOT(prior_R, tauUnscaled_sym));
    double tau = tauUnscaled/fabs(zeta);
    
    SET_SLOT(prior_R, tau_sym, ScalarReal(tau));
}

void
updatePriorVarDLM_NormUnknown(SEXP prior_R, SEXP var_R, 
                            SEXP observed_R, SEXP expected_R, 
                            SEXP zeta_R)
{
    int J = LENGTH(observed_R);
    double *var = REAL(var_R);
    double *observed = REAL(observed_R);
    double *expected = REAL(expected_R);
    double zeta = *REAL(zeta_R);
    
	updatePriorVarDLM_NormUnknown_Internal(prior_R, var, J,
                                observed, expected, zeta);
}

void
updatePriorVarDLM_NormUnknown_Internal(SEXP prior_R, double *var, int J,
                                double *observed, double *expected,
                                double zeta)
{
    double minTau = *REAL(GET_SLOT(prior_R, minTau_sym));
    double maxTau = *REAL(GET_SLOT(prior_R, maxTau_sym));

    int Jminus1 = J-1;
     
    double s_sq = 0.0;
    for (int j = 0; j < J; ++j) {
        double tmp = observed[j] - expected[j];
        s_sq += tmp*tmp;
    }
    s_sq /= Jminus1;
    
    double tau_sq = rinvchisq1(Jminus1, s_sq);
    double tau_prop = sqrt(tau_sq);
    double tau_prop_scaled = fabs(zeta) * tau_prop;

    if ( !(tau_prop_scaled < minTau) && !(tau_prop_scaled > maxTau) ) {
        SET_SLOT(prior_R, tau_sym, ScalarReal(tau_prop));
    }
}


void
updatePriorVarDLM_RobustKnown(SEXP prior_R, SEXP var_R, 
                                SEXP observed_R, SEXP expected_R, 
                                SEXP zeta_R)
{
    int J = LENGTH(observed_R);
    double *var = REAL(var_R);
    double *observed = REAL(observed_R);
    double *expected = REAL(expected_R);
    double zeta = *REAL(zeta_R);
    
	updatePriorVarDLM_RobustKnown_Internal(prior_R, var, J,
                                observed, expected, zeta);
}

void
updatePriorVarDLM_RobustKnown_Internal(SEXP prior_R, double *var, int J,
                                double *observed, double *expected,
                                double zeta)
{
    double tauUnscaled = *REAL(GET_SLOT(prior_R, tauUnscaled_sym));
    double tau = tauUnscaled/fabs(zeta);
    
    SET_SLOT(prior_R, tau_sym, ScalarReal(tau));
}

void
updatePriorVarDLM_RobustUnknown(SEXP prior_R, SEXP var_R, 
                                SEXP observed_R, SEXP expected_R, 
                                SEXP zeta_R)
{
    int J = LENGTH(observed_R);
    double *var = REAL(var_R);
    double *observed = REAL(observed_R);
    double *expected = REAL(expected_R);
    double zeta = *REAL(zeta_R);
    
	updatePriorVarDLM_RobustUnknown_Internal(prior_R, var, J,
                                observed, expected, zeta);
}


void
updatePriorVarDLM_RobustUnknown_Internal(SEXP prior_R, double *var, int J,
                                double *observed, double *expected,
                                double zeta)
{
    double minTau = *REAL(GET_SLOT(prior_R, minTau_sym));
    double maxTau = *REAL(GET_SLOT(prior_R, maxTau_sym));

    double nu = *REAL(GET_SLOT(prior_R, nu_sym));       
    
    double shapeParam = (J * nu + 1.0)/2;
    double sumVarRecip = 0.0;
    
    for (int j = 0; j < J; ++j) {
        sumVarRecip += 1.0/(var[j]);
    }
    
    double rateParamMult = (nu/2.0)*sumVarRecip;
    
    double tau_sq = rgamma(shapeParam, 
                                1/rateParamMult);
    double tau_prop = sqrt(tau_sq);
    double tau_prop_scaled = fabs(zeta) * tau_prop;

    if ( !(tau_prop_scaled < minTau) && !(tau_prop_scaled > maxTau) ) {
        SET_SLOT(prior_R, tau_sym, ScalarReal(tau_prop));
    }
}

void
updatePriorVarDLM_Zero(SEXP prior_R, SEXP var_R, 
                            SEXP observed_R, SEXP expected_R, 
                            SEXP zeta_R)
{
    int J = LENGTH(observed_R);
    double *var = REAL(var_R);
    double *observed = REAL(observed_R);
    double *expected = REAL(expected_R);
    double zeta = *REAL(zeta_R);
    
	updatePriorVarDLM_Zero_Internal(prior_R, var, J,
                                observed, expected, zeta);
}

void
updatePriorVarDLM_Zero_Internal(SEXP prior_R, double *var, int J,
                                double *observed, double *expected,
                                double zeta)
{
	/* null op */
}


SEXP
updateVarDLM(SEXP prior_R, SEXP observed_R, SEXP expected_R)
{
    int J = LENGTH(observed_R);
    double *observed = REAL(observed_R);
    double *expected = REAL(expected_R);
    
    SEXP ans_R;
    PROTECT(ans_R = allocVector(REALSXP, J));
    double *ans = REAL(ans_R);
    
    updateVarDLM_Internal(ans, J, prior_R, observed, expected);
    
    UNPROTECT(1);
    return ans_R;
}

void
updateVarDLM_Internal(double *ans, int J, 
                        SEXP prior_R, double *observed, double *expected)
{
    int iMethodPriorVarDLM = *(INTEGER(GET_SLOT(prior_R, 
                                            iMethodPriorVarDLM_sym)));
    
    switch(iMethodPriorVarDLM)
    {
        case 1: /*Normal Known */
            updateVarDLM_NormKnown_Internal(ans, J,
                                    prior_R, observed, expected);
            break;
        case 2: /*Normal Unknown */
            updateVarDLM_NormUnknown_Internal(ans, J,
                                    prior_R, observed, expected);
            break;
        case 3: /*Robust Known */
            updateVarDLM_RobustKnown_Internal(ans, J,
                                    prior_R, observed, expected);
            break;
        case 4: /*Robust Unknown */
            updateVarDLM_RobustUnknown_Internal(ans, J,
                                    prior_R, observed, expected);
            break;
        case 5: /*Zero Unknown */
            updateVarDLM_Zero_Internal(ans, J,
                                    prior_R, observed, expected);
            break;
        default:
            error("unknown iMethodPriorVarDLM: %d", iMethodPriorVarDLM);
            break;
    }
}


SEXP
updateVarDLM_NormKnown(SEXP prior_R, SEXP observed_R, SEXP expected_R)
{
    int J = LENGTH(observed_R);
    double *observed = REAL(observed_R);
    double *expected = REAL(expected_R);
    
    SEXP ans_R;
    PROTECT(ans_R = allocVector(REALSXP, J));
    double *ans = REAL(ans_R);
    
    updateVarDLM_NormKnown_Internal(ans, J,
                                    prior_R, observed, expected);
    
    UNPROTECT(1);
    return ans_R;
}

/* ans should have at least J==LENGTH(observed_R) elements */
void
updateVarDLM_NormKnown_Internal(double *ans, int J, 
                        SEXP prior_R, double *observed, double *expected)
{
    double tau = *REAL(GET_SLOT(prior_R, tau_sym));
    double tau_sq = tau * tau;
    for(int j = 0; j < J; ++j) {
        ans[j] = tau_sq;
    }
    
}

SEXP
updateVarDLM_NormUnknown(SEXP prior_R, SEXP observed_R, SEXP expected_R)
{
    int J = LENGTH(observed_R);
    double *observed = REAL(observed_R);
    double *expected = REAL(expected_R);
    
    SEXP ans_R;
    PROTECT(ans_R = allocVector(REALSXP, J));
    double *ans = REAL(ans_R);
    
    updateVarDLM_NormUnknown_Internal(ans, J,
                                    prior_R, observed, expected);
    
    UNPROTECT(1);
    return ans_R;
}

/* ans should have at least J==LENGTH(observed_R) elements */
void
updateVarDLM_NormUnknown_Internal(double *ans, int J, 
                        SEXP prior_R, double *observed, double *expected)
{
    double tau = *REAL(GET_SLOT(prior_R, tau_sym));
    double tau_sq = tau * tau;
    for(int j = 0; j < J; ++j) {
        ans[j] = tau_sq;
    }
    
}

SEXP
updateVarDLM_RobustKnown(SEXP prior_R, SEXP observed_R, SEXP expected_R)
{
    int J = LENGTH(observed_R);
    double *observed = REAL(observed_R);
    double *expected = REAL(expected_R);
    
    SEXP ans_R;
    PROTECT(ans_R = allocVector(REALSXP, J));
    double *ans = REAL(ans_R);
    
    updateVarDLM_RobustKnown_Internal(ans, J,
                                    prior_R, observed, expected);
    
    UNPROTECT(1);
    return ans_R;
}

/* ans should have at least J==LENGTH(observed_R) elements */
void
updateVarDLM_RobustKnown_Internal(double *ans, int J, 
                        SEXP prior_R, double *observed, double *expected)
{
    
    double tau = *REAL(GET_SLOT(prior_R, tau_sym));
    double nu = *REAL(GET_SLOT(prior_R, nu_sym));
    
    double nuTauSq = nu*tau*tau;
    double nuPlusOne = nu+1;
    
    for (int j = 0; j < J; ++j) {
        double tmp = observed[j] - expected[j];
        double s_sq = (nuTauSq + tmp*tmp)/nuPlusOne;
        ans[j] = rinvchisq1(nuPlusOne, s_sq);
    }
    
}

SEXP
updateVarDLM_RobustUnknown(SEXP prior_R, SEXP observed_R, SEXP expected_R)
{
    int J = LENGTH(observed_R);
    double *observed = REAL(observed_R);
    double *expected = REAL(expected_R);
    
    SEXP ans_R;
    PROTECT(ans_R = allocVector(REALSXP, J));
    double *ans = REAL(ans_R);
    
    updateVarDLM_RobustUnknown_Internal(ans, J,
                                    prior_R, observed, expected);
    
    UNPROTECT(1);
    return ans_R;
}

/* ans should have at least J==LENGTH(observed_R) elements */
void
updateVarDLM_RobustUnknown_Internal(double *ans, int J, 
                        SEXP prior_R, double *observed, double *expected)
{
    
    double tau = *REAL(GET_SLOT(prior_R, tau_sym));
    double nu = *REAL(GET_SLOT(prior_R, nu_sym));
    
    double nuTauSq = nu*tau*tau;
    double nuPlusOne = nu+1;
    
    for (int j = 0; j < J; ++j) {
        double tmp = observed[j] - expected[j];
        double s_sq = (nuTauSq + tmp*tmp)/nuPlusOne;
        ans[j] = rinvchisq1(nuPlusOne, s_sq);
    }
    
}

SEXP
updateVarDLM_Zero(SEXP prior_R, SEXP observed_R, SEXP expected_R)
{
    int J = LENGTH(observed_R);
    double *observed = REAL(observed_R);
    double *expected = REAL(expected_R);
    
    SEXP ans_R;
    PROTECT(ans_R = allocVector(REALSXP, J));
    double *ans = REAL(ans_R);
    
    updateVarDLM_Zero_Internal(ans, J,
                                    prior_R, observed, expected);
    
    UNPROTECT(1);
    return ans_R;
}

/* ans should have at least J==LENGTH(observed_R) elements */
void
updateVarDLM_Zero_Internal(double *ans, int J, 
                        SEXP prior_R, double *observed, double *expected)
{
    
    memset(ans, 0, J*sizeof(double));
    
}

/* update model betas */
void updatePriorsBetas(SEXP object);
void updateBetas(SEXP object);
void updateZetas(SEXP object);
/* wrap update priors betas */
UPDATEOBJECT_WRAPPER_R(updatePriorsBetas);
/* wrap update betas and zetas*/
UPDATEOBJECT_WRAPPER_R(updateBetas);

UPDATEOBJECT_WRAPPER_R(updateZetas);
  CALLDEF(updatePriorsBetas_R, 1),
  CALLDEF(updateBetas_R, 1),
  CALLDEF(updateZetas_R, 1),
#if(0) /* function deleted */
/* only here for testing updateBetas:
 * the uber update model function effectively duplicates this */
void
updateBetas(SEXP object)
{
        int i_method_model = *(INTEGER(GET_SLOT(object, iMethodModel_sym)));

        switch(i_method_model)
        {
            case 4: case 5: /*Normal */
                updateBetas_General(object, identity);
                break;
            case 6: case 10: case 20: case 21:/* Poisson */
                updateBetas_General(object, log);
                break;
            case 9: case 18: case 19:/* Binomial */
                updateBetas_General(object, logit);
                break;
            default:
                error("unknown iMethodModel: %d", i_method_model);
                break;
        }
}
#endif

#if(0) /* function deleted */
/* the the call to updateBeta here will have to be updated in some way
 * JAH 2 April 2016*/
void
updateBetas_General(SEXP object, double (*g)(double))
{
    SEXP priors_R = GET_SLOT(object, priorsBetas_sym);
    int n_betas =  LENGTH(priors_R);

    double *zetas = REAL(GET_SLOT(object, zetas_sym));

    double sigma = *REAL(GET_SLOT(object, sigma_sym));

    SEXP theta_R = GET_SLOT(object, theta_sym);
    int n_theta = LENGTH(theta_R);
    double *theta = REAL(theta_R);

    SEXP betas_R = GET_SLOT(object, betas_sym);
    int len_beta_array[n_betas];
    int max_len_beta = 0;

    for (int iBeta = 0; iBeta < n_betas; ++iBeta) {
        
        int len_beta = LENGTH(VECTOR_ELT(betas_R, iBeta));
        if (len_beta > max_len_beta) max_len_beta = len_beta;
        len_beta_array[iBeta] = len_beta;
    }
    

    /* one malloc */
    double * vbar = (double *)R_alloc(max_len_beta, sizeof(double));

    SEXP iteratorBetas_R = GET_SLOT(object, iteratorBetas_sym);

    for (int iBeta = 0; iBeta < n_betas; ++iBeta) {

        int len_beta = len_beta_array[iBeta];

        double zeta = zetas[iBeta];

        getVBar(vbar, len_beta,
                betas_R, iteratorBetas_R,
                zetas,
                theta, n_theta, n_betas,
                iBeta, g);

        int n = n_theta/len_beta; /* integer division */

        /* scale by zeta */
        for (int b = 0; b < len_beta; ++b) {
            vbar[b] /= zeta;
        }
        
        double sigma_scaled = sigma/ fabs(zeta);

        #ifdef DEBUGGING_EXTRA
            PrintValue(ScalarInteger(100));
            PrintValue(ScalarInteger(iBeta));
        #endif

        
        /* just adapted code here to make compatible
         * with new version of updateBeta, but presumably
         * there are other changes to updateBetas to come
         * JAH 2 April 2016*/
         updateBeta_Internal(REAL(VECTOR_ELT(betas_R, iBeta)), len_beta, 
                                VECTOR_ELT(priors_R, iBeta), 
                                vbar, n, sigma_scaled);
        
    }
}
#endif

#if(0) /* function deleted */
void
updatePriorsBetas(SEXP object)
{
    SEXP betas_R = GET_SLOT(object, betas_sym);
    int n_beta =  LENGTH(betas_R);

    SEXP priors_R = GET_SLOT(object, priorsBetas_sym);
    
    double *zetas = REAL(GET_SLOT(object, zetas_sym));

    for (int b = 0; b < n_beta; ++b) {
        updatePrior( VECTOR_ELT(priors_R, b), VECTOR_ELT(betas_R, b),
                zetas[b] );
    }
}
#endif

/* values used for limits on allowable proposals for updateZetas */
//#define ZETA_PROP_UPPER_LIMIT 2.0
//#define ZETA_PROP_LOWER_LIMIT 0.5
#if(0) /* function deleted */
/* only here for testing updateZetas */
void
updateZetas(SEXP object_R)
{
        int i_method_model = *(INTEGER(GET_SLOT(object_R, iMethodModel_sym)));

        switch(i_method_model)
        {
            case 4: case 5: /*Normal */
                updateZetas_General(object_R, identity);
                break;
            case 6: case 10: case 20: case 21:/* Poisson */
                updateZetas_General(object_R, log);
                break;
            case 9: case 18: case 19:/* Binomial */
                updateZetas_General(object_R, logit);
                break;
            default:
                error("unknown iMethodModel: %d", i_method_model);
                break;
        }
}

void
updateZetas_General(SEXP object_R, double (*g)(double))
{
    SEXP betas_R = GET_SLOT(object_R, betas_sym);
    int n_betas =  LENGTH(betas_R);

    double *zetas = REAL(GET_SLOT(object_R, zetas_sym));
    double sigma = *REAL(GET_SLOT(object_R, sigma_sym));
    SEXP theta_R = GET_SLOT(object_R, theta_sym);
    int n_theta = LENGTH(GET_SLOT(object_R, theta_sym));
    double *theta = REAL(theta_R);

    int len_beta_array[n_betas];
    int max_len_beta = 0;

    for (int iBeta = 0; iBeta < n_betas; ++iBeta) {
        
        int len_beta = LENGTH(VECTOR_ELT(betas_R, iBeta));
        if (len_beta > max_len_beta) max_len_beta = len_beta;
        len_beta_array[iBeta] = len_beta;
    }
    
    /* one malloc */
    double * vbar = (double *)R_alloc(max_len_beta, sizeof(double));

    SEXP iteratorBetas_R = GET_SLOT(object_R, iteratorBetas_sym);

    for (int iBeta = 0; iBeta < n_betas; ++iBeta) {

        int len_beta = len_beta_array[iBeta];

        getVBar(vbar, len_beta,
                betas_R, iteratorBetas_R,
                zetas,
                theta, n_theta, n_betas,
                iBeta, g);

        int n = n_theta/len_beta; /* integer division */

        /* sums */
        double *beta = REAL(VECTOR_ELT(betas_R, iBeta));
        double sumBeta = 0.0;
        double sumVBar = 0.0;
        for (int b = 0; b < len_beta; ++b) {
            sumBeta += beta[b];
            sumVBar += vbar[b];
        }

        double mean = sumVBar/sumBeta;
        double sd = sqrt(n_theta) * sigma / (n * fabs(sumBeta));

        double zeta_prop = rnorm(mean, sd);
        
        if ((zeta_prop > ZETA_PROP_LOWER_LIMIT) 
                    && (zeta_prop < ZETA_PROP_UPPER_LIMIT)) {
            zetas[iBeta] = zeta_prop;
        }
	
    }
}
#endif
#if(0)
    void updateBetas_General(SEXP object, double (*g)(double));
    
    
    void updateZetas_General(SEXP object, double (*g)(double));
    #endif 

void FFBS(SEXP object_R, SEXP y_R, SEXP v_R, int forward);
/* Wrapper macro to use for the filter functions that returns an
 * updated object.
 * No arguments to functions should be modified,
 * other than the duplicate of object, which is changed in place.
 * The wrapper puts a _R suffix on end of function name,
 * and ensures that the R version returns the updated object. */
#define FILTER_WRAPPER_R(name)      \
    SEXP name##_R(SEXP object_R, SEXP y_R, SEXP v_R, SEXP forward_R) {       \
    int forward = *INTEGER(forward_R);         \
    SEXP ans_R;         \
    PROTECT(ans_R = duplicate(object_R));         \
    GetRNGstate();         \
    name(ans_R, y_R, v_R, forward);       \
    PutRNGstate();         \
    UNPROTECT(1);       \
    return ans_R;       \
    }
FILTER_WRAPPER_R(FFBS);
CALLDEF(FFBS_R,4),
void FFBS_Internal(SEXP object_R, double *y,  double *v, int forward);
void
FFBS(SEXP object_R, SEXP y_R, SEXP v_R, int forward)
{
	double *y = REAL(y_R);
    double *v = REAL(v_R);
    
	FFBS_Internal(object_R, y, v, forward);
}

void
FFBS_Internal(SEXP object_R, double *y,  double *v, int forward)
{
	forwardFilter_Internal(object_R, y, v, forward);
	/* function deleted */
	#if(0)
	updateFinalGamma(object_R, forward);
	#endif
	backwardSample(object_R, forward);
}

void backwardSample(SEXP object_R, int forward);
/* wrap backwardSample */
/* Wrapper macro to use for the filter functions that returns an
 * updated object.
 * No arguments to functions should be modified,
 * other than the duplicate of object, which is changed in place.
 * The wrapper puts a _R suffix on end of function name,
 * and ensures that the R version returns the updated object. */
#define UPDATEOBJECTFILTER_WRAPPER_R(name)      \
    SEXP name##_R(SEXP object_R, SEXP forward_R) {       \
    int forward = *INTEGER(forward_R);         \
    SEXP ans_R;         \
    PROTECT(ans_R = duplicate(object_R));         \
    GetRNGstate();         \
    name(ans_R, forward);       \
    PutRNGstate();         \
    UNPROTECT(1);       \
    return ans_R;       \
    }
UPDATEOBJECTFILTER_WRAPPER_R(backwardSample);
CALLDEF(backwardSample_R, 2),

void
backwardSample(SEXP object_R, int forward)
{
    int J = *INTEGER(GET_SLOT(object_R, J_sym));
    int q = *INTEGER(GET_SLOT(object_R, q_sym));

    #ifdef DEBUGGING
        PrintValue(mkString("forward"));
        PrintValue(ScalarInteger(forward));
        PrintValue(mkString("J"));
        PrintValue(ScalarInteger(J));
    #endif
    

    /* gamma a list of vector of doubles, len J+1, each vector length q */
    SEXP gamma_R = GET_SLOT(object_R, gamma_sym); 

    /* G a matrix of doubles, size q x q */
    double *G = REAL(GET_SLOT(object_R, G_sym));

    /* W a list of matrices of doubles, len J, each matrix q x q */
    SEXP W_R = GET_SLOT(object_R, W_sym); 

    /* m a list of vector of doubles, len J+1, each vector length q */
    SEXP m_R = GET_SLOT(object_R, m_sym); 
    /* C a list of symmetric matrices of doubles, len J+1, each matrix size q x q */
    SEXP C_R = GET_SLOT(object_R, CC_sym); 
    
    /* UC a list of matrices of doubles, len J+1, each matrix q x q */
    SEXP UC_R = GET_SLOT(object_R, UC_sym); 
    
    /* DCInv a list of vector of doubles, len J+1, each vector length q */
    SEXP DCInv_R = GET_SLOT(object_R, DCInv_sym); 
    
    /* a a list of vectors of doubles, len J, each vector length q */
    SEXP a_R = GET_SLOT(object_R, a_sym); 

    /* UR a list of matrices of doubles, len J, each matrix q x q */
    SEXP UR_R = GET_SLOT(object_R, UR_sym); 
    
    /* DRInv a list of vector of doubles, len J, each vector length q */
    SEXP DRInv_R = GET_SLOT(object_R, DRInv_sym); 
    
    /* space for 2 vectors of length q 
     * and 4 matrices q  x q 
     * and svd work  q*(5q + 7)
     * = total  9*q + 9*q*q*/
    int nWorkspace = 9*q*(1 + q);
    double *workspace = (double *)R_alloc(nWorkspace, sizeof(double));
    
    /* divvie up the workspace */
    double *sqrtWInv = workspace; /* q */
    double *DCs = workspace + q; /* q */
    double *work1 = workspace + 2*q; /* q x q */
    double *work2 = workspace + 2*q + q*q; /* q x q */
    double *work3 = workspace + 2*q + 2* q*q; /* 2q x q */
    double *work_svd = workspace + 2*q + 4* q*q; /* q*(5q + 7) */
    
    /* allocate 8q of int space for iwork in svd */
    int *iwork_svd = (int *)R_alloc(8*q, sizeof(int));

    double eps = DOUBLE_EPS;
    double epsInv = 1 / eps;

    /* stuff needed for fortran routines */
    int info = 0;
    int lwork = q*(5*q+7); /* q*(5q + 7) */
    
    char jobz = 'O';
    char transN = 'N';
    char transT = 'T';
    
    int dim_m = 2*q;
    int dim_n = q;
    
    double dummyU = 0; /* U not used */
    int ldu = 1; 
    
    double alpha_blas_one = 1.0;
    double beta_blas_zero = 0.0;
    double beta_blas_one = 1.0;
    
    int inc_blas = 1;
    
    for (int j = J-1; j >= 0; --j) {
        
        int j0 = j + 1;
        int j1 = j;
        int j2 = j;
        
        if (!forward) {
            j0 = J - 1 - j; 
            j1 = J - 1 - j;
            j2 = J - j;
        }

        #ifdef DEBUGGING
            PrintValue(mkString("j"));
            PrintValue(ScalarInteger(j));
            PrintValue(ScalarInteger(j+1));
            PrintValue(mkString("j0"));
            PrintValue(ScalarInteger(j0));
            PrintValue(ScalarInteger(j0+1));
            PrintValue(mkString("j1"));
            PrintValue(ScalarInteger(j1));
            PrintValue(ScalarInteger(j1+1));
            PrintValue(mkString("j2"));
            PrintValue(ScalarInteger(j2));
            PrintValue(ScalarInteger(j2+1));
             
        #endif
        
        double *thisUR = REAL(VECTOR_ELT(UR_R, j1));
        double *thisDRInv = REAL(VECTOR_ELT(DRInv_R, j1));
        double *thisC = REAL(VECTOR_ELT(C_R, j2));
        double *thisW = REAL(VECTOR_ELT(W_R, j1));
        double *thisUC = REAL(VECTOR_ELT(UC_R, j2));
        double *thisDCInv = REAL(VECTOR_ELT(DCInv_R, j2));
        
        #ifdef DEBUGGING
            PrintValue(mkString("thisUR"));
            PrintValue(VECTOR_ELT(UR_R, j1));
            PrintValue(mkString("thisDRInv"));
            PrintValue(VECTOR_ELT(DRInv_R, j1));
            PrintValue(mkString("thisC"));
            PrintValue(VECTOR_ELT(C_R, j2));
            PrintValue(mkString("thisW"));
            PrintValue(VECTOR_ELT(W_R, j1));
            PrintValue(mkString("thisUC"));
            PrintValue(VECTOR_ELT(UC_R, j2));
            PrintValue(mkString("thisDCInv"));
            PrintValue(VECTOR_ELT(DCInv_R, j2));
           
        #endif

/*      R.inv <- UR[[j1]] %*% diag(DR.inv[[j1]]^2) %*% t(UR[[j1]])
        B.j <- C[[j2]] %*% t(G) %*% R.inv
*/
        /* R.inv into work 1 */
        for (int rowi = 0; rowi < q; ++rowi) {
         
            for (int colj = rowi; colj < q; ++colj) {
                
                double tmp = 0;
                
                for (int iq = 0; iq < q; ++iq) {
                    double drinv_qi = thisDRInv[iq];    
                    tmp += drinv_qi * drinv_qi * 
                        thisUR[ q * iq + rowi] * thisUR[ q * iq + colj];
                }
                work1[ q * colj + rowi ] = tmp;
                
                if (colj > rowi) {
                    work1[ q * rowi + colj ] = tmp;
                }
            }
            
            /* might as well do W's while we are looping 0 to q-1 */
            double thisWi = thisW[rowi*q + rowi];
            sqrtWInv[rowi] = (thisWi > eps ? 1/sqrt(thisWi) : epsInv);
        }
        /* R.inv should be in work1 */
        
        #ifdef DEBUGGING
            PrintValue(mkString("R.inv"));
            printDblArray(work1, q*q);
           
        #endif
        
        /* B.j <- C[[j2]] %*% t(G) %*% R.inv */
        F77_CALL(dgemm)(&transT, &transN, &q, &q, &q,
                &alpha_blas_one, G, &q, work1, &q,
                &beta_blas_zero, work2, &q);
        /* after call, work2 contains t(G)  * work1 = t(G) * invR*/
        
        F77_CALL(dgemm)(&transN, &transN, &q, &q, &q,
                        &alpha_blas_one, thisC, &q, work2, &q,
                        &beta_blas_zero, work1, &q);
        /* after call, work1 contains B_j = thisC*t(G)*inv(this_R) */
        
        #ifdef DEBUGGING
            PrintValue(mkString("B.j"));
            printDblArray(work1, q*q);
           
        #endif

        /* did sqrt.W.inv in the rowi loop above */
        
        #ifdef DEBUGGING
            PrintValue(mkString("sqrt.W.inv"));
            printDblArray(sqrtWInv, q);
           
        #endif
        
        
        /*M.Cs <- rbind(diag(sqrt.W.inv) %*% G,
                          diag(DC.inv[[j2]]) %*% t(UC[[j2]])) */
        for (int rowi = 0; rowi < q; ++rowi) {
            
            double w = sqrtWInv[rowi];
            double d = thisDCInv[rowi];
         
            for (int colj = 0; colj < q; ++colj) {
            
                /* use work 3 to create a 2q x q matrix*/
                work3 [ 2*q*colj + rowi ] 
                            = w * G[q * colj + rowi];
                
                work3 [ 2*q*colj + rowi + q ] 
                            = d * thisUC[q * rowi + colj];
                 
            }
        }
        
        #ifdef DEBUGGING
            PrintValue(mkString("M.Cs"));
            printDblArray(work3, 2*q*q);
           
        #endif
        
        /* M.Cs (A for dgesdd) in work 3 (2q x q) */
        /* svd.Cs <- svd(M.Cs, nu = 0)
         * provide work2 for VT */
        F77_CALL(dgesdd)(&jobz, &dim_m, &dim_n, work3,
                        &dim_m, DCs, &dummyU, &ldu, /* U not used */
                        work2, &dim_n, /* work2 for VT */
                        work_svd, &lwork,
                        iwork_svd, &info);
        if (info) error("error in dgesdd in backwardSample: %d", info);                  
                          
        double *this_m = REAL(VECTOR_ELT(m_R, j2));
        double *this_gamma = REAL(VECTOR_ELT(gamma_R, j0));
        double *this_a = REAL(VECTOR_ELT(a_R, j1));
        
        /* use work3 for temporary storage of this_m->ms and this_gamma */
        double *ms = work3;
        double *tmp_gamma_minus_a = work3 + q;
        memcpy(ms, this_m, q*sizeof(double));
        memcpy(tmp_gamma_minus_a, this_gamma, q*sizeof(double));
        
        /* use loop to do DCs and gamma[[j0]] - a[[j1]]) 
         * and z - put into what was sqrtWInv */
        
        double *z = sqrtWInv; 
        
        for (int i = 0; i < q; ++i) {
            
            double tmp = 1/DCs[i];
            DCs[i] = ( R_finite( tmp ) ? tmp : 0.0 );
            
            tmp_gamma_minus_a[i] -= this_a[i];
            
            z[i] = rnorm(0, 1); 
        }
        
        #ifdef DEBUGGING
            PrintValue(mkString("this_m"));
            PrintValue(VECTOR_ELT(m_R, j2));
            PrintValue(mkString("this_gamma"));
            PrintValue(VECTOR_ELT(gamma_R, j0));
            PrintValue(mkString("this_a"));
            PrintValue(VECTOR_ELT(a_R, j1));
            PrintValue(mkString("DCs"));
            printDblArray(DCs, q);
            PrintValue(mkString("USs transposed"));
            printDblArray(work2, q*q);
           
        #endif
        
        /*ms <- m[[j2]] + drop(B.j %*% (gamma[[j0]] - a[[j1]])) */
        /* work1 contains B_j */
        /* general matrix vector multiplication */
        F77_CALL(dgemv)(&transN, &q, &q, &alpha_blas_one, work1, 
                    &q, tmp_gamma_minus_a, &inc_blas, &beta_blas_one,
                    ms, &inc_blas);
        /* after call, ms contains ms <- m[[j2]] + drop(B.j %*% (gamma[[j0]] - a[[j1]])) */
        
        /*    sqrt.Cs <- UCs %*% diag(DCs) 
         * z <- rnorm(n = q)*/
        /* UCs is in work2 but as VT, not V 
         * put sqrt.Cs into work1*/
        
        for (int colj = 0; colj < q; ++colj) {        
            
            double d = DCs[colj];
            
            for (int rowi = 0; rowi < q; ++rowi) {
            
                work1[colj*q + rowi] = d * work2[rowi*q + colj];
            }
        }

        #ifdef DEBUGGING
            PrintValue(mkString("ms"));
            printDblArray(ms, q);
            PrintValue(mkString("z"));
            printDblArray(z, q);
            PrintValue(mkString("sqrt.Cs"));
            printDblArray(work1, q*q);
            
        #endif

        /*  gamma[[j2]] <- ms + drop(sqrt.Cs %*% z)*/
        double *new_gamma = REAL(VECTOR_ELT(gamma_R, j2));
        
        /* ms + sqrt.Cs %*% z */
        F77_CALL(dgemv)(&transN, &q, &q, &alpha_blas_one, work1, /* sqrt.Cs is in work1 */
                    &q, z, &inc_blas, &beta_blas_one,
                    ms, &inc_blas);
        /* after call, ms contains ms + drop(sqrt.Cs %*% z) */
        
        /* put ms in the new gamma vector */
        memcpy(new_gamma, ms, q*sizeof(double));

        #ifdef DEBUGGING
            PrintValue(mkString("new gamma"));
            PrintValue(VECTOR_ELT(gamma_R, j2));
            PrintValue(mkString("whole gamma"));
            PrintValue(gamma_R);
        #endif
        
    } /* end j loop */
}

SEXP betaHatComponent(SEXP component_R, int forward);
SEXP betaHatPoly(SEXP components_R, int forward);
void betaHatComponent_Internal(double *ans, int J, SEXP component_R,
                                        int forward);
void betaHatPoly_Internal(double *ans, int J, SEXP components_R,
							int forward);
/* one-off wrapper for betaHatComponent */
SEXP
betaHatComponent_R(SEXP component_R, SEXP forward_R)
{
    int forward = *INTEGER(forward_R);
    SEXP ans_R;     
        
    PROTECT(ans_R = betaHatComponent(component_R, forward));
    
    UNPROTECT(1);
    return ans_R;
}

/* one-off wrapper for betaHatPoly */
SEXP
betaHatPoly_R(SEXP components_R, SEXP forward_R)
{
    int forward = *INTEGER(forward_R);
    SEXP ans_R;     
        
    PROTECT(ans_R = betaHatPoly(components_R, forward));
    
    UNPROTECT(1);
    return ans_R;
}


CALLDEF(betaHatComponent_R, 2),
CALLDEF(betaHatPoly_R, 2),
SEXP
betaHatComponent(SEXP component_R, int forward)
{
    /* J integer */
    int J = *(INTEGER(GET_SLOT(component_R, J_sym)));
    SEXP ans_R;
    PROTECT(ans_R = allocVector(REALSXP, J));
    double *ans = REAL(ans_R);
    
    betaHatComponent_Internal(ans, J, component_R, forward);
    
    UNPROTECT(1);
    return ans_R;
}


/*        J <- component@J
        F <- component@F         
        gamma <- component@gamma
        ans <- numeric(J)
        for (j in seq_len(J)) {
            ## next 2 lines have changed
            jg <- if (forward) j + 1L else j
            ans[j] <- sum(F[[j]] * gamma[[jg]])
        }
        ans
    }
}
*/

/* ans must be array (at least) J long */
void
betaHatComponent_Internal(double *ans, int J, SEXP component_R, int forward)
{
    /* J integer, F a list of length J of doubles length q
    gamma a list of length J+1 of doubles length q */
    int q = *(INTEGER(GET_SLOT(component_R, q_sym)));
    SEXP F_R = GET_SLOT(component_R, F_sym);
    SEXP gamma_R = GET_SLOT(component_R, gamma_sym);
    
    int inc_blas = 1;
    
    for (int j = 0; j < J; ++j) {
        
        int jg = (forward ? j+1 : j);
        ans[j] = F77_CALL(ddot)(&q, REAL(VECTOR_ELT(F_R, j)),
                &inc_blas, REAL(VECTOR_ELT(gamma_R, jg)), &inc_blas);   
        
    }
}

SEXP
betaHatPoly(SEXP components_R, int forward)
{
    /* get J from first component */
    int J = *INTEGER(GET_SLOT(VECTOR_ELT(components_R, 0), J_sym));
    
    SEXP ans_R;
    PROTECT(ans_R = allocVector(REALSXP, J));
    double *ans = REAL(ans_R);
    
    betaHatPoly_Internal(ans, J, components_R, forward);
    
    UNPROTECT(1);
    return ans_R;

}


void
betaHatPoly_Internal(double *ans, int J, SEXP components_R, int forward)
{
    int n = LENGTH(components_R);
    
    SEXP first_component_R = VECTOR_ELT(components_R, 0);
    
    /* get ans for first component */
    
    betaHatComponent_Internal(ans, J, first_component_R, forward);
    
    double *tmp = (double *)R_alloc(J, sizeof(double));
    
    /* needed by daxpy, blas vector add routine */
    int inc_blas = 1;
    double alpha_blas = 1.0;
    
    /* add on for rest of the elements */
    for (int i = 1; i < n; ++i) {
        
        SEXP component_R = VECTOR_ELT(components_R, i);
        betaHatComponent_Internal(tmp, J, component_R, forward);
        F77_CALL(daxpy)(&J, &alpha_blas,
            tmp, &inc_blas, ans, &inc_blas);
        /* after call, ans = tmp + ans */
    }
}

SEXP betaTilde(SEXP beta_R, SEXP components_R, SEXP i_R, int forward);
/* one-off wrapper for betaTilde */
SEXP
betaTilde_R(SEXP beta_R, SEXP components_R, SEXP i_R, SEXP forward_R)
{
    int forward = *INTEGER(forward_R);
    SEXP ans_R;     
        
    PROTECT(ans_R = betaTilde(beta_R, components_R, i_R, forward));
    
    UNPROTECT(1);
    return ans_R;
}
CALLDEF(betaTilde_R, 4),
void betaTilde_Internal(double *betaToTilde, int J, SEXP components_R,
							int i, int forward);
SEXP
betaTilde(SEXP beta_R, SEXP components_R, SEXP i_R, int forward)
{
    int i = *INTEGER(i_R) - 1;
    
    int J = length(beta_R);
    
    SEXP betaToTilde_R;
    PROTECT(betaToTilde_R = duplicate(beta_R));
    double *betaToTilde = REAL(betaToTilde_R);
    
    betaTilde_Internal(betaToTilde, J, components_R, i, forward);
    
    UNPROTECT(1);
    return betaToTilde_R;
}

/* betaToTilde is changed in place */
void
betaTilde_Internal(double *betaToTilde, int J, SEXP components_R, int i,
                    int forward)
{
    int n = LENGTH(components_R);
    
    double *beta_hat = (double *)R_alloc(J, sizeof(double));
    
    /* needed by daxpy, blas vector add routine */
    int inc_blas = 1;
    double alpha_blas = -1.0; /* negative 1 */
    
    for (int k = 0; k < n; ++k) {
        if (i != k) {
            SEXP component_R = VECTOR_ELT(components_R, k);
            betaHatComponent_Internal(beta_hat, J, component_R, forward);
            
            F77_CALL(daxpy)(&J, &alpha_blas,
            beta_hat, &inc_blas, betaToTilde, &inc_blas);
        /* after call, betaToTilde = betaToTilde - beta_hat */
        }
    }
}

SEXP diffRandomWalk(SEXP vec_R, SEXP order_R, 
                SEXP iteratorVec_R, SEXP iteratorAns_R);
SEXP
diffRandomWalk_Internal(SEXP prior, SEXP beta_R)
{
    SEXP order_R = GET_SLOT(prior, order_sym);
    SEXP iteratorBeta_R = GET_SLOT(prior, iteratorBeta_sym);
    SEXP iteratorDiffBeta_R = GET_SLOT(prior, iteratorDiffBeta_sym);
    
    SEXP beta_diffed_R;
    PROTECT(beta_diffed_R = diffRandomWalk(beta_R,
                                                order_R,
                                                iteratorBeta_R,
                                                iteratorDiffBeta_R));
    
    UNPROTECT(1); /* beta_diffed_R */
    return beta_diffed_R;
}
    

/*
 * Uses my version of diff.  
 */
SEXP
diffRandomWalk(SEXP vec_R, SEXP order_R, 
                SEXP iteratorVec_R, SEXP iteratorAns_R)
{
    double *vec = REAL(vec_R);
    
    /* treat by value */
    int order = *(INTEGER(order_R));
    int indicesVec_len =  LENGTH(GET_SLOT(iteratorVec_R, indices_sym));
    
    /* treat by value */
    int nWithinAns = *(INTEGER(GET_SLOT(iteratorAns_R, nWithin_sym)));
    int nBetweenAns = *(INTEGER(GET_SLOT(iteratorAns_R, nBetween_sym)));
    
    int indicesAns_len =  LENGTH(GET_SLOT(iteratorAns_R, indices_sym));
    
    int len_ans = indicesAns_len * nWithinAns * nBetweenAns;
    SEXP ans_R;
    PROTECT(ans_R = allocVector(REALSXP, len_ans));
    double *ans = REAL(ans_R);
        
    resetA(iteratorVec_R);
    resetA(iteratorAns_R);
    
    double *work = (double *)R_alloc(indicesVec_len, sizeof(double));
       
    int n_classifying = nWithinAns * nBetweenAns;
    
    while (n_classifying > 0) {
        
        /* new indices each iteration of loop */
        int *indicesVec = INTEGER(GET_SLOT(iteratorVec_R, indices_sym));
        int *indicesAns = INTEGER(GET_SLOT(iteratorAns_R, indices_sym));
        
        /* ans[indices.ans] <- diff(vec[indices.vec], difference = order) */
        
        /* put stuff into work from vec */
        for (int i = 0; i < indicesVec_len; ++i) {
            work[i] = vec[indicesVec[i] - 1];
        }
        
        /* contents of work changed by call to diff: 
         * first indicesVec_len - order elements will contain
         * outcomes we want to put into ans */
        diff(work, indicesVec_len, order);
        
        /* put stuff into ans from work */
        for (int i = 0; i < indicesAns_len; ++i) {
            ans[indicesAns[i] - 1] = work[i];
        }
        
        advanceA(iteratorVec_R); 
        advanceA(iteratorAns_R); 
        /* updates values pointed to by iterator _ptr variables */
        
        --n_classifying;
    }
    //free (work);
    
    UNPROTECT(1); /* ans_R */
    return ans_R;
}
SEXP diffRandomWalk_Internal(SEXP prior, SEXP beta_R);

/* one-off wrapper for diffRandomWalk */
SEXP
diffRandomWalk_R(SEXP vec_R, SEXP order_R, 
                SEXP iteratorVec_R, SEXP iteratorAns_R)
{
    SEXP ans;
    PROTECT(ans = diffRandomWalk(vec_R, order_R, 
                iteratorVec_R, iteratorAns_R) );
    UNPROTECT(1);
    return ans;
}
CALLDEF(diffRandomWalk_R, 4),
      
/* updating */
void forwardFilter(SEXP object_R, SEXP y_R, SEXP v_R, int forward);
void forwardFilter_Internal(SEXP object_R, double *y,  double *v, 
                                int forward);
/* wrap for forwardFilter */
FILTER_NOPRNG_WRAPPER_R(forwardFilter);
CALLDEF(forwardFilter_R, 4),
void
forwardFilter(SEXP object_R, SEXP y_R, SEXP v_R, int forward)
{
    double *y = REAL(y_R);
    double *v = REAL(v_R);
    
    forwardFilter_Internal(object_R, y,  v, forward);
}



/* v, y both at least J long */
void
forwardFilter_Internal(SEXP object_R, double *y,  double *v, int forward)
{
    int J = *INTEGER(GET_SLOT(object_R, J_sym));
    int q = *INTEGER(GET_SLOT(object_R, q_sym));
    /* G a matrix of doubles, size q x q */
    double *G = REAL(GET_SLOT(object_R, G_sym));
    /* F a list of vector of doubles, len J, each vector length q */
    SEXP F_R = GET_SLOT(object_R, F_sym); 
    /* W a list of matrices of doubles, len J, each matrix size q x q */
    SEXP W_R = GET_SLOT(object_R, W_sym); 
    /* m a list of vector of doubles, len J+1, each vector length q */
    SEXP m_R = GET_SLOT(object_R, m_sym); 
    /* C a list of symmetric matrices of doubles, len J+1, each matrix size q x q */
    SEXP C_R = GET_SLOT(object_R, CC_sym); 
    /* UC a list of matrices of doubles, len J+1, each matrix q x q */
    SEXP UC_R = GET_SLOT(object_R, UC_sym); 
    /* DC a list of vectrs of doubles, len J+1, each vector length q */
    SEXP DC_R = GET_SLOT(object_R, DC_sym); 
    /* DCInv a list of vector of doubles, len J+1, each vector length q */
    SEXP DCInv_R = GET_SLOT(object_R, DCInv_sym); 
    /* a a list of vectors of doubles, len J, each vector length q */
    SEXP a_R = GET_SLOT(object_R, a_sym); 
    /* UR a list of matrices of doubles, len J, each matrix q x q */
    SEXP UR_R = GET_SLOT(object_R, UR_sym); 
    /* DRInv a list of vector of doubles, len J, each vector length q */
    SEXP DRInv_R = GET_SLOT(object_R, DRInv_sym); 
   
    /* space for 1 vector length q
     * and 3 matrices q  x q 
     * and svd work  q*(5q + 7)
     * = total  8*q + 8*q*q*/
    int nWorkspace = 8*q*(1+q);
    double *workspace = (double *)R_alloc(nWorkspace, sizeof(double));
    
    /* divvie up the workspace */
    double *singulars = workspace; /* q */
    double *work1 = workspace + q; /* q x q */
    double *work2 = workspace + q + q*q; /* 2*q x q */
    double *work_svd = workspace + q + 3* q*q; /* q*(5q + 7) */
    
    /* allocate 8q of int space for iwork in svd */
    int *iwork_svd = (int *)R_alloc(8*q, sizeof(int));

    /* stuff needed for fortran routines */
    int info = 0;
    int lwork = q*(5*q+7); /* q*(5q + 7) */
    
    char jobz = 'O';
    char transN = 'N';
    char transT = 'T';
    
    int dim_m = 2*q;
    int dim_n = q;
    
    double dummyU = 0; /* U not used */
    int ldu = 1; 
    
    double alpha_blas_one = 1.0;
    double beta_blas_zero = 0.0;
    double beta_blas_one = 1.0;
    
    int inc_blas = 1;
    
    for (int j = 0; j < J; ++j) {
    
        int j0 = j;
        int j1 = j;
        int j2 = j + 1;
        
        if (!forward) {
            j0 = J - j; 
            j1 = J - j - 1;
            j2 = J - j - 1;
        }

        #ifdef DEBUGGING
            PrintValue(mkString("j"));
            PrintValue(ScalarInteger(j));
            PrintValue(ScalarInteger(j+1));
            PrintValue(mkString("j0"));
            PrintValue(ScalarInteger(j0));
            PrintValue(ScalarInteger(j0+1));
            PrintValue(mkString("j1"));
            PrintValue(ScalarInteger(j1));
            PrintValue(ScalarInteger(j1+1));
            PrintValue(mkString("j2"));
            PrintValue(ScalarInteger(j2));
            PrintValue(ScalarInteger(j2+1));
             
        #endif
        
        double *thisDC = REAL(VECTOR_ELT(DC_R, j0));
        double *thisUC = REAL(VECTOR_ELT(UC_R, j0));
        double *thisW = REAL(VECTOR_ELT(W_R, j1));
        double *thisUR = REAL(VECTOR_ELT(UR_R, j1));
        double *thisDRInv = REAL(VECTOR_ELT(DRInv_R, j1));
        double *thisF = REAL(VECTOR_ELT(F_R, j1));
        
        double v_inv = 1/v[j1];
        if (!R_finite(v_inv)) {
            v_inv = 0;
        }
        
        #ifdef DEBUGGING
            PrintValue(mkString("thisDC"));
            PrintValue(VECTOR_ELT(DC_R, j0));
            PrintValue(mkString("thisUC"));
            PrintValue(VECTOR_ELT(UC_R, j0));
            PrintValue(mkString("thisW"));
            PrintValue(VECTOR_ELT(W_R, j1));
            PrintValue(mkString("thisF"));
            PrintValue(VECTOR_ELT(F_R, j1));
            PrintValue(mkString("v_inv"));
            PrintValue(ScalarReal(v_inv));
        #endif
        
        /* t(UC[[j0]]) %*% t(G)*/
        F77_CALL(dgemm)(&transT, &transT, &q, &q, &q,
                        &alpha_blas_one, thisUC, &q, G, &q,
                        &beta_blas_zero, work1, &q);
        /* after call, work1 contains t(UC[[j0]]) %*% t(G) */
        
        /*  M.R <- rbind(diag(DC[[j0]], nrow = q) %*% t(UC[[j0]]) %*% t(G),
                         sqrt(W[[j1]])) */
        for (int rowi = 0; rowi < q; ++rowi) {
         
            for (int colj = 0; colj < q; ++colj) {
            
                /* use work2 to create a 2q x q matrix*/
                work2 [ 2*q*colj + rowi ] 
                            = thisDC[rowi] * work1[q * colj + rowi];
                
                work2 [ 2*q*colj + rowi + q ] 
                            = sqrt(thisW[q * colj + rowi]);
            }
        }
        
        #ifdef DEBUGGING
            PrintValue(mkString("M.R"));
            printDblArray(work2, 2*q*q);
           
        #endif
            
        /* MR (A for dgesdd) in work 2 (2q x q) */
        /* svd.R <- svd(M.R, nu = 0)
         * provide work1 for VT */
        F77_CALL(dgesdd)(&jobz, &dim_m, &dim_n, work2,
                        &dim_m, singulars, &dummyU, &ldu, /* U not used */
                        work1, &dim_n, /* work1 for VT */
                        work_svd, &lwork,
                        iwork_svd, &info);
        if (info) error("error in dgesdd in forwardFilter: %d", info); 
        
        /*UR[[j1]] <- svd.R$v
            DR.inv[[j1]] <- 1 / svd.R$d
            DR.inv[[j1]][is.infinite(DR.inv[[j1]])] <- 0 */
        for (int rowi = 0; rowi < q; ++rowi) {
            
            double tmp = 1/singulars[rowi];
            thisDRInv[rowi] = ( R_finite( tmp ) ? tmp : 0.0 );
        }
        
        #ifdef DEBUGGING
            PrintValue(mkString("V transposed"));
            printDblArray(work1, q*q);
            PrintValue(mkString("singulars"));
            printDblArray(singulars, q);
            PrintValue(mkString("new thisDRInv"));
            PrintValue(VECTOR_ELT(DRInv_R, j1));
        #endif    
        
        double *tmpVec = singulars;
        /*put  sqrt(v.inv)* VT %*% (F[[j1]]) 
         *                  = sqrt(v.inv)* t(UR[[j1]]) %*% F[[ji]] 
         * into tmpVec = singulars*/
        
        double sqrt_v_inv = sqrt(v_inv);
        /* general matrix vector multiplication */
        F77_CALL(dgemv)(&transN, &q, &q, &sqrt_v_inv, work1, /* VT in work1 */ 
                    &q, thisF, &inc_blas, &beta_blas_zero,
                    tmpVec, &inc_blas);
        /* after call, tmpVec contains sqrt(v.inv)* t(UR[[j1]]) %*% F[[ji]] 
         * which is the transpose of what we need for the rbind */
        
        /*M.C <- rbind(sqrt(v.inv) * t(F[[j1]]) %*% UR[[j1]],
                         diag(DR.inv[[j1]], nrow = q)) */
        /* use first q + q*q elments of work2 for M.C
         * M.C will have dims (q+1) * q; */
        memset(work2, 0, q*(q+1)*sizeof(double));                 
        
        for (int rowi = 0; rowi < q; ++rowi) {
            
            for (int colj = 0; colj < q; ++colj) {
            
                if (rowi == 0) {
                    /* top row is tmpVec transposed*/
                    work2 [ (q+1)*colj ] 
                                = tmpVec[colj];
                }
                /* then the diagonal from DRinv */
                if (rowi == colj) {
                work2 [ (q+1)*colj + rowi + 1 ] 
                            = thisDRInv[rowi];
                }
                
                /* also put transpose of work1 into thisUR */
                thisUR[q * colj + rowi] = work1[q * rowi + colj];
            }
        }
        #ifdef DEBUGGING
            PrintValue(mkString("thisUR now"));
            PrintValue(VECTOR_ELT(UR_R, j1));
            PrintValue(mkString("sqrt(v.inv)* t(UR[[j1]]) %*% F[[ji]]"));
            printDblArray(tmpVec, q);
            PrintValue(mkString("M.C"));
            printDblArray(work2, q*(q+1));
            
        #endif
        
        /* M.C (A for dgesdd) in work2 ((q+1) x q) */
        /*svd.C <- svd(M.C, nu = 0)
         * provide work1 for VT */
        int dim_rows = q+1; 
        F77_CALL(dgesdd)(&jobz, &dim_rows, &dim_n, work2,
                        &dim_rows, singulars, &dummyU, &ldu, /* U not used */
                        work1, &dim_n, /* work1 for VT */
                        work_svd, &lwork, /* more than needed */
                        iwork_svd, &info);
        if (info) error("error in dgesdd in forwardFilter: %d", info); 
        
        
        #ifdef DEBUGGING
            PrintValue(mkString("VT"));
            printDblArray(work1, q*q);
            PrintValue(mkString("singulars"));
            printDblArray(singulars, q);
            
        #endif
        
        double *newUC = REAL(VECTOR_ELT(UC_R, j2));
        double *newDC = REAL(VECTOR_ELT(DC_R, j2));
        double *newDCInv = REAL(VECTOR_ELT(DCInv_R, j2));
        double *newC = REAL(VECTOR_ELT(C_R, j2));
        
        /*UC[[j2]] <- UR[[j1]] %*% svd.C$v */
        F77_CALL(dgemm)(&transN, &transT, &q, &q, &q,
                        &alpha_blas_one, thisUR, &q, 
                        work1, &q, /* work1 is t(svd.C$v)) */
                        &beta_blas_zero, newUC, &q);
        
        /*DC[[j2]] <- 1 / svd.C$d
            DC[[j2]][is.infinite(DC[[j2]])] <- 0
            DC.inv[[j2]] <- svd.C$d */
        
        for (int rowi = 0; rowi < q; ++rowi) {
            double d = singulars[rowi];
            double tmp = 1/d;
            newDC[rowi] = ( R_finite( tmp ) ? tmp : 0.0 );
            newDCInv[rowi] = d;
        }
        
        #ifdef DEBUGGING
            PrintValue(mkString("new UC"));
            PrintValue(VECTOR_ELT(UC_R, j2));
            PrintValue(mkString("new DC"));
            PrintValue(VECTOR_ELT(DC_R, j2));
            PrintValue(mkString("new DCInv"));
            PrintValue(VECTOR_ELT(DCInv_R, j2));
        #endif
        
        /* put diag(DC[[j2]]^2, nrow = q) %*% t(UC[[j2]] into work1 */
        for (int rowi = 0; rowi < q; ++rowi) {
            
            double d = newDC[rowi];
            
            for (int colj = 0; colj < q; ++colj) {
                work1[colj*q + rowi] = d*d * newUC[rowi*q + colj];
            }
        }
        
        #ifdef DEBUGGING
            PrintValue(mkString("diag(DC[[j2]]^2, nrow = q) %*% t(UC[[j2]]"));
            printDblArray(work1, q*q);
        #endif
        
        /* C[[j2]] <- UC[[j2]] %*% diag(DC[[j2]]^2, nrow = q) %*% t(UC[[j2]])*/
        F77_CALL(dgemm)(&transN, &transN, &q, &q, &q,
                        &alpha_blas_one, newUC, &q, 
                        work1, &q, /* work1 is  diag(DC[[j2]]^2, nrow = q) %*% t(UC[[j2]])*/
                        &beta_blas_zero, newC, &q);
        
        #ifdef DEBUGGING
            PrintValue(mkString("new C"));
            PrintValue(VECTOR_ELT(C_R, j2));
        #endif
        
        double *this_m = REAL(VECTOR_ELT(m_R, j0));
        double *new_a = REAL(VECTOR_ELT(a_R, j1));
        double *new_m = REAL(VECTOR_ELT(m_R, j2));

        #ifdef DEBUGGING
            PrintValue(mkString("this_m"));
            PrintValue(VECTOR_ELT(m_R, j0));
        #endif 

        /* a[[j1]] <- drop(G %*% m[[j0]]) */
        F77_CALL(dgemv)(&transN, &q, &q, &alpha_blas_one, G, 
                    &q, this_m, &inc_blas, &beta_blas_zero,
                    new_a, &inc_blas);
        /* new_a should have new a[[j1]] */
        
        #ifdef DEBUGGING
            PrintValue(mkString("new a[[j1]]"));
            PrintValue(VECTOR_ELT(a_R, j1));
        #endif    
        
        
        /*f.j <- sum(F[[j1]] * a[[j1]]) */
        double f_j = F77_CALL(ddot)(&q, thisF,
                &inc_blas, new_a, &inc_blas);   
        
        /*e.j <- y[j1] - f.j*/
        double e_j = y[j1] - f_j;
        
        #ifdef DEBUGGING
            PrintValue(mkString("f.j"));
            PrintValue( ScalarReal(f_j));
            PrintValue(mkString("e.j"));
            PrintValue( ScalarReal(e_j));
        #endif    
        
        /* new_a = a[[j1]] into new_m = m[[j2]]*/
        memcpy(new_m, new_a, q*sizeof(double));
        
        /*A.j <- drop(C[[j2]] %*% F[[j1]]) * v.inv
         * m[[j2]] <- a[[j1]] + A.j * e.j
         so do m[[j2]] <- m[[j1]] + C[[j2]] %*% F[[j1]] * v.inv * e.j */
        double mult = v_inv * e_j;
        F77_CALL(dgemv)(&transN, &q, &q, &mult, newC,  
                    &q, thisF, &inc_blas, &beta_blas_one,
                    new_m, &inc_blas); /* before, new_m contains a[[j1]] */
        
        #ifdef DEBUGGING
            PrintValue(mkString("new m[[j2]]"));
            PrintValue(VECTOR_ELT(m_R, j2));
        #endif  
    } /* end j loop */
}

void minv2 (SEXP m_ans_R);
* one-off wrapper for minv2 */
SEXP minv2_R(SEXP m_R)
{
	SEXP ans_R;         
    PROTECT(ans_R = duplicate(m_R));
    minv2(ans_R);
    UNPROTECT(1);
	return ans_R;
}
CALLDEF(minv2_R, 1),
void minv2_Internal (double *m_ans);
void
minv2 (SEXP m_ans_R)
{
    double *m_ans = REAL(m_ans_R);
    minv2_Internal (m_ans);
    
}

void
minv2_Internal (double *m_ans)
{
    /* tolerance for K */
    double k_tolerance = 1e-10; 

    double m_ans0 = m_ans[0];
    double m_ans1 = m_ans[1];
    double m_ans2 = m_ans[2];
    double m_ans3 = m_ans[3];
    
    double det = m_ans0 * m_ans3 - m_ans1 * m_ans2;
    if (fabs(det) < k_tolerance) {
        error("determinant of 'm' indistinguishable from 0");
    }
    m_ans[0] = m_ans3 / det;
    m_ans[3] = m_ans0 / det;
    m_ans[1] = -m_ans1 / det;
    m_ans[2] = -m_ans2 / det;
    
}

/* symbols removed */
tauUnscaled_sym,
minTau_sym,
maxTau_sym,
nu_sym,
Gq_sym,
FqTFq_sym,
iteratorDiffBeta_sym,
valueBench_sym, /* changed name */
weightBench_sym, /* changed name */
transformBench_sym, /* changed name */
meanBench_sym, /* changed name */
sdBench_sym, /* changed name */
scaleBench_sym, /* changed name */
nAcceptBench_sym, /* changed name */
nFailedPropValueBench_sym, /* changed name */
iMethodPriorVarDLM_sym,
F_sym, 
/* gamma_sym already done */
deltaHat_sym,
gammaHat_sym,
inverseG_sym,
W_sym,
m_sym,
components_sym,
offsetsComponents_sym,
iMethodPolyComponent_sym,
phiUnscaled_sym,
phiRestricted_sym,
deltaNoInitial_sym,
gammaNoInitial_sym,
priorV_sym,  
priorW_sym,
  //offsetsDelta_sym,
  //offsetsGamma_sym,
  //iteratorGammaEst_sym,
  //offsetsPhi_sym,
  //offsetsPriorW_sym,
ADD_SYM(offsetsGamma0);
  ADD_SYM(offsetsPriorsW);
  ADD_SYM(offsetsPriorV);
  ADD_SYM(offsetsZetas);
  
  
ADD_SYM(tauUnscaled);
ADD_SYM(minTau);
ADD_SYM(maxTau);
ADD_SYM(nu);
ADD_SYM(Gq);
ADD_SYM(FqTFq);
ADD_SYM(iteratorDiffBeta);
ADD_SYM(valueBench);
ADD_SYM(weightBench);
ADD_SYM(transformBench);
ADD_SYM(meanBench);
ADD_SYM(sdBench);
ADD_SYM(scaleBench);
ADD_SYM(nAcceptBench);
ADD_SYM(nFailedPropValueBench);
ADD_SYM(iMethodPriorVarDLM);
ADD_SYM(F);
ADD_SYM(deltaHat);
ADD_SYM(gammaHat);
ADD_SYM(inverseG);
ADD_SYM(W);
ADD_SYM(m);
ADD_SYM(components);
ADD_SYM(offsetsComponents);
ADD_SYM(iMethodPolyComponent);
ADD_SYM(phiUnscaled);
ADD_SYM(phiRestricted);
ADD_SYM(deltaNoInitial);
ADD_SYM(gammaNoInitial);
ADD_SYM(priorV);
ADD_SYM(priorW);
ADD_SYM(phiKnown);
  ADD_SYM(offsetsDelta);
  ADD_SYM(offsetsGamma);
  ADD_SYM(iteratorGammaEst);
  ADD_SYM(offsetsPhi);
  ADD_SYM(offsetsPriorW);
  
  
#if(0)
void
updateGammaM0C0AR1(SEXP prior_R, SEXP beta_R)
{
    double *beta = REAL(beta_R); 

    int K = *INTEGER(GET_SLOT(prior_R, K_sym)); /*scalar integer */ 
    int L = *INTEGER(GET_SLOT(prior_R, L_sym)); /*scalar integer */ 
    double *gamma = REAL(GET_SLOT(prior_R, gamma_sym)); /*length (K+1)L */ 
    double *m0 = REAL(GET_SLOT(prior_R, m0_sym)); /*length L */ 
    double *C0 = REAL(GET_SLOT(prior_R, C0_sym)); /*length L */ 
    double phi = *REAL(GET_SLOT(prior_R, phi_sym)); /*scalar double */ 
    double *v = REAL(GET_SLOT(prior_R, v_sym)); /*length KL */ 
    double *w = REAL(GET_SLOT(prior_R, w_sym)); /*length KL */ 
    SEXP iterGamma_R = GET_SLOT(prior_R, iteratorGamma_sym); /* AlongIterator */ 
    SEXP iterV_R = GET_SLOT(prior_R, iteratorV_sym); /* AlongIterator */ 

    double *m = (double *)R_alloc((K+1), sizeof(double)); 
    double *C = (double *)R_alloc((K+1), sizeof(double)); 
    double *R = (double *)R_alloc(K, sizeof(double)); 

    resetA(iterGamma_R); 
    resetA(iterV_R); 

    int *indicesGamma = INTEGER(GET_SLOT(iterGamma_R, indices_sym)); 
    int *indicesV = INTEGER(GET_SLOT(iterV_R, indices_sym)); 

    double phi_squared = phi*phi; 

    for (int l = 0; l < L; ++l) { 
         
        m[0] = m0[l]; 
        C[0] = C0[l]; 
        
        #ifdef DEBUGGING 
            PrintValue(mkString("")); 
            PrintValue(mkString("l = ")); 
            PrintValue(ScalarInteger(l)); 
            PrintValue(mkString("m[0] = m0[l] ")); 
            PrintValue(ScalarReal(m[0])); 
            PrintValue(mkString("C[0] = C0[l] ")); 
            PrintValue(ScalarReal(C[0])); 
        #endif 
        
        for (int k = 0; k < K; ++k) { 
            
            int iv = indicesV[k] - 1; 
            
            #ifdef DEBUGGING 
                PrintValue(mkString("")); 
                PrintValue(mkString("forward k = ")); 
                PrintValue(ScalarInteger(k)); 
                PrintValue(mkString("iv = indicesV[k] - 1 = ")); 
                PrintValue(ScalarInteger(iv)); 
            #endif 
            
            double R_k = phi_squared * C[k] + w[iv]; 
            R[k] = R_k; 
            double v_iv = v[iv]; 
            double A = v_iv / (R_k + v_iv); 
            m[k+1] = A * phi * m[k] + (1-A)*beta[iv]; 
            C[k+1] = A * R_k; 
            
            #ifdef DEBUGGING 
                PrintValue(mkString("R[k] =")); 
                PrintValue(ScalarReal(R_k)); 
                PrintValue(mkString("v[iv] =")); 
                PrintValue(ScalarReal(v_iv)); 
                PrintValue(mkString("A = ")); 
                PrintValue(ScalarReal(A)); 
                PrintValue(mkString("m[k+1] = ")); 
                PrintValue(ScalarReal(m[k+1])); 
                PrintValue(mkString("C[k+1] = ")); 
                PrintValue(ScalarReal(C[k+1])); 
            #endif 
        } 

        int ig = indicesGamma[K] - 1; /* index [K + 1L] in R -> [K] in C*/ 
        gamma[ig] = rnorm(m[K], sqrt(C[K])); 
        
        #ifdef DEBUGGING 
            PrintValue(mkString("")); 
            PrintValue(mkString("finished forward")); 
        
            PrintValue(mkString("ig = ")); 
            PrintValue(ScalarInteger(ig)); 
            PrintValue(mkString("m[K] = ")); 
            PrintValue(ScalarReal(m[K])); 
            PrintValue(mkString("C[K] = ")); 
            PrintValue(ScalarReal(C[K])); 
            
            PrintValue(mkString("gamma[ig]")); 
            PrintValue(ScalarReal(gamma[ig])); 
            PrintValue(mkString("")); 
        #endif 
        
        for (int k = K-1; k >= 0; --k) { 
            
            int iv = indicesV[k] - 1; 
            int ig0 = indicesGamma[k] - 1; 
            int ig1 = indicesGamma[k+1] - 1; 
            
            #ifdef DEBUGGING 
                PrintValue(mkString("backward k = ")); 
                PrintValue(ScalarInteger(k)); 
            
                PrintValue(mkString("iv = ")); 
                PrintValue(ScalarInteger(iv)); 
                PrintValue(mkString("ig0 = ")); 
                PrintValue(ScalarInteger(ig0)); 
                PrintValue(mkString("ig1 = ")); 
                PrintValue(ScalarInteger(ig1)); 
            #endif 
            
            double B = w[iv] / R[k]; 
            m[k] = B * m[k] + (1 - B)*gamma[ig1]/phi; 
            C[k] = B * C[k]; 
            gamma[ig0] = rnorm(m[k], sqrt(C[k])); 
            
            #ifdef DEBUGGING 
                PrintValue(mkString("B = ")); 
                PrintValue(ScalarReal(B)); 
                PrintValue(mkString("m[k] = ")); 
                PrintValue(ScalarReal(m[k])); 
                PrintValue(mkString("C[k] = ")); 
                PrintValue(ScalarReal(C[k])); 
                PrintValue(mkString("m[k] = ")); 
                PrintValue(ScalarReal(m[k])); 
                PrintValue(mkString("C[k] = ")); 
                PrintValue(ScalarReal(C[k])); 
                PrintValue(mkString("gamma[ig0] = ")); 
                PrintValue(ScalarReal(gamma[ig0])); 
            #endif 
        } 
       
        m0[l] = m[0]; 
        C0[l] = C[0]; 

        advanceA(iterGamma_R); 
        advanceA(iterV_R);  

        #ifdef DEBUGGING 
            PrintValue(mkString(""));     
            PrintValue(mkString("finished backward")); 
            PrintValue(mkString("")); 
            PrintValue(mkString("m0[l] = ")); 
            PrintValue(ScalarReal(m0[l])); 
            PrintValue(mkString("C0[l] = ")); 
            PrintValue(ScalarReal(C0[l])); 
            PrintValue(mkString("done updates")); 
        #endif 
    } 
}
#endif

void transferGamma(SEXP component_R, double *values, int nValues);
void transferGamma0(SEXP component_R, double *values, int nValues, int forward);


SEXP transferGamma_R(SEXP component_R, SEXP values_R)
{
    double *values = REAL(values_R);
    int nValues = LENGTH(values_R);
    
    SEXP ans_R;         
    PROTECT(ans_R = duplicate(component_R));
    transferGamma(ans_R, values, nValues);
    UNPROTECT(1);
    return ans_R;
}

SEXP transferGamma0_R(SEXP component_R, SEXP values_R, SEXP forward_R)
{
    int forward = *INTEGER(forward_R);
    double *values = REAL(values_R);
    int nValues = LENGTH(values_R);
    
    SEXP ans_R;         
    PROTECT(ans_R = duplicate(component_R));
    transferGamma0(ans_R, values, nValues, forward);
    UNPROTECT(1);
    return ans_R;
}

CALLDEF(transferGamma_R, 2),
  
  CALLDEF(transferGamma0_R, 3),
  
void
transferGamma(SEXP component_R, double *values, int nValues)
{
    /* J integer, q an integer
    gamma a list of length J+1 of doubles length q */
    int q = *(INTEGER(GET_SLOT(component_R, q_sym)));
    int J = *(INTEGER(GET_SLOT(component_R, J_sym)));
    SEXP gamma_R = GET_SLOT(component_R, gamma_sym);
    
    int first = 0;
    
    if ((nValues < q*(J+1)) ) {
        error("transferGamma: not enough elements in values");
    }
    
    for (int i = 0; i < J+1; ++i) {
        double *this_gamma = REAL(VECTOR_ELT(gamma_R, i));
        memcpy(this_gamma, values + first, q*sizeof(double)); 
        first += q;   
    }
}

 
void
transferGamma0(SEXP component_R, double *values, int nValues, int forward)
{
    /* J integer, q an integer
    gamma a list of length J+1 of doubles length q */
    int J = *(INTEGER(GET_SLOT(component_R, J_sym)));
    SEXP gamma_R = GET_SLOT(component_R, gamma_sym);
    
    /* offsets has two integer elements, second >= first */
    int *offsets_gamma0 = INTEGER(GET_SLOT(component_R, offsetsGamma0_sym));
    int first = offsets_gamma0[0]-1;
    int last = offsets_gamma0[1]-1;
    
    if (!(nValues > last) ) {
        error("transferGamma0: not enough elements in values");
    }
    
    double *this_gamma = NULL;

    if (forward) {
        this_gamma = REAL(VECTOR_ELT(gamma_R, 0)); /* first gamma */
    }
    else {
        this_gamma = REAL(VECTOR_ELT(gamma_R, J)); /* last gamma */
    }
    
    int n = last - first + 1;
    
    for (int i = 0; i < n; ++i) {
        this_gamma[i] = values[first + i];
    }
}
    

void transferParamDeltaAR11(SEXP prior_R, double *values, int nValues); 
void transferParamDelta0AR11Predict(SEXP prior_R, double *values, int nValues); 
void transferParamGammaAR1(SEXP prior_R, double *values, int nValues);
void transferParamGamma0AR1Predict(SEXP prior_R, double *values, int nValues);    
void transferParamPhiAR1(SEXP prior_R, double *values, int nValues);
/* wrap transfer AR1 functions*/
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamDeltaAR11);
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamDelta0AR11Predict);
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamGammaAR1);
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamGamma0AR1Predict);
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamPhiAR1);

CALLDEF(transferParamDeltaAR11_R, 2),
  CALLDEF(transferParamDelta0AR11Predict_R, 2),
  CALLDEF(transferParamGammaAR1_R, 2),
  CALLDEF(transferParamGamma0AR1Predict_R, 2),
  CALLDEF(transferParamPhiAR1_R, 2),
void
transferParamDeltaAR11(SEXP prior_R, double *values, int nValues)
{
    int *offsets = INTEGER(GET_SLOT(prior_R, offsetsDelta_sym));
	int first = offsets[0] - 1;
	int last =  offsets[1] - 1;
    
    int nToCopy = last - first + 1;
	double *delta = REAL(GET_SLOT(prior_R, delta_sym)); 
    /* copy from values to delta */
	memcpy(delta, values + first, nToCopy*sizeof(double)); 
}

void
transferParamDelta0AR11Predict(SEXP prior_R, double *values, int nValues)
{
	int K = *INTEGER(GET_SLOT(prior_R, K_sym));
	int L = *INTEGER(GET_SLOT(prior_R, L_sym));
	int forward = *INTEGER(GET_SLOT(prior_R, forward_sym));
	
	double *delta = REAL(GET_SLOT(prior_R, delta_sym)); 
	
	int *offsets = INTEGER(GET_SLOT(prior_R, offsetsDelta_sym));
	int first = offsets[0] - 1;
	
	double *valsToCopy = values + first;
	
	SEXP iterPred_R = GET_SLOT(prior_R, iteratorGamma_sym);
	SEXP iterEst_R = GET_SLOT(prior_R, iteratorGammaEst_sym);
	
	resetA(iterPred_R);
	resetA(iterEst_R);
	
	int *indicesPred = INTEGER(GET_SLOT(iterPred_R, indices_sym));
	SEXP indicesEst_R = GET_SLOT(iterEst_R, indices_sym);
	int *indicesEst = INTEGER(indicesEst_R);
	
	int K_plus_1_est = LENGTH(indicesEst_R);
    
	for (int l = 0; l < L; ++l) {
		int i_pred = (forward ? indicesPred[0] : indicesPred[K]) - 1;
		int i_est = (forward ? indicesEst[K_plus_1_est - 1] 
												: indicesEst[0]) - 1;
		delta[i_pred] = valsToCopy[i_est];
		
		advanceA(iterPred_R);
		advanceA(iterEst_R);
	}
}

void
transferParamGammaAR1(SEXP prior_R, double *values, int nValues)
{
	int *offsets = INTEGER(GET_SLOT(prior_R, offsetsGamma_sym));
	int first = offsets[0] - 1;
	int last =  offsets[1] - 1;
	
	int nToCopy = last - first + 1;
	double *gamma = REAL(GET_SLOT(prior_R, gamma_sym)); 
	
	/* copy from values to gamma */
	memcpy(gamma, values + first, nToCopy*sizeof(double)); 
}

void
transferParamGamma0AR1Predict(SEXP prior_R, double *values, int nValues)
{
	int K = *INTEGER(GET_SLOT(prior_R, K_sym));
	int L = *INTEGER(GET_SLOT(prior_R, L_sym));
	int forward = *INTEGER(GET_SLOT(prior_R, forward_sym));
	
	double *gamma = REAL(GET_SLOT(prior_R, gamma_sym)); 
	
	int *offsets = INTEGER(GET_SLOT(prior_R, offsetsGamma_sym));
	int first = offsets[0] - 1;
	
	double *valsToCopy = values + first;
	
	SEXP iterPred_R = GET_SLOT(prior_R, iteratorGamma_sym);
	SEXP iterEst_R = GET_SLOT(prior_R, iteratorGammaEst_sym);
	
	resetA(iterPred_R);
	resetA(iterEst_R);
	
	int *indicesPred = INTEGER(GET_SLOT(iterPred_R, indices_sym));
	SEXP indicesEst_R = GET_SLOT(iterEst_R, indices_sym);
	int *indicesEst = INTEGER(indicesEst_R);
	
	int K_plus_1_est = LENGTH(indicesEst_R);
	
	for (int l = 0; l < L; ++l) {
		int i_pred = (forward ? indicesPred[0] : indicesPred[K]) - 1;
		int i_est = (forward ? indicesEst[K_plus_1_est - 1] 
												: indicesEst[0]) - 1;
		gamma[i_pred] = valsToCopy[i_est];
		
		advanceA(iterPred_R);
		advanceA(iterEst_R);
	}
}

void
transferParamPhiAR1(SEXP prior_R, double *values, int nValues)
{
	int phiKnown = *INTEGER(GET_SLOT(prior_R, phiKnown_sym));
	
	if (!phiKnown) {
		int *offsets = INTEGER(GET_SLOT(prior_R, offsetsPhi_sym));
		
		int first = offsets[0] - 1;
		SET_SLOT(prior_R, phi_sym, ScalarReal(values[first]));
	}
}
      

 
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamPriorV);
TRANSFERPARAMPRIOR_WRAPPER_R(transferParamPriorWAR1);
TRANSFERPARAM_WRAPPER_R(transferParamZetas);

SEXP transferPriorsW_R(SEXP component_R, SEXP values_R)
{
    double *values = REAL(values_R);
    int nValues = LENGTH(values_R);
    
    SEXP ans_R;         
    PROTECT(ans_R = duplicate(component_R));
    transferPriorsW(ans_R, values, nValues);
    UNPROTECT(1);
    return ans_R;
}

/* Priors-methods */
  CALLDEF(transferParamPriorV_R, 2),

    CALLDEF(transferParamPriorWAR1_R, 2),  
CALLDEF(transferParamZetas_R,4),
CALLDEF(transferPriorsW_R, 2),
  
void transferParamPriorWAR1(SEXP prior_R, double *values, int nValues);                                
void transferParamPriorV(SEXP prior_R, double *values, int nValues);
void transferParamZetas(SEXP model_R, const char *filename,
                                int lengthIter, int iteration);
void transferPriorsW(SEXP component_R, double *values, int nValues);

void
transferParamPriorV(SEXP prior_R, double *values, int nValues)
{
    /* offsetsPriorV_R of type OffsetOrNull */
    SEXP offsetsPriorV_R = GET_SLOT(prior_R, offsetsPriorV_sym);
    
    if ( !isNull(offsetsPriorV_R) ) {
        
        
        /* unused since transferParamPriorVarDLM function deleted */
        #if(0)
        int *offsets = INTEGER(offsetsPriorV_R);
        SEXP priorV_R = GET_SLOT(prior_R, priorV_sym);
        
        int first = offsets[0]-1;
        int last = offsets[1]-1;
        
        int nValuesToTransfer = last - first + 1;
        
        /* function deleted */
		transferParamPriorVarDLM(priorV_R, values + first, nValuesToTransfer); 
        #endif
    }
}


void
transferParamPriorWAR1(SEXP prior_R, double *values, int nValues)
{
	SEXP offsetsPriorW_R = GET_SLOT(prior_R, offsetsPriorW_sym);
	
	if ( !isNull(offsetsPriorW_R) ) {
        
        /* unused since transferParamPriorVarDLM function deleted */
		#if(0)
        int *offsets = INTEGER(offsetsPriorW_R);
        SEXP priorW_R = GET_SLOT(prior_R, priorW_sym);
        int first = offsets[0]-1;
        int last = offsets[1]-1;
        
        int nValuesToTransfer = last - first + 1;
        
        /* function deleted */
		transferParamPriorVarDLM(priorW_R, values + first, nValuesToTransfer); 
        #endif
    }
}


void
transferParamZetas(SEXP model_R, const char *filename,
                                int lengthIter, int iteration)
{
    double *zetas = REAL(GET_SLOT(model_R, zetas_sym));
    
    int *this_offsets = INTEGER(GET_SLOT(model_R, offsetsZetas_sym));
    int first = this_offsets[0] - 1;
    int last = this_offsets[1] - 1;
    
    int length_data = last - first + 1;
        
    getOneIterFromFile(zetas,
                        filename, 
                        first, 
                        length_data, 
                        lengthIter, 
                        iteration);
}


void
transferPriorsW(SEXP component_R, double *values, int nValues)
{
    int q = *(INTEGER(GET_SLOT(component_R, q_sym)));
    
    /* unused since transferParamPriorVarDLM function deleted */
	#if(0)
	/* PriorsW a list of PriorVarDLM types, length q */
    SEXP priorsW_R = GET_SLOT(component_R, priorsW_sym);
    #endif
    
    /* offsetsPriorsW a list of offset types, length q */
    SEXP offsetsPriorsW_R = GET_SLOT(component_R, offsetsPriorsW_sym);
    
    for (int i = 0; i < q; ++i) {
        SEXP this_offset_R = VECTOR_ELT(offsetsPriorsW_R, i);
        
        if( !isNull(this_offset_R)) {
            
            /* unused since transferParamPriorVarDLM function deleted */
			#if(0)
			int *this_offset = INTEGER(this_offset_R);
            int first = this_offset[0]-1;
            int last = this_offset[1]-1;
            
            int nValuesToTransfer = last - first + 1;
            
            /* priorsW[[i]] <- transferParamPriorVarDLM(prior = priorsW[[i]],
                                             values = values[first : last]) */
            SEXP thisPriorW = VECTOR_ELT(priorsW_R, i);
            
            /* function deleted */
            transferParamPriorVarDLM(thisPriorW, &values[first], 
                                                    nValuesToTransfer);
			#endif
        }
    }
}


    
	   
    
