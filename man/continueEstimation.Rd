% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimate-functions.R
\name{continueEstimation}
\alias{continueEstimation}
\title{Add extra iterations to burnin or output.}
\usage{
continueEstimation(filename, nBurnin = 0, nSim = 1000, verbose = FALSE,
  useC = TRUE)
}
\arguments{
\item{filename}{The filename used by the original call.}

\item{nBurnin}{Number of iteration discarded before recording begins.}

\item{nSim}{Number of additional iterations.}

\item{verbose}{Logical.  If \code{TRUE} (the default) a message is
printed at the end of the calculations.}

\item{useC}{Logical.  If \code{TRUE} (the default), the calculations
are done in C.  Setting \code{useC} to \code{FALSE} may be useful
for debugging.}
}
\description{
Continue estimation process, retaining current settings, but extending
the burnin or sampling from the posterior distribution.
\code{continueEstimation} is called after \code{\link{estimateModel}},
\code{\link{estimateCounts}}, or \code{\link{estimateAccount}},
and can be called multiple times.
}
\details{
The treatment of output from previous calls to the estimation functions or
to \code{continueEstimation} depends on whether \code{nBurnin} in the
current call to \code{continueEstimation} is equal to 0 or greater than 0.
If \code{nBurnin} is equal to 0, then any further iterations are added to
the current posterior sample.  If \code{nBurnin} is greater than
0, then any previous output is treated as part of the burnin, and the
construction of the posterior sample begins again from scratch.
See below for an example.

Because model output includes the state of the random number generator,
it should be possible to obtain identical results by (i) calling an estimation
function followed by one or more calls to \code{continueEstimation},
and (ii) doing all the calculations in one call to an estimaton function.
For instance,
\itemize{
  \item \code{estimateModel} with \code{nBurnin = 2000} and \code{nSim = 0}
  \item \code{continueEstimation} with \code{nSim = 1000}
  \item \code{continueEstimation} with \code{nSim = 1000}
}
should give the same results as
\itemize{
  \item \code{estimateModel} with \code{nBurnin = 2000} and \code{nSim = 2000}.
}

Note that the total size of the posterior sample depends not just on
\code{nSim}, but also on \code{nChain} and \code{nThin}.  In the simplest
case (ie a single call to an estimation function, and \code{nSim * nChain}
divisible by \code{nThin}) the number of iterations in the sample equals
\code{nSim * nChain / nThin}.
}
\examples{
## prepare data
deaths <- demdata::VADeaths2
popn <- demdata::VAPopn
deaths <- round(deaths)
deaths <- Counts(deaths)
popn <- Counts(popn)

## Show that estimation using a single call to
## 'estimateModel' gives the same results as
## a call to 'estimateModel' followed by a call
## to 'continueEstimation'

## estimate all at once
set.seed(1)
filename.all.at.once <- tempfile()
estimateModel(Model(y ~ Poisson(mean ~ age)),
              y = deaths,
              exposure = popn,
              filename = filename.all.at.once,
              nBurnin = 20,
              nSim = 20,
              nThin = 2,
              nChain = 2,
              parallel = FALSE)
rates.all.at.once <- fetch(filename.all.at.once,
                           where = c("model", "likelihood", "rate"))

## estimate using 'continueEstimation'
set.seed(1)
filename.with.continue <- tempfile()
estimateModel(Model(y ~ Poisson(mean ~ age)),
              y = deaths,
              exposure = popn,
              filename = filename.with.continue,
              nBurnin = 20,
              nSim = 0,
              nThin = 2,
              nChain = 2,
              parallel = FALSE)
continueEstimation(filename = filename.with.continue,
                   nBurnin = 0,
                   nSim = 20)
rates.with.continue <- fetch(filename.all.at.once,
                           where = c("model", "likelihood", "rate"))

## the two approaches give the same answer
all.equal(rates.all.at.once, rates.with.continue)


## Demonstrate the differences between nBurnin = 0
## and nBurnin > 0.

## nBurnin = 0 in call to continueEstimation, so keep 
## iterations from original call to estimateModel
filename.keep.original <- tempfile()
estimateModel(Model(y ~ Poisson(mean ~ age)),
              y = deaths,
              exposure = popn,
              filename = filename.keep.original,
              nBurnin = 20,
              nSim = 10,
              nThin = 2,
              nChain = 2,
              parallel = FALSE)
continueEstimation(filename = filename.keep.original,
                   nBurnin = 0,
                   nSim = 20)
fetchSummary(filename.keep.original) # see 'nBurnin' and 'nSim'

## nBurnin > 0 in call to continueEstimation, so treat
## iterations from original call to estimateModel
## as part of burnin
filename.discard.original <- tempfile()
estimateModel(Model(y ~ Poisson(mean ~ age)),
              y = deaths,
              exposure = popn,
              filename = filename.discard.original,
              nBurnin = 20,
              nSim = 10,
              nThin = 2,
              nChain = 2,
              parallel = FALSE)
continueEstimation(filename = filename.discard.original,
                   nBurnin = 10,
                   nSim = 10)
fetchSummary(filename.discard.original) # see 'nBurnin' and 'nSim'

}
\references{
\code{continueEstimation} was inspired by the discussion of
checkpointing in Geyer, C. 2011. Introduction to Markov chain Monte Carlo.
Brooks, S., Gelman, A., Jones, G. L., and Meng, X-L. (eds.)
\emph{Handbook of Markov Chain Monte Carlo}. Chapman & Hall/CRC.
}
\seealso{
\code{continueEstimation} is used together with
\code{\link{estimateModel}}, \code{\link{estimateCounts}},
and \code{\link{estimateAccount}}.
}
