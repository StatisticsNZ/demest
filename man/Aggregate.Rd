% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SpecModel-generators.R
\name{Aggregate}
\alias{AgCertain}
\alias{AgFun}
\alias{AgNormal}
\alias{AgPoisson}
\alias{Aggregate}
\title{Specify aggregate values.}
\usage{
AgCertain(value, weights = NULL, concordances = list())

AgNormal(value, sd, weights = NULL, concordances = list(), jump = NULL)

AgPoisson(value, weights = NULL, concordances = list(), jump = NULL)

AgFun(value, sd, FUN, weights = NULL, concordances = list())
}
\arguments{
\item{value}{The aggregate value or values.  A single number, or, if there
are multiple values, an object of class
\code{\linkS4class{DemographicArray}}.}

\item{weights}{An object of class \code{\linkS4class{Counts}} holding
weights to be used when aggregating. Optional.}

\item{concordances}{A named list of objects of class
\code{\link[classconc]{ManyToOne}}.}

\item{sd}{Standard deviation(s) for errors. If \code{value} is a single
number, then \code{sd} must be a single number; otherwise \code{sd} must be
an object of class \code{\linkS4class{DemographicArray}}.}

\item{jump}{The standard deviation of the proposal density used in
Metropolis-Hastings updates.}

\item{FUN}{A function taking arguments called \code{x} and \code{weights}
and returning a single number.  See below for details.}
}
\value{
An object of class \code{\linkS4class{SpecAggregate}}.
}
\description{
Specify values for aggregations of low-level parameters.
Aggregate values can be used to provide extra information to a model,
beyond the information contains in the main dataset.  For instance,
aggregate values can be used implement benchmarks or incorporate
expert judgements.
}
\details{
Let \eqn{\gamma_i} be a rate, count, probability, or mean for cell \eqn{i}.
For instance, \eqn{\gamma_i} could be the prevalence of obesity in a
particular combination of age, educational status, and region, or it
could be an age-sex-specific mortality rate during a given period.  
The \eqn{\gamma_i} are underlying parameters that are not observed
directly.

Let \eqn{\psi_j} be a more aggregate parameter describing the same
phenomenon as the \eqn{\gamma_i}.  For instance, \eqn{\psi_j} could
be the average prevalence of obesity in region \eqn{j}, or life expectancy
for sex \eqn{j}.  Like the \eqn{\gamma_i}, the \eqn{\psi_j} are not
observed directly.

Typically, \eqn{\psi_j} is a weighted sum of the associated \eqn{\gamma_i},
that is,

\deqn{\psi_j = \sum b_{ij} \gamma_i,}

where \eqn{b_{ij} > 0} if \eqn{\gamma_i} is associated with \eqn{\psi_j},
and 0 otherwise.  For instance, if \eqn{\gamma_i} describes obesity
prevalence for a subpopulation in region \eqn{j}, then \eqn{b_{ij} > 0},
and if it describes obesity prevanece in another region, then
\eqn{b_{ij} = 0}.

However, more complicated relationships between the \eqn{\psi_j} and
\eqn{\gamma_j} are also permitted.  In the most general case,

\deqn{\psi_j = f(B, \gamma),}

where \eqn{B} is a matrix of \eqn{b_{ij}}, and \eqn{f} is an arbitrary
function.  For instance, \eqn{f} could be a (non-linear) function that takes
a vector of age-specific mortality rates and returns life expectancy.

Let \eqn{m_j} be an estimate, prediction, or elicited value for
aggregate parameter \eqn{\psi_j}.  For instance, \eqn{m_j} could be a
previously published estimate of obesity prevalence in region \eqn{j},
or it could be an expert's life expectancy forecast.  In contrast to the
\eqn{\gamma_i} and \eqn{\psi_j}, the \eqn{m_j} are observed. The \eqn{m_j}
are 'aggregate values'.

Aggregate values are treated as data, and placed in the likelihood.  To do
so, a sub-model specifying the relationship between the \eqn{m_j} and
\eqn{\psi_j} is required.  A sub-model

\deqn{p(m_j | \psi_j),}

is, in effect, a model for the accuracy of the \eqn{m_j}.

Different choices for the relationship between (i) the \eqn{\gamma_i} and
\eqn{\psi_j}, and (ii) the \eqn{\psi_j} and \eqn{m_j} are appropriate
for different applications.  The combinations that are currently available
in \code{demest} are documented below.

Default values for the \eqn{b_{ij}} vary according to the model being used:

\tabular{ll}{
   Model \tab Default \cr
   Poisson with exposure \tab \code{exposure} argument, normalised to sum to
1 for each \eqn{j}. \cr
   Poisson without exposure \tab All weights equal to 1. \cr
   Binomial \tab \code{exposure} argument, normalised to sum to 1 for each
\eqn{j}. \cr
   Normal \tab \code{weights} argument (which defaults to 1).
}

The \code{concordances} argument is needed when \code{values} has categories
that are collapsed versions of categories of \code{weights}, or the
underlying rates, probabilities, or means.  For instance, \code{values}
might be specified at the state level, while the rates are estimated at
the county level.  The mapping between the original and collapsed
categories is known as a \code{\link[classconc]{Concordance}}.
}
\section{\code{AgCertain}}{


The aggregate parameters are weighted sums or means of the disaggregated
parameters,

    \deqn{\psi_j = \sum b_{ij} \gamma_i,}

and the aggregate values are treated as error-free,

    \deqn{m_j = \psi_j.}

Although it is seldom realistic to treat an aggregate parameter as known
with certainty, there can be pragmatic reasons for doing so.  For
instance, statistical agencies sometimes require that disaggregated
estimates agree exactly with previously-published aggregate estimates.
(Within the literature on small area estimation, this practice is known
as 'benchmarking'.)  With \code{AgCertain}, agreement is guaranteed.
For instance, new estimates of obesity by age, educational status, and
region can be made to agree with existing estimates of obesity by region.
}

\section{\code{AgNormal}}{


The aggregate parameters are weighted sums or means of the disaggregated
parameters,

    \deqn{\psi_j = \sum b_{ij} \gamma_i.}

However, in contrast to \code{AgCertain}, the aggregate parameters are
assumed to be observed with error.  The errors have normal distributions,
with mean 0 and standard deviation \eqn{s_j}, so that

    \deqn{m_j ~ N(\psi_j, s_j^2).}

One possible application for \code{AgNormal} is 'inexact' benchmarking,
where the disaggregated parameters are pulled towards the benchmarks, but
complete agreement is not required.  Another application is where expert
judgements are treated as fallible.
}

\section{\code{AgPoisson}}{


\code{AgPoisson} is used only with Poisson models that contain an exposure
term.  The aggregate parameters are rates, obtained using

    \deqn{\psi_j = \sum b_{ij} \gamma_i,}

where the \eqn{b_{ij}} are proportional to exposures.  Let \eqn{n_j} be
exposure term associated with \eqn{\psi_i}.  The expected count implied by
\eqn{\psi_j} is then \eqn{\psi_j n_j}.  The expected count is implied by
aggregate value \eqn{m_j} is \eqn{m_j n_j}.  The two expected counts are
related by

    \deqn{m_j n_j ~ Poisson(\psi_j n_j).}
}

\section{\code{AgFun}}{


The aggregate parameters are obtained from the disaggregated parameters
through a user-defined function \eqn{f}.  Let \eqn{\gamma_{[j]}} denote the
vector of \eqn{\gamma_i} associated with aggregate parameter \eqn{\psi_j}.
Similarly let \eqn{b_{[j]}} denote the vector of \eqn{b_{ij}} associated
with \eqn{\psi_j}.  Then

    \deqn{\psi_j = f(\gamma_{[j]}, b_{[j]}).}

\code{AgFun} uses the same model as \code{AgNormal} for the accuracy of the
accuracy of the \eqn{m_j},

    \deqn{m_j ~ N(\psi_j, s_j^2).}

User-supplied function \code{FUN} must take two arguments, called \code{x}
and \code{weights}, and return a numeric vector of length 1.  The \code{x}
argument is for the \eqn{\gamma_{[j]}} and the \code{weights} argument is
for the \eqn{b_{[j]}}.  The values for \code{x} supplied to \code{FUN}
during estimation have class \code{\link[dembase:Values]{Values-class}}
and the values for \code{weights} have class
\code{\link[dembase:Counts]{Counts-class}}.  Function \code{FUN} can
take advantage of the metadata attached to \code{x} and \code{weights}:
see below for an example.
}
\examples{
## Overall value of 0.8 known with certainty
AgCertain(0.8)

## Separate values for females and males known
## with certainty
value <- ValuesOne(c(0.5, 1.1),
                   labels = c("Female", "Male"),
                   name = "sex")
AgCertain(value)

## Non-default weights
weights <- Counts(array(c(0.6, 0.3, 0.2, 0.4, 0.2, 0.3),
                        dim = c(2, 3),
                        dimnames = list(sex = c("Female", "Male"),
                                        region = c("A", "B", "C"))))
AgCertain(value = value, weights = weights)

## Overall value of 0.8, with all errors having
## standard deviation of 0.1
AgNormal(value = 0.8, sd = 0.1)

## Aggregate values and errors that vary by sex
sd <- ValuesOne(c(0.15, 0.25),
                labels = c("Female", "Male"),
                name = "sex")
AgNormal(value = value, sd = sd)

## Non-default standard deviation for proposal density
AgNormal(value = value, sd = sd, jump = 0.02)

## Poisson model
AgPoisson(value)

## TODO - AgFun
}
\seealso{
Aggregate values are typically specified as part of a call
to function \code{\link{Model}}.
}

